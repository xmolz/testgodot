This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.gd, **/*.tscn, **/*.gdshader
- Files matching these patterns are excluded: **/.godot/**, **.import/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
action_panel.tscn
action.gd
addons/dialogue_manager/compiler/compilation.gd
addons/dialogue_manager/compiler/compiled_line.gd
addons/dialogue_manager/compiler/compiler_regex.gd
addons/dialogue_manager/compiler/compiler_result.gd
addons/dialogue_manager/compiler/compiler.gd
addons/dialogue_manager/compiler/expression_parser.gd
addons/dialogue_manager/compiler/resolved_goto_data.gd
addons/dialogue_manager/compiler/resolved_line_data.gd
addons/dialogue_manager/compiler/resolved_tag_data.gd
addons/dialogue_manager/compiler/tree_line.gd
addons/dialogue_manager/components/code_edit_syntax_highlighter.gd
addons/dialogue_manager/components/code_edit.gd
addons/dialogue_manager/components/code_edit.tscn
addons/dialogue_manager/components/download_update_panel.gd
addons/dialogue_manager/components/download_update_panel.tscn
addons/dialogue_manager/components/editor_property/editor_property_control.gd
addons/dialogue_manager/components/editor_property/editor_property_control.tscn
addons/dialogue_manager/components/editor_property/editor_property.gd
addons/dialogue_manager/components/editor_property/resource_button.gd
addons/dialogue_manager/components/editor_property/resource_button.tscn
addons/dialogue_manager/components/errors_panel.gd
addons/dialogue_manager/components/errors_panel.tscn
addons/dialogue_manager/components/files_list.gd
addons/dialogue_manager/components/files_list.tscn
addons/dialogue_manager/components/find_in_files.gd
addons/dialogue_manager/components/find_in_files.tscn
addons/dialogue_manager/components/search_and_replace.gd
addons/dialogue_manager/components/search_and_replace.tscn
addons/dialogue_manager/components/title_list.gd
addons/dialogue_manager/components/title_list.tscn
addons/dialogue_manager/components/update_button.gd
addons/dialogue_manager/components/update_button.tscn
addons/dialogue_manager/constants.gd
addons/dialogue_manager/dialogue_label.gd
addons/dialogue_manager/dialogue_label.tscn
addons/dialogue_manager/dialogue_line.gd
addons/dialogue_manager/dialogue_manager.gd
addons/dialogue_manager/dialogue_resource.gd
addons/dialogue_manager/dialogue_response.gd
addons/dialogue_manager/dialogue_responses_menu.gd
addons/dialogue_manager/editor_translation_parser_plugin.gd
addons/dialogue_manager/example_balloon/example_balloon.gd
addons/dialogue_manager/example_balloon/example_balloon.tscn
addons/dialogue_manager/example_balloon/small_example_balloon.tscn
addons/dialogue_manager/export_plugin.gd
addons/dialogue_manager/import_plugin.gd
addons/dialogue_manager/inspector_plugin.gd
addons/dialogue_manager/plugin.gd
addons/dialogue_manager/settings.gd
addons/dialogue_manager/test_scene.gd
addons/dialogue_manager/test_scene.tscn
addons/dialogue_manager/utilities/builtins.gd
addons/dialogue_manager/utilities/dialogue_cache.gd
addons/dialogue_manager/views/main_view.gd
addons/dialogue_manager/views/main_view.tscn
aida.gd
aida.tscn
AidaDialogue.tscn
balloon.gd
black_screen_overlay.gd
black_screen_overlay.tscn
Boot.gd
Boot.tscn
camera_2d.gd
Cannathink.tscn
ChapterButton.gd
ChapterButton.tscn
character_conversation_overlay.gd
character_conversation_scene.tscn
CharacterConversationOverlay.tscn
conversationballoon.gd
conversationballoon.tscn
ConversationEventManager.gd
Cutscenes/ToiletClogCutscene.gd
DateInputWidget.gd
DateInputWidget.tscn
DigitSpinner.gd
DigitSpinner.tscn
explanation_data.gd
explanation_layer.gd
explanation_layer.gdshader
explanation_layer.tscn
FallbackManager.gd
GameManager.gd
GameManager.tscn
have_more_logo.tscn
hospital_bathroom_door.tscn
hospital_door.tscn
hospital_scrolling_wall_background.tscn
input_blocker.gd
insurance_form_button_ui.gd
insurance_form_button_ui.tscn
insurance_form.gd
insurance_form.tscn
interactable.gd
interactable.tscn
Interactables/Game World/Hospital Bathroom/hospital_bathroom_mirror.tscn
Interactables/Game World/Hospital Bathroom/hospital_bathroom_toilet_flush.tscn
Interactables/Game World/Hospital Bathroom/hospital_bathroom_toilet_paper.tscn
Interactables/Game World/Hospital Bathroom/hospital_toilet.gd
Interactables/Game World/Hospital Bathroom/hospital_toilet.tscn
Interactables/Game World/Hospital Room/medicine_cabinet.tscn
InteractionResponse.gd
interactions/actions/AddItemAction.gd
interactions/actions/CallMethodAction.gd
interactions/actions/DestroyAction.gd
interactions/actions/OpenMemoryBoxAction.gd
interactions/actions/OpenZoomViewAction.gd
interactions/actions/PlaySoundAction.gd
interactions/actions/RemoveItemAction.gd
interactions/actions/SayLineAction.gd
interactions/actions/SetLevelFlagAction.gd
interactions/actions/ShowCustomDialogueAction.gd
interactions/actions/ShowDialogueActiont.gd
interactions/actions/StartConversationAction.gd
interactions/actions/TeleportAction.gd
interactions/actions/TriggerCutsceneAction.gd
InventoryUI.gd
InventoryUI.tscn
Invigirol.tscn
ItemData.gd
level_state_manager.tscn
LevelStateManager.gd
LocationRow.gd
LocationRow.tscn
logo_splash.tscn
LogoSplash.gd
main_menu.tscn
Main.gd
main.tscn
MainMenu.gd
mcbucket_default_conversation.tscn
mcbucket_hyper_conversation.tscn
mcbucket_invigirol_conversation.tscn
mcbucket_med_dispenser.tscn
mcbucket_sleeping_conversation.tscn
mcbucket_thinking_conversation.tscn
mcbucket.gd
mcbucket.tscn
MedCabinetzoomin.tscn
memory_box.tscn
MemoryBoxOverlay.gd
MemoryBoxOverlay.tscn
MemoryChapterData.gd
MemoryGroupData.gd
Non Interactables/hospital_bathroom_sink.tscn
Notification.gd
Notification.tscn
NotificationManager.gd
NotificationManager.tscn
npc.gd
npc.tscn
object_zoom_overlay.gd
ObjectZoomOverlay.tscn
player.gd
player.tscn
Scripts/MedicineCabinetZoom.gd
Sergei_Conversation.tscn
sergei_med_dispenser.tscn
Sergei.tscn
sergey.gd
Shaders/grayscale_material.gdshader
SoundManager.gd
static_bathroom_background.tscn
static_wall_background_ventless.tscn
static_wall_background.tscn
Systems/Cutscene.gd
table.tscn
television_screen.gdshader
test_box.tscn
Test_Conversation.tscn
TransitionLayer.gd
TransitionLayer.tscn
tubelight.tscn
tv_controller.gd
tv.tscn
UI_cannathink.tscn
ui_interactable.gd
UI_Interactable.tscn
UI_Invigirol.tscn
UI_Zanopram.tscn
verb_ui_2.gd
VerbData.gd
VerbUI.gd
VerbUI.tscn
VerbUI2.tscn
WaypointMovement.gd
Zanopram.tscn
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Cutscenes/ToiletClogCutscene.gd">
extends Cutscene

# --- REFERENCES ---
@export_group("Actors")
@export var aida_npc: CharacterBody2D
@export var player: CharacterBody2D

@export_group("Objects")
@export var toilet_interactable: Interactable 

@export_group("Locations")
@export var main_room_door_pos: Marker2D 
@export var player_spawn_pos: Marker2D 
@export var bathroom_entry_pos: Marker2D 
@export var toilet_fix_pos: Marker2D 
@export var main_room_return_pos: Marker2D

@export_group("Dialogue")
@export var aida_scold_dialogue: DialogueResource
@export var scold_dialogue_start_id: String = "aida_toilet_clogged" 

@export_group("Settings")
@export var fix_duration: float = 25.0 

func _execution_steps():
	print_rich("[color=magenta][Time: %s] Cutscene START.[/color]" % Time.get_ticks_msec())
	
	# --- STEP 0: PRE-SETUP ---
	GameManager.set_current_level_flag("aida_fixing_toilet", true)
	
	var aida_mover = aida_npc.get_node_or_null("MovementController")
	if aida_mover: aida_mover.pause_movement()
	
	# Teleport Aida to waiting spot
	aida_npc.global_position = main_room_door_pos.global_position
	aida_npc.visible = true 
	
	# Face Aida
	var target_x = 0.0
	if player_spawn_pos: target_x = player_spawn_pos.global_position.x
	elif player: target_x = player.global_position.x
	if target_x < aida_npc.global_position.x:
		if aida_npc.has_node("Sprite"): aida_npc.get_node("Sprite").flip_h = true
	else:
		if aida_npc.has_node("Sprite"): aida_npc.get_node("Sprite").flip_h = false

	# Wait for fade-in
	await get_tree().create_timer(1.0).timeout

	# Face Player
	if player and player.has_method("face_target"):
		player.face_target(aida_npc.global_position)

	# --- STEP 1: DIALOGUE ---
	if aida_scold_dialogue:
		DialogueManager.show_dialogue_balloon_scene("res://conversationballoon.tscn", aida_scold_dialogue, scold_dialogue_start_id)
		await DialogueManager.dialogue_ended
	
	# --- STEP 2: ENTER BATHROOM ---
	aida_npc.visible = false 
	await get_tree().create_timer(0.5).timeout 
	
	aida_npc.global_position = bathroom_entry_pos.global_position
	aida_npc.visible = true
	
	# EARLY RELEASE
	print_rich("[color=magenta][Time: %s] Releasing Player Control.[/color]" % Time.get_ticks_msec())
	GameManager.change_game_state(GameManager.GameState.IN_GAME_PLAY)
	
	# --- BACKGROUND LOGIC ---
	
	# --- STEP 3: WALK TO TOILET ---
	if aida_mover:
		await aida_mover.move_to_position_async(toilet_fix_pos.global_position, 5.0, 10.0)
	
	# --- STEP 4: PLAY FIX ANIMATION ---
	var anim_player = aida_npc.get_node_or_null("AnimationPlayer")
	if anim_player and anim_player.has_animation("fix_toilet"):
		anim_player.play("fix_toilet")
		await get_tree().create_timer(fix_duration).timeout
		anim_player.play("idle")
	else:
		await get_tree().create_timer(5.0).timeout
	
	# --- STEP 5: UNCLOG TOILET ---
	if toilet_interactable:
		GameManager.set_current_level_flag("toilet_clogged", false)
		GameManager.set_current_level_flag("toilet_has_paper", false)
		
		var toilet_root = toilet_interactable.get_parent()
		if toilet_root and toilet_root.has_method("change_state"):
			toilet_root.change_state(0) 
	
	# --- STEP 6: LEAVE BATHROOM ---
	if aida_mover:
		await aida_mover.move_to_position_async(bathroom_entry_pos.global_position)
	
	aida_npc.visible = false
	await get_tree().create_timer(0.5).timeout
	
	# Teleport to Main Room Return Pos
	aida_npc.global_position = main_room_return_pos.global_position
	aida_npc.visible = true
	
	# ### MOVED FLAG RESET HERE ###
	# She is back in the main room. She is technically "Available" again.
	# If the player clogs the toilet NOW, we allow the cutscene to trigger, 
	# which will just snap her back to the door position instantly.
	GameManager.set_current_level_flag("aida_fixing_toilet", false)
	# ---------------------------
	
	# --- STEP 7: RETURN TO PATROL ---
	print_rich("[color=magenta][Time: %s] Aida returning to desk...[/color]" % Time.get_ticks_msec())
	
	# She is already physically at the Main Room Return Pos (due to teleport in Step 6).
	# We just need to sync her "Brain" to match her location.
	
	if aida_mover:
		# 1. Reset her internal target to the first waypoint (Desk)
		# This ensures she starts her route fresh, rather than walking to some random old target.
		if aida_mover.has_method("set_target_waypoint_index"):
			aida_mover.set_target_waypoint_index(0)
			
		# 2. Resume logic
		aida_mover.resume_movement()
		
	# Reset Busy Flag
	GameManager.set_current_level_flag("aida_fixing_toilet", false)
	
	print_rich("[color=magenta][Time: %s] Cutscene Script Complete.[/color]" % Time.get_ticks_msec())
</file>

<file path="interactions/actions/TriggerCutsceneAction.gd">
class_name TriggerCutsceneAction
extends Action

# The name of the Node in the scene tree that holds the cutscene script.
# Example: "ToiletClogCutscene"
@export var cutscene_node_name: String = ""

func execute(interactable_node: Interactable) -> bool:
	if cutscene_node_name == "":
		push_warning("TriggerCutsceneAction: No cutscene_node_name specified.")
		return true

	# We need to find the node. We assume it's in the current main scene.
	var root = interactable_node.get_tree().current_scene
	
	# Search for the node by name (recursive = true)
	var cutscene_node = root.find_child(cutscene_node_name, true, false)
	
	if cutscene_node and cutscene_node.has_method("start_cutscene"):
		# We DO NOT await this. 
		# Why? Because the Cutscene handles its own state (locking input/UI).
		# If we awaited here, the Interactable system would wait for the cutscene 
		# to end before marking the interaction as "complete". 
		# But the Cutscene switches GameState, which might conflict with Interactable cleanup.
		# It is cleaner to fire-and-forget here, letting the Cutscene take full control.
		cutscene_node.start_cutscene()
	else:
		push_error("TriggerCutsceneAction: Could not find Cutscene Node named '%s' (or it lacks start_cutscene method)." % cutscene_node_name)
		
	return true
</file>

<file path="Scripts/MedicineCabinetZoom.gd">
extends ObjectZoomOverlay

@export var caught_dialogue_resource: DialogueResource
@export var caught_dialogue_start_id: String = "aida_caught_snooping"

func _ready():
	super._ready()
	
	print_rich("[color=orange]MedicineCabinet: Zoom opened. Forcing Game Unpause to allow Aida to move.[/color]")
	get_tree().paused = false
	
	if GameManager and GameManager.current_level_state_manager:
		if not GameManager.current_level_state_manager.level_flag_changed.is_connected(_on_level_flag_changed):
			GameManager.current_level_state_manager.level_flag_changed.connect(_on_level_flag_changed)

func _on_level_flag_changed(flag_name: String, new_value: bool):
	if flag_name == "aida_in_main_room" and new_value == true:
		print_rich("[color=red]MedicineCabinet: AIDA RETURNED! Triggering caught sequence.[/color]")
		_trigger_forced_exit()

func _trigger_forced_exit():
	_cleanup_and_queue_free()
	
	if caught_dialogue_resource:
		call_deferred("_start_caught_dialogue")

func _start_caught_dialogue():
	print_rich("[color=red]MedicineCabinet: Playing Caught Dialogue.[/color]")
	
	# --- THE FIX: Connect the cleanup signal! ---
	# We tell DialogueManager: "When this text finishes, tell GameManager to unlock the player."
	if GameManager:
		DialogueManager.dialogue_ended.connect(
			GameManager._on_dialogue_ended_for_object_dialogue,
			CONNECT_ONE_SHOT
		)
	# --------------------------------------------

	DialogueManager.show_dialogue_balloon_scene(
		"res://conversationballoon.tscn", 
		caught_dialogue_resource, 
		caught_dialogue_start_id
	)
</file>

<file path="Systems/Cutscene.gd">
class_name Cutscene
extends Node

# This signal allows the Trigger to know when we are done (useful for chaining)
signal cutscene_finished

# Call this to start the sequence
func start_cutscene():
	print_rich("[color=Orchid]CutsceneSystem: Starting cutscene '%s'[/color]" % name)
	
	# 1. Change GameState to CUTSCENE (This hides UI and blocks Input via GM)
	if GameManager:
		GameManager.change_game_state(GameManager.GameState.CUTSCENE)
	else:
		push_error("Cutscene: GameManager not found!")

	# 2. Run the specific steps for this cutscene
	await _execution_steps()
	
	# 3. Finish up
	_finish_cutscene()

# VIRTUAL FUNCTION: Override this in your specific cutscene script
func _execution_steps():
	# Default behavior: wait one frame so it's not instant
	await get_tree().process_frame

func _finish_cutscene():
	print_rich("[color=Orchid]CutsceneSystem: Finishing cutscene '%s'[/color]" % name)
	
	# 1. Restore GameState to PLAY (This restores UI and Input via GM)
	if GameManager:
		GameManager.change_game_state(GameManager.GameState.IN_GAME_PLAY)
	
	cutscene_finished.emit()
</file>

<file path="Test_Conversation.tscn">
[gd_scene load_steps=8 format=3 uid="uid://dojqgskjk44nk"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_irlht"]
[ext_resource type="Resource" uid="uid://bdwme0ug677oq" path="res://testdialogue.dialogue" id="2_irlht"]
[ext_resource type="Texture2D" uid="uid://cx4r1a1ci7vpj" path="res://sergei.PNG" id="3_pqeca"]
[ext_resource type="Texture2D" uid="uid://coo5k2phjvc1e" path="res://Protag.png" id="4_h5ikw"]
[ext_resource type="Material" uid="uid://dek82a5tuykas" path="res://Shaders/grayscale_material.tres" id="5_gt5sx"]
[ext_resource type="Texture2D" uid="uid://dg6a8t20eu1yu" path="res://Backgrounds/Sergey/sergey_neutral.png" id="6_l02a4"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_pqeca")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_irlht")
conversation_dialogue_file = ExtResource("2_irlht")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_h5ikw")
mental_image_shader = ExtResource("5_gt5sx")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(960.9997, 540.5)
scale = Vector2(0.5000002, 0.498611)
texture = ExtResource("6_l02a4")
centered = false

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6

[node name="MentalImageSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(960.9997, 540.5)
scale = Vector2(0.5000002, 0.498611)
texture = ExtResource("6_l02a4")
</file>

<file path="action_panel.tscn">
[gd_scene load_steps=2 format=3 uid="uid://b548w1pnhoun6"]

[ext_resource type="Texture2D" uid="uid://ku705x18lumh" path="res://Action panel(1).PNG" id="1_7buhs"]

[node name="ActionPanel" type="Node2D"]

[node name="ActionPanelSprite" type="Sprite2D" parent="."]
texture = ExtResource("1_7buhs")
centered = false
</file>

<file path="addons/dialogue_manager/compiler/compilation.gd">
## A single compilation instance of some dialogue.
class_name DMCompilation extends RefCounted


#region Compilation locals


## A list of file paths that were imported by this file.
var imported_paths: PackedStringArray = []
## A list of state names from "using" clauses.
var using_states: PackedStringArray = []
## A map of titles in this file.
var titles: Dictionary = {}
## The first encountered title in this file.
var first_title: String = ""
## A list of character names in this file.
var character_names: PackedStringArray = []
## A list of any compilation errors.
var errors: Array[Dictionary] = []
## A map of all compiled lines.
var lines: Dictionary = {}
## A flattened and simplified map of compiled lines for storage in a resource.
var data: Dictionary = {}


#endregion

#region Internal variables


# A list of all [RegEx] references
var regex: DMCompilerRegEx = DMCompilerRegEx.new()
# For parsing condition/mutation expressions
var expression_parser: DMExpressionParser = DMExpressionParser.new()

# A map of titles that came from imported files.
var _imported_titles: Dictionary = {}
# Used to keep track of circular imports.
var _imported_line_map: Dictionary = {}
# The number of imported lines.
var _imported_line_count: int = 0
# A list of already encountered static line IDs.
var _known_translation_keys: Dictionary = {}
# A noop for retrieving the next line without conditions.
var _first: Callable = func(_s): return true

# Title jumps are adjusted as they are parsed so any goto lines might need to be adjusted after they are first seen.
var _goto_lines: Dictionary = {}


#endregion

#region Main


## Compile some text.
func compile(text: String, path: String = ".") -> Error:
	titles = {}
	character_names = []

	parse_line_tree(build_line_tree(inject_imported_files(text + "\n=> END", path)))

	# Convert the compiles lines to a Dictionary so they can be stored.
	for id in lines:
		var line: DMCompiledLine = lines[id]
		data[id] = line.to_data()

	if errors.size() > 0:
		return ERR_PARSE_ERROR

	return OK


## Inject any imported files
func inject_imported_files(text: String, path: String) -> PackedStringArray:
	# Work out imports
	var known_imports: Dictionary = {}

	# Include the base file path so that we can get around circular dependencies
	known_imports[path.hash()] = "."

	var raw_lines: PackedStringArray = text.split("\n")

	for id in range(0, raw_lines.size()):
		var line = raw_lines[id]
		if is_import_line(line):
			var import_data: Dictionary = extract_import_path_and_name(line)

			if not import_data.has("path"): continue

			var import_hash: int = import_data.path.hash()
			if import_data.size() > 0:
				# Keep track of titles so we can add imported ones later
				if str(import_hash) in _imported_titles.keys():
					add_error(id, 0, DMConstants.ERR_FILE_ALREADY_IMPORTED)
				if import_data.prefix in _imported_titles.values():
					add_error(id, 0, DMConstants.ERR_DUPLICATE_IMPORT_NAME)
				_imported_titles[str(import_hash)] = import_data.prefix

				# Import the file content
				if not known_imports.has(import_hash):
					var error: Error = import_content(import_data.path, import_data.prefix, _imported_line_map, known_imports)
					if error != OK:
						add_error(id, 0, error)

				# Make a map so we can refer compiled lines to where they were imported from
				if not _imported_line_map.has(import_hash):
					_imported_line_map[import_hash] = {
						hash = import_hash,
						imported_on_line_number = id,
						from_line = 0,
						to_line = 0
					}

	var imported_content: String =  ""
	var cummulative_line_number: int = 0
	for item in _imported_line_map.values():
		item["from_line"] = cummulative_line_number
		if known_imports.has(item.hash):
			cummulative_line_number += known_imports[item.hash].split("\n").size()
		item["to_line"] = cummulative_line_number
		if known_imports.has(item.hash):
			imported_content += known_imports[item.hash] + "\n"

	if imported_content == "":
		_imported_line_count = 0
		return text.split("\n")
	else:
		_imported_line_count = cummulative_line_number + 1
		# Combine imported lines with the original lines
		return (imported_content + "\n" + text).split("\n")


## Import content from another dialogue file or return an ERR
func import_content(path: String, prefix: String, imported_line_map: Dictionary, known_imports: Dictionary) -> Error:
	if FileAccess.file_exists(path):
		var file = FileAccess.open(path, FileAccess.READ)
		var content: PackedStringArray = file.get_as_text().strip_edges().split("\n")

		for index in range(0, content.size()):
			var line = content[index]
			if is_import_line(line):
				var import = extract_import_path_and_name(line)
				if import.size() > 0:
					if not known_imports.has(import.path.hash()):
						# Add an empty record into the keys just so we don't end up with cyclic dependencies
						known_imports[import.path.hash()] = ""
						if import_content(import.path, import.prefix, imported_line_map, known_imports) != OK:
							return ERR_LINK_FAILED

					if not imported_line_map.has(import.path.hash()):
						# Make a map so we can refer compiled lines to where they were imported from
						imported_line_map[import.path.hash()] = {
							hash = import.path.hash(),
							imported_on_line_number = index,
							from_line = 0,
							to_line = 0
						}

					_imported_titles[import.prefix] = import.path.hash()

		var origin_hash: int = -1
		for hash_value in known_imports.keys():
			if known_imports[hash_value] == ".":
				origin_hash = hash_value

		# Replace any titles or jump points with references to the files they point to (event if they point to their own file)
		for i in range(0, content.size()):
			var line = content[i]
			if line.strip_edges().begins_with("~ "):
				var indent: String = "\t".repeat(get_indent(line))
				var title = line.strip_edges().substr(2)
				if "/" in line:
					var bits = title.split("/")
					content[i] = "%s~ %s/%s" % [indent, _imported_titles[bits[0]], bits[1]]
				else:
					content[i] = "%s~ %s/%s" % [indent, str(path.hash()), title]

			elif "=>< " in line:
				var jump: String = line.substr(line.find("=>< ") + "=>< ".length()).strip_edges()
				if "/" in jump:
					var bits: PackedStringArray = jump.split("/")
					var title_hash: int = _imported_titles[bits[0]]
					if title_hash == origin_hash:
						content[i] = "%s=>< %s" % [line.split("=>< ")[0], bits[1]]
					else:
						content[i] = "%s=>< %s/%s" % [line.split("=>< ")[0], title_hash, bits[1]]

				elif not jump in ["END", "END!"]:
					content[i] = "%s=>< %s/%s" % [line.split("=>< ")[0], str(path.hash()), jump]

			elif "=> " in line:
				var jump: String = line.substr(line.find("=> ") + "=> ".length()).strip_edges()
				if "/" in jump:
					var bits: PackedStringArray = jump.split("/")
					var title_hash: int = _imported_titles[bits[0]]
					if title_hash == origin_hash:
						content[i] = "%s=> %s" % [line.split("=> ")[0], bits[1]]
					else:
						content[i] = "%s=> %s/%s" % [line.split("=> ")[0], title_hash, bits[1]]

				elif not jump in ["END", "END!"]:
					content[i] = "%s=> %s/%s" % [line.split("=> ")[0], str(path.hash()), jump]

		imported_paths.append(path)
		known_imports[path.hash()] = "\n".join(content) + "\n=> END\n"
		return OK
	else:
		return ERR_FILE_NOT_FOUND


## Build a tree of parent/child relationships
func build_line_tree(raw_lines: PackedStringArray) -> DMTreeLine:
	var root: DMTreeLine = DMTreeLine.new("")
	var parent_chain: Array[DMTreeLine] = [root]
	var previous_line: DMTreeLine
	var doc_comments: PackedStringArray = []

	# Get list of known autoloads
	var autoload_names: PackedStringArray = get_autoload_names()

	for i in range(0, raw_lines.size()):
		var raw_line: String = raw_lines[i]
		var tree_line: DMTreeLine = DMTreeLine.new(str(i - _imported_line_count))

		tree_line.line_number = i + 1
		tree_line.type = get_line_type(raw_line)
		tree_line.text = raw_line.strip_edges()

		# Handle any "using" directives.
		if tree_line.type == DMConstants.TYPE_USING:
			var using_match: RegExMatch = regex.USING_REGEX.search(raw_line)
			if "state" in using_match.names:
				var using_state: String = using_match.strings[using_match.names.state].strip_edges()
				if not using_state in autoload_names:
					add_error(tree_line.line_number, 0, DMConstants.ERR_UNKNOWN_USING)
				elif not using_state in using_states:
					using_states.append(using_state)
				continue
		# Ignore import lines because they've already been processed.
		elif is_import_line(raw_line):
			continue

		tree_line.indent = get_indent(raw_line)

		# Attach doc comments
		if raw_line.strip_edges().begins_with("##"):
			doc_comments.append(raw_line.replace("##", "").strip_edges())
		elif tree_line.type == DMConstants.TYPE_DIALOGUE:
			tree_line.notes = "\n".join(doc_comments)
			doc_comments.clear()

		# Empty lines are only kept so that we can work out groupings of things (eg. randomised
		# lines). Therefore we only need to keep one empty line in a row even if there
		# are multiple. The indent of an empty line is assumed to be the same as the non-empty line
		# following it. That way, grouping calculations should work.
		if tree_line.type in [DMConstants.TYPE_UNKNOWN, DMConstants.TYPE_COMMENT] and raw_lines.size() > i + 1:
			var next_line = raw_lines[i + 1]
			if get_line_type(next_line) in [DMConstants.TYPE_UNKNOWN, DMConstants.TYPE_COMMENT]:
				continue
			else:
				tree_line.type = DMConstants.TYPE_UNKNOWN
				tree_line.indent = get_indent(next_line)

		# Nothing should be more than a single indent past its parent.
		if tree_line.indent > parent_chain.size():
			add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_INVALID_INDENTATION)

		# Check for indentation changes
		if tree_line.indent > parent_chain.size() - 1:
			parent_chain.append(previous_line)
		elif tree_line.indent < parent_chain.size() - 1:
			parent_chain.resize(tree_line.indent + 1)

		# Add any titles to the list of known titles
		if tree_line.type == DMConstants.TYPE_TITLE:
			var title: String = tree_line.text.substr(2)
			if title == "":
				add_error(i, 2, DMConstants.ERR_EMPTY_TITLE)
			elif titles.has(title):
				add_error(i, 2, DMConstants.ERR_DUPLICATE_TITLE)
			else:
				titles[title] = tree_line.id
				if "/" in title:
					# Replace the hash title with something human readable.
					var bits: PackedStringArray = title.split("/")
					if _imported_titles.has(bits[0]):
						title = _imported_titles[bits[0]] + "/" + bits[1]
						titles[title] = tree_line.id
				elif first_title == "" and i >= _imported_line_count:
					first_title = tree_line.id

		# Append the current line to the current parent (note: the root is the most basic parent).
		var parent: DMTreeLine = parent_chain[parent_chain.size() - 1]
		tree_line.parent = weakref(parent)
		parent.children.append(tree_line)

		previous_line = tree_line

	return root


#endregion

#region Parsing


func parse_line_tree(root: DMTreeLine, parent: DMCompiledLine = null) -> Array[DMCompiledLine]:
	var compiled_lines: Array[DMCompiledLine] = []

	for i in range(0, root.children.size()):
		var tree_line: DMTreeLine = root.children[i]
		var line: DMCompiledLine = DMCompiledLine.new(tree_line.id, tree_line.type)

		match line.type:
			DMConstants.TYPE_UNKNOWN:
				line.next_id = get_next_matching_sibling_id(root.children, i, parent, _first)

			DMConstants.TYPE_TITLE:
				parse_title_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_CONDITION:
				parse_condition_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_WHILE:
				parse_while_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_MATCH:
				parse_match_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_WHEN:
				parse_when_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_MUTATION:
				parse_mutation_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_GOTO:
				# Extract any weighted random calls before parsing dialogue
				if tree_line.text.begins_with("%"):
					parse_random_line(tree_line, line, root.children, i, parent)
				parse_goto_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_RESPONSE:
				parse_response_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_RANDOM:
				parse_random_line(tree_line, line, root.children, i, parent)

			DMConstants.TYPE_DIALOGUE:
				# Extract any weighted random calls before parsing dialogue
				if tree_line.text.begins_with("%"):
					parse_random_line(tree_line, line, root.children, i, parent)
				parse_dialogue_line(tree_line, line, root.children, i, parent)

		# Main line map is keyed by ID
		lines[line.id] = line

		# Returned lines order is preserved so that it can be used for compiling children
		compiled_lines.append(line)

	return compiled_lines


## Parse a title and apply it to the given line
func parse_title_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var result: Error = OK

	line.text = tree_line.text.substr(tree_line.text.find("~ ") + 2).strip_edges()

	# Titles can't have numbers as the first letter (unless they are external titles which get replaced with hashes)
	if tree_line.line_number >= _imported_line_count and regex.BEGINS_WITH_NUMBER_REGEX.search(line.text):
		result = add_error(tree_line.line_number, 2, DMConstants.ERR_TITLE_BEGINS_WITH_NUMBER)

	# Only import titles are allowed to have "/" in them
	var valid_title = regex.VALID_TITLE_REGEX.search(line.text.replace("/", ""))
	if not valid_title:
		result = add_error(tree_line.line_number, 2, DMConstants.ERR_TITLE_INVALID_CHARACTERS)

	line.next_id = get_next_matching_sibling_id(siblings, sibling_index, parent, _first)

	## Update the titles reference to point to the actual first line
	titles[line.text] = line.next_id

	## Update any lines that point to this title
	if _goto_lines.has(line.text):
		for goto_line in _goto_lines[line.text]:
			goto_line.next_id = line.next_id

	return result


## Parse a goto and apply it to the given line.
func parse_goto_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	# Work out where this line is jumping to.
	var goto_data: DMResolvedGotoData = DMResolvedGotoData.new(tree_line.text, titles)
	if goto_data.error:
		return add_error(tree_line.line_number, tree_line.indent + 2, goto_data.error)
	if goto_data.next_id or goto_data.expression:
		line.next_id = goto_data.next_id
		line.next_id_expression = goto_data.expression
		add_reference_to_title(goto_data.title, line)

	if goto_data.is_snippet:
		line.is_snippet = true
		line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, _first)

	return OK


## Parse a condition line and apply to the given line
func parse_condition_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	# Work out the next IDs before parsing the condition line itself so that the last
	# child can inherit from the chain.

	# Find the next conditional sibling that is part of this grouping (if there is one).
	for next_sibling: DMTreeLine in siblings.slice(sibling_index + 1):
		if not next_sibling.type in [DMConstants.TYPE_UNKNOWN, DMConstants.TYPE_CONDITION]:
			break
		elif next_sibling.type == DMConstants.TYPE_CONDITION:
			if next_sibling.text.begins_with("el"):
				line.next_sibling_id = next_sibling.id
				break
			else:
				break

	line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, func(s: DMTreeLine):
		# The next line that isn't a conditional or is a new "if"
		return s.type != DMConstants.TYPE_CONDITION or s.text.begins_with("if ")
	)
	# Any empty IDs should end the conversation.
	if line.next_id_after == DMConstants.ID_NULL:
		line.next_id_after = parent.next_id_after if parent != null and parent.next_id_after else DMConstants.ID_END

	# Having no nested body is an immediate failure.
	if tree_line.children.size() == 0:
		return add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_INVALID_CONDITION_INDENTATION)

	# Try to parse the conditional expression ("else" has no expression).
	if "if " in tree_line.text:
		var condition: Dictionary = extract_condition(tree_line.text, false, tree_line.indent)
		if condition.has("error"):
			return add_error(tree_line.line_number, condition.index, condition.error)
		else:
			line.expression = condition

	# Parse any nested body lines
	parse_children(tree_line, line)

	return OK


## Parse a while loop and apply it to the given line.
func parse_while_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, _first)

	# Parse the while condition
	var condition: Dictionary = extract_condition(tree_line.text, false, tree_line.indent)
	if condition.has("error"):
		return add_error(tree_line.line_number, condition.index, condition.error)
	else:
		line.expression = condition

	# Parse the nested body (it should take care of looping back to this line when it finishes)
	parse_children(tree_line, line)

	return OK


func parse_match_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var result: Error = OK

	# The next line after is the next sibling
	line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, _first)

	# Extract the condition to match to
	var condition: Dictionary = extract_condition(tree_line.text, false, tree_line.indent)
	if condition.has("error"):
		result = add_error(tree_line.line_number, condition.index, condition.error)
	else:
		line.expression = condition

	# Match statements should have children
	if tree_line.children.size() == 0:
		result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_INVALID_CONDITION_INDENTATION)

	# Check that all children are when or else.
	for child in tree_line.children:
		if child.type == DMConstants.TYPE_WHEN: continue
		if child.type == DMConstants.TYPE_UNKNOWN: continue
		if child.type == DMConstants.TYPE_CONDITION and child.text.begins_with("else"): continue

		result = add_error(child.line_number, child.indent, DMConstants.ERR_EXPECTED_WHEN_OR_ELSE)

	# Each child should be a "when" or "else". We don't need those lines themselves, just their
	# condition and the line they point to if the conditions passes.
	var children: Array[DMCompiledLine] = parse_children(tree_line, line)
	for child: DMCompiledLine in children:
		# "when" cases
		if child.type == DMConstants.TYPE_WHEN:
			line.siblings.append({
				condition = child.expression,
				next_id = child.next_id
			})
		# "else" case
		elif child.type == DMConstants.TYPE_CONDITION:
			if line.siblings.any(func(s): return s.has("is_else")):
				result = add_error(child.line_number, child.indent, DMConstants.ERR_ONLY_ONE_ELSE_ALLOWED)
			else:
				line.siblings.append({
					next_id = child.next_id,
					is_else = true
				})
		# Remove the line from the list of all lines because we don't need it any more.
		lines.erase(child.id)

	return result


func parse_when_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var result: Error = OK

	# This when line should be found inside a match line
	if parent.type != DMConstants.TYPE_MATCH:
		result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_WHEN_MUST_BELONG_TO_MATCH)

	# When lines should have children
	if tree_line.children.size() == 0:
		result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_INVALID_CONDITION_INDENTATION)

	# The next line after a when is the same as its parent match line
	line.next_id_after = parent.next_id_after

	# Extract the condition to match to
	var condition: Dictionary = extract_condition(tree_line.text, false, tree_line.indent)
	if condition.has("error"):
		result = add_error(tree_line.line_number, condition.index, condition.error)
	else:
		line.expression = condition

	parse_children(tree_line, line)

	return result


## Parse a mutation line and apply it to the given line
func parse_mutation_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var mutation: Dictionary = extract_mutation(tree_line.text)
	if mutation.has("error"):
		return add_error(tree_line.line_number, mutation.index, mutation.error)
	else:
		line.expression = mutation

	line.next_id = get_next_matching_sibling_id(siblings, sibling_index, parent, _first)

	return OK


## Parse a response and apply it to the given line.
func parse_response_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var result: Error = OK

	# Remove the "- "
	tree_line.text = tree_line.text.substr(2)

	# Extract the static line ID
	var static_line_id: String = extract_static_line_id(tree_line.text)
	if static_line_id:
		tree_line.text = tree_line.text.replace("[ID:%s]" % [static_line_id], "")
		line.translation_key = static_line_id

	# Handle conditional responses and remove them from the prompt text.
	if " [if " in tree_line.text:
		var condition = extract_condition(tree_line.text, true, tree_line.indent)
		if condition.has("error"):
			result = add_error(tree_line.line_number, condition.index, condition.error)
		else:
			line.expression = condition
			# Extract just the raw condition text
			var found: RegExMatch = regex.WRAPPED_CONDITION_REGEX.search(tree_line.text)
			line.expression_text = found.strings[found.names.expression]

			tree_line.text = regex.WRAPPED_CONDITION_REGEX.sub(tree_line.text, "").strip_edges()

	# Find the original response in this group of responses.
	var original_response: DMTreeLine = tree_line
	for i in range(sibling_index - 1, -1, -1):
		if siblings[i].type == DMConstants.TYPE_RESPONSE:
			original_response = siblings[i]
		elif siblings[i].type != DMConstants.TYPE_UNKNOWN:
			break

	# If it's the original response then set up an original line.
	if original_response == tree_line:
		line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, (func(s: DMTreeLine):
			# The next line that isn't a response.
			return not s.type in [DMConstants.TYPE_RESPONSE, DMConstants.TYPE_UNKNOWN]
		), true)
		line.responses = [line.id]
		# If this line has children then the next ID is the first child.
		if tree_line.children.size() > 0:
			parse_children(tree_line, line)
		# Otherwise use the same ID for after the random group.
		else:
			line.next_id = line.next_id_after
	# Otherwise let the original line know about it.
	else:
		var original_line: DMCompiledLine = lines[original_response.id]
		line.next_id_after = original_line.next_id_after
		line.siblings = original_line.siblings
		original_line.responses.append(line.id)
		# If this line has children then the next ID is the first child.
		if tree_line.children.size() > 0:
			parse_children(tree_line, line)
		# Otherwise use the original line's next ID after.
		else:
			line.next_id = original_line.next_id_after

	parse_character_and_dialogue(tree_line, line, siblings, sibling_index, parent)

	return OK


## Parse a randomised line
func parse_random_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	# Find the weight
	var weight: float = 1
	var found = regex.WEIGHTED_RANDOM_SIBLINGS_REGEX.search(tree_line.text + " ")
	var condition: Dictionary = {}
	if found:
		if found.names.has("weight"):
			weight = found.strings[found.names.weight].to_float()
		if found.names.has("condition"):
			condition = extract_condition(tree_line.text, true, tree_line.indent)

	# Find the original random sibling. It will be the jump off point.
	var original_sibling: DMTreeLine = tree_line
	for i in range(sibling_index - 1, -1, -1):
		if siblings[i] and siblings[i].is_random:
			original_sibling = siblings[i]
		else:
			break

	var weighted_sibling: Dictionary = { weight = weight, id = line.id, condition = condition }

	# If it's the original sibling then set up an original line.
	if original_sibling == tree_line:
		line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, (func(s: DMTreeLine):
			# The next line that isn't a randomised line.
			# NOTE: DMTreeLine.is_random won't be set at this point so we need to check for the "%" prefix.
			return not s.text.begins_with("%")
		), true)
		line.siblings = [weighted_sibling]
		# If this line has children then the next ID is the first child.
		if tree_line.children.size() > 0:
			parse_children(tree_line, line)
		# Otherwise use the same ID for after the random group.
		else:
			line.next_id = line.next_id_after

	# Otherwise let the original line know about it.
	else:
		var original_line: DMCompiledLine = lines[original_sibling.id]
		line.next_id_after = original_line.next_id_after
		line.siblings = original_line.siblings
		original_line.siblings.append(weighted_sibling)
		# If this line has children then the next ID is the first child.
		if tree_line.children.size() > 0:
			parse_children(tree_line, line)
		# Otherwise use the original line's next ID after.
		else:
			line.next_id = original_line.next_id_after

	# Remove the randomise syntax from the line.
	tree_line.text = regex.WEIGHTED_RANDOM_SIBLINGS_REGEX.sub(tree_line.text, "")
	tree_line.is_random = true

	return OK


## Parse some dialogue and apply it to the given line.
func parse_dialogue_line(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var result: Error = OK

	# Remove escape character
	if tree_line.text.begins_with("\\using"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\if"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\elif"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\else"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\while"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\match"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\when"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\do"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\set"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\-"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\~"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\=>"): tree_line.text = tree_line.text.substr(1)
	if tree_line.text.begins_with("\\%"): tree_line.text = tree_line.text.substr(1)

	# Append any further dialogue
	for i in range(0, tree_line.children.size()):
		var child: DMTreeLine = tree_line.children[i]
		if child.type == DMConstants.TYPE_DIALOGUE:
			# Nested dialogue lines cannot have further nested dialogue.
			if child.children.size() > 0:
				add_error(child.children[0].line_number, child.children[0].indent, DMConstants.ERR_INVALID_INDENTATION)
			# Mark this as a dialogue child of another dialogue line.
			child.is_nested_dialogue = true
			var child_line = DMCompiledLine.new("", DMConstants.TYPE_DIALOGUE)
			parse_character_and_dialogue(child, child_line, [], 0, parent)
			var child_static_line_id: String = extract_static_line_id(child.text)
			if child_line.character != "" or child_static_line_id != "":
				add_error(child.line_number, child.indent, DMConstants.ERR_UNEXPECTED_SYNTAX_ON_NESTED_DIALOGUE_LINE)
			# Check that only the last child (or none) has a jump reference
			if i < tree_line.children.size() - 1 and " =>" in child.text:
				add_error(child.line_number, child.indent, DMConstants.ERR_NESTED_DIALOGUE_INVALID_JUMP)
			if i == 0 and " =>" in tree_line.text:
				add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_NESTED_DIALOGUE_INVALID_JUMP)

			tree_line.text += "\n" + child.text
		elif child.type == DMConstants.TYPE_UNKNOWN:
			tree_line.text += "\n"
		else:
			result = add_error(child.line_number, child.indent, DMConstants.ERR_INVALID_INDENTATION)

	# Extract the static line ID
	var static_line_id: String = extract_static_line_id(tree_line.text)
	if static_line_id:
		tree_line.text = tree_line.text.replace(" [ID:", "[ID:").replace("[ID:%s]" % [static_line_id], "")
		line.translation_key = static_line_id

	# Check for simultaneous lines
	if tree_line.text.begins_with("| "):
		# Jumps are only allowed on the origin line.
		if " =>" in tree_line.text:
			result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_GOTO_NOT_ALLOWED_ON_CONCURRECT_LINES)
		# Check for a valid previous line.
		tree_line.text = tree_line.text.substr(2)
		var previous_sibling: DMTreeLine = siblings[sibling_index - 1]
		if previous_sibling.type != DMConstants.TYPE_DIALOGUE:
			result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_CONCURRENT_LINE_WITHOUT_ORIGIN)
		else:
			# Because the previous line's concurrent_lines array is the same as
			# any line before that this doesn't need to check any higher up.
			var previous_line: DMCompiledLine = lines[previous_sibling.id]
			previous_line.concurrent_lines.append(line.id)
			line.concurrent_lines = previous_line.concurrent_lines

	parse_character_and_dialogue(tree_line, line, siblings, sibling_index, parent)

	# Check for any inline expression errors
	var resolved_line_data: DMResolvedLineData = DMResolvedLineData.new("")
	var bbcodes: Array[Dictionary] = resolved_line_data.find_bbcode_positions_in_string(tree_line.text, true, true)
	for bbcode: Dictionary in bbcodes:
		var tag: String = bbcode.code
		var code: String = bbcode.raw_args
		if tag.begins_with("do") or tag.begins_with("set") or tag.begins_with("if"):
			var expression: Array = expression_parser.tokenise(code, DMConstants.TYPE_MUTATION, bbcode.start + bbcode.code.length())
			if expression.size() == 0:
				add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_INVALID_EXPRESSION)
			elif expression[0].type == DMConstants.TYPE_ERROR:
				add_error(tree_line.line_number, tree_line.indent + expression[0].i, expression[0].value)

	# If the line isn't part of a weighted random group then make it point to the next
	# available sibling.
	if line.next_id == DMConstants.ID_NULL and line.siblings.size() == 0:
		line.next_id = get_next_matching_sibling_id(siblings, sibling_index, parent, func(s: DMTreeLine):
			# Ignore concurrent lines.
			return not s.text.begins_with("| ")
		)

	return result


## Parse the character name and dialogue and apply it to a given line.
func parse_character_and_dialogue(tree_line: DMTreeLine, line: DMCompiledLine, siblings: Array[DMTreeLine], sibling_index: int, parent: DMCompiledLine) -> Error:
	var result: Error = OK

	var text: String = tree_line.text

	# Attach any doc comments.
	line.notes = tree_line.notes

	# Extract tags.
	var tag_data: DMResolvedTagData = DMResolvedTagData.new(text)
	line.tags = tag_data.tags
	text = tag_data.text_without_tags

	# Handle inline gotos and remove them from the prompt text.
	if " =><" in text:
		# Because of when the return point needs to be known at runtime we need to split
		# this line into two (otherwise the return point would be dependent on the balloon).
		var goto_data: DMResolvedGotoData = DMResolvedGotoData.new(text, titles)
		if goto_data.error:
			result = add_error(tree_line.line_number, tree_line.indent + 3, goto_data.error)
		if goto_data.next_id or goto_data.expression:
			text = goto_data.text_without_goto
			var goto_line: DMCompiledLine = DMCompiledLine.new(line.id + ".1", DMConstants.TYPE_GOTO)
			goto_line.next_id = goto_data.next_id
			line.next_id_expression = goto_data.expression
			if line.type == DMConstants.TYPE_RESPONSE:
				goto_line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, func(s: DMTreeLine):
					# If this is coming from a response then we want the next non-response line.
					return s.type != DMConstants.TYPE_RESPONSE
				)
			else:
				goto_line.next_id_after = get_next_matching_sibling_id(siblings, sibling_index, parent, _first)
			goto_line.is_snippet = true
			lines[goto_line.id] = goto_line
			line.next_id = goto_line.id
			add_reference_to_title(goto_data.title, goto_line)
	elif " =>" in text:
		var goto_data: DMResolvedGotoData = DMResolvedGotoData.new(text, titles)
		if goto_data.error:
			result = add_error(tree_line.line_number, tree_line.indent + 2, goto_data.error)
		if goto_data.next_id or goto_data.expression:
			text = goto_data.text_without_goto
			line.next_id = goto_data.next_id
			line.next_id_expression = goto_data.expression
			add_reference_to_title(goto_data.title, line)

	# Handle the dialogue.
	text = text.replace("\\:", "!ESCAPED_COLON!")
	if ": " in text:
		# If a character was given then split it out.
		var bits = Array(text.strip_edges().split(": "))
		line.character = bits.pop_front().strip_edges()
		if not line.character in character_names:
			character_names.append(line["character"])
		# Character names can have expressions in them.
		line.character_replacements = expression_parser.extract_replacements(line.character, tree_line.indent)
		for replacement in line.character_replacements:
			if replacement.has("error"):
				result = add_error(tree_line.line_number, replacement.index, replacement.error)
		text = ": ".join(bits).replace("!ESCAPED_COLON!", ":")
	else:
		line.character = ""
		text = text.replace("!ESCAPED_COLON!", ":")

	# Extract any expressions in the dialogue.
	line.text_replacements = expression_parser.extract_replacements(text, line.character.length() + 2 + tree_line.indent)
	for replacement in line.text_replacements:
		if replacement.has("error"):
			result = add_error(tree_line.line_number, replacement.index, replacement.error)

	# Replace any newlines.
	text = text.replace("\\n", "\n").strip_edges()

	# If there was no manual translation key then just use the text itself (unless this is a
	# child dialogue below another dialogue line).
	if not tree_line.is_nested_dialogue and line.translation_key == "":
		# Show an error if missing translations is enabled
		if DMSettings.get_setting(DMSettings.MISSING_TRANSLATIONS_ARE_ERRORS, false):
			result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_MISSING_ID)
		else:
			line.translation_key = text

	line.text = text

	# IDs can't be duplicated for text that doesn't match.
	if line.translation_key != "":
		if _known_translation_keys.has(line.translation_key) and _known_translation_keys.get(line.translation_key) != line.text:
			result = add_error(tree_line.line_number, tree_line.indent, DMConstants.ERR_DUPLICATE_ID)
		else:
			_known_translation_keys[line.translation_key] = line.text

	return result


#endregion

#region Errors


## Add a compilation error to the list. Returns the given error code.
func add_error(line_number: int, column_number: int, error: int) -> Error:
	# See if the error was in an imported file
	for item in _imported_line_map.values():
		if line_number < item.to_line:
			errors.append({
				line_number = item.imported_on_line_number,
				column_number = 0,
				error = DMConstants.ERR_ERRORS_IN_IMPORTED_FILE,
				external_error = error,
				external_line_number = line_number
			})
			return error

	# Otherwise, it's in this file
	errors.append({
		line_number = line_number - _imported_line_count,
		column_number = column_number,
		error = error
	})

	return error


#endregion

#region Helpers


## Get the names of any autoloads in the project.
func get_autoload_names() -> PackedStringArray:
	var autoloads: PackedStringArray = []

	var project = ConfigFile.new()
	project.load("res://project.godot")
	if project.has_section("autoload"):
		return Array(project.get_section_keys("autoload")).filter(func(key): return key != "DialogueManager")

	return autoloads


## Check if a line is importing another file.
func is_import_line(text: String) -> bool:
	return text.begins_with("import ") and " as " in text


## Extract the import information from an import line
func extract_import_path_and_name(line: String) -> Dictionary:
	var found: RegExMatch = regex.IMPORT_REGEX.search(line)
	if found:
		return {
			path = found.strings[found.names.path],
			prefix = found.strings[found.names.prefix]
		}
	else:
		return {}


## Get the indent of a raw line
func get_indent(raw_line: String) -> int:
	var tabs: RegExMatch = regex.INDENT_REGEX.search(raw_line)
	if tabs:
		return tabs.get_string().length()
	else:
		return 0


## Get the type of a raw line
func get_line_type(raw_line: String) -> String:
	raw_line = raw_line.strip_edges()
	var text: String = regex.WEIGHTED_RANDOM_SIBLINGS_REGEX.sub(raw_line + " ", "").strip_edges()

	if text.begins_with("import "):
		return DMConstants.TYPE_IMPORT

	if text.begins_with("using "):
		return DMConstants.TYPE_USING

	if text.begins_with("#"):
		return DMConstants.TYPE_COMMENT

	if text.begins_with("~ "):
		return DMConstants.TYPE_TITLE

	if text.begins_with("if ") or text.begins_with("elif") or text.begins_with("else"):
		return DMConstants.TYPE_CONDITION

	if text.begins_with("while "):
		return DMConstants.TYPE_WHILE

	if text.begins_with("match "):
		return DMConstants.TYPE_MATCH

	if text.begins_with("when "):
		return DMConstants.TYPE_WHEN

	if text.begins_with("do ") or text.begins_with("do! ") or text.begins_with("set "):
		return DMConstants.TYPE_MUTATION

	if text.begins_with("=> ") or text.begins_with("=>< "):
		return DMConstants.TYPE_GOTO

	if text.begins_with("- "):
		return DMConstants.TYPE_RESPONSE

	if raw_line.begins_with("%") and text.is_empty():
		return DMConstants.TYPE_RANDOM

	if not text.is_empty():
		return DMConstants.TYPE_DIALOGUE

	return DMConstants.TYPE_UNKNOWN


## Get the next sibling that passes a [Callable] matcher.
func get_next_matching_sibling_id(siblings: Array[DMTreeLine], from_index: int, parent: DMCompiledLine, matcher: Callable, with_empty_lines: bool = false) -> String:
	for i in range(from_index + 1, siblings.size()):
		var next_sibling: DMTreeLine = siblings[i]

		if not with_empty_lines:
			# Ignore empty lines
			if not next_sibling or next_sibling.type == DMConstants.TYPE_UNKNOWN:
				continue

		if matcher.call(next_sibling):
			return next_sibling.id

	# If no next ID can be found then check the parent for where to go next.
	if parent != null:
		return parent.id if parent.type == DMConstants.TYPE_WHILE else parent.next_id_after

	return DMConstants.ID_NULL


## Extract a static line ID from some text.
func extract_static_line_id(text: String) -> String:
		# Find a static translation key, eg. [ID:something]
	var found: RegExMatch = regex.STATIC_LINE_ID_REGEX.search(text)
	if found:
		return found.strings[found.names.id]
	else:
		return ""


## Extract a condition (or inline condition) from some text.
func extract_condition(text: String, is_wrapped: bool, index: int) -> Dictionary:
	var regex: RegEx = regex.WRAPPED_CONDITION_REGEX if is_wrapped else regex.CONDITION_REGEX
	var found: RegExMatch = regex.search(text)

	if found == null:
		return {
			index = 0,
			error = DMConstants.ERR_INCOMPLETE_EXPRESSION
		}

	var raw_condition: String = found.strings[found.names.expression]
	if raw_condition.ends_with(":"):
		raw_condition = raw_condition.substr(0, raw_condition.length() - 1)

	var expression: Array = expression_parser.tokenise(raw_condition, DMConstants.TYPE_CONDITION, index + found.get_start("expression"))

	if expression.size() == 0:
		return {
			index = index + found.get_start("expression"),
			error = DMConstants.ERR_INCOMPLETE_EXPRESSION
		}
	elif expression[0].type == DMConstants.TYPE_ERROR:
		return {
			index = expression[0].i,
			error = expression[0].value
		}
	else:
		return {
			expression = expression
		}


## Extract a mutation from some text.
func extract_mutation(text: String) -> Dictionary:
	var found: RegExMatch = regex.MUTATION_REGEX.search(text)

	if not found:
		return {
			index = 0,
			error = DMConstants.ERR_INCOMPLETE_EXPRESSION
		}

	if found.names.has("expression"):
		var expression: Array = expression_parser.tokenise(found.strings[found.names.expression], DMConstants.TYPE_MUTATION, found.get_start("expression"))
		if expression.size() == 0:
			return {
				index = found.get_start("expression"),
				error = DMConstants.ERR_INCOMPLETE_EXPRESSION
			}
		elif expression[0].type == DMConstants.TYPE_ERROR:
			return {
				index = expression[0].i,
				error = expression[0].value
			}
		else:
			return {
				expression = expression,
				is_blocking = not "!" in found.strings[found.names.keyword]
			}

	else:
		return {
			index = found.get_start(),
			error = DMConstants.ERR_INCOMPLETE_EXPRESSION
		}


## Keep track of lines referencing titles because their own next_id might not have been resolved yet.
func add_reference_to_title(title: String, line: DMCompiledLine) -> void:
	if title in [DMConstants.ID_END, DMConstants.ID_END_CONVERSATION, DMConstants.ID_NULL]: return

	if not _goto_lines.has(title):
		_goto_lines[title] = []
	_goto_lines[title].append(line)


## Parse a nested block of child lines
func parse_children(tree_line: DMTreeLine, line: DMCompiledLine) -> Array[DMCompiledLine]:
	var children = parse_line_tree(tree_line, line)
	if children.size() > 0:
		line.next_id = children.front().id
		# The last child should jump to the next line after its parent condition group
		var last_child: DMCompiledLine = children.back()
		if last_child.next_id == DMConstants.ID_NULL:
			last_child.next_id = line.next_id_after
			if last_child.siblings.size() > 0:
				for sibling in last_child.siblings:
					lines.get(sibling.id).next_id = last_child.next_id

	return children


#endregion
</file>

<file path="addons/dialogue_manager/compiler/compiled_line.gd">
## A compiled line of dialogue.
class_name DMCompiledLine extends RefCounted


## The ID of the line
var id: String
## The translation key (or static line ID).
var translation_key: String = ""
## The type of line.
var type: String = ""
## The character name.
var character: String = ""
## Any interpolation expressions for the character name.
var character_replacements: Array[Dictionary] = []
## The text of the line.
var text: String = ""
## Any interpolation expressions for the text.
var text_replacements: Array[Dictionary] = []
## Any response siblings associated with this line.
var responses: PackedStringArray = []
## Any randomise or case siblings for this line.
var siblings: Array[Dictionary] = []
## Any lines said simultaneously.
var concurrent_lines: PackedStringArray = []
## Any tags on this line.
var tags: PackedStringArray = []
## The condition or mutation expression for this line.
var expression: Dictionary = {}
## The express as the raw text that was given.
var expression_text: String = ""
## The next sequential line to go to after this line.
var next_id: String = ""
## The next line to go to after this line if it is unknown and compile time.
var next_id_expression: Array[Dictionary] = []
## Whether this jump line should return after the jump target sequence has ended.
var is_snippet: bool = false
## The ID of the next sibling line.
var next_sibling_id: String = ""
## The ID after this line if it belongs to a block (eg. conditions).
var next_id_after: String = ""
## Any doc comments attached to this line.
var notes: String = ""


#region Hooks


func _init(initial_id: String, initial_type: String) -> void:
	id = initial_id
	type = initial_type


func _to_string() -> String:
	var s: Array = [
		"[%s]" % [type],
		"%s:" % [character] if character != "" else null,
		text if text != "" else null,
		expression if expression.size() > 0 else null,
		"[%s]" % [",".join(tags)] if tags.size() > 0 else null,
		str(siblings) if siblings.size() > 0 else null,
		str(responses) if responses.size() > 0 else null,
		"=> END" if "end" in next_id else "=> %s" % [next_id],
		"(~> %s)" % [next_sibling_id] if next_sibling_id != "" else null,
		"(==> %s)" % [next_id_after] if next_id_after != "" else null,
	].filter(func(item): return item != null)

	return " ".join(s)


#endregion

#region Helpers


## Express this line as a [Dictionary] that can be stored in a resource.
func to_data() -> Dictionary:
	var d: Dictionary = {
		id = id,
		type = type,
		next_id = next_id
	}

	if next_id_expression.size() > 0:
		d.next_id_expression = next_id_expression

	match type:
		DMConstants.TYPE_CONDITION:
			d.condition = expression
			if not next_sibling_id.is_empty():
				d.next_sibling_id = next_sibling_id
			d.next_id_after = next_id_after

		DMConstants.TYPE_WHILE:
			d.condition = expression
			d.next_id_after = next_id_after

		DMConstants.TYPE_MATCH:
			d.condition = expression
			d.next_id_after = next_id_after
			d.cases = siblings

		DMConstants.TYPE_MUTATION:
			d.mutation = expression

		DMConstants.TYPE_GOTO:
			d.is_snippet = is_snippet
			d.next_id_after = next_id_after
			if not siblings.is_empty():
				d.siblings = siblings

		DMConstants.TYPE_RANDOM:
			d.siblings = siblings

		DMConstants.TYPE_RESPONSE:
			d.text = text

			if not responses.is_empty():
				d.responses = responses

			if translation_key != text:
				d.translation_key = translation_key
			if not expression.is_empty():
				d.condition = expression
			if not character.is_empty():
				d.character = character
			if not character_replacements.is_empty():
				d.character_replacements = character_replacements
			if not text_replacements.is_empty():
				d.text_replacements = text_replacements
			if not tags.is_empty():
				d.tags = tags
			if not notes.is_empty():
				d.notes = notes
			if not expression_text.is_empty():
				d.condition_as_text = expression_text

		DMConstants.TYPE_DIALOGUE:
			d.text = text

			if translation_key != text:
				d.translation_key = translation_key

			if not character.is_empty():
				d.character = character
			if not character_replacements.is_empty():
				d.character_replacements = character_replacements
			if not text_replacements.is_empty():
				d.text_replacements = text_replacements
			if not tags.is_empty():
				d.tags = tags
			if not notes.is_empty():
				d.notes = notes
			if not siblings.is_empty():
				d.siblings = siblings
			if not concurrent_lines.is_empty():
				d.concurrent_lines = concurrent_lines

	return d


#endregion
</file>

<file path="addons/dialogue_manager/compiler/compiler_regex.gd">
## A collection of [RegEx] for use by the [DMCompiler].
class_name DMCompilerRegEx extends RefCounted


var IMPORT_REGEX: RegEx = RegEx.create_from_string("import \"(?<path>[^\"]+)\" as (?<prefix>[a-zA-Z_\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}][a-zA-Z_0-9\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}]+)")
var USING_REGEX: RegEx = RegEx.create_from_string("^using (?<state>.*)$")
var INDENT_REGEX: RegEx = RegEx.create_from_string("^\\t+")
var VALID_TITLE_REGEX: RegEx = RegEx.create_from_string("^[a-zA-Z_0-9\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}][a-zA-Z_0-9\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}]*$")
var BEGINS_WITH_NUMBER_REGEX: RegEx = RegEx.create_from_string("^\\d")
var CONDITION_REGEX: RegEx = RegEx.create_from_string("(if|elif|while|else if|match|when) (?<expression>.*)\\:?")
var WRAPPED_CONDITION_REGEX: RegEx = RegEx.create_from_string("\\[if (?<expression>.*)\\]")
var MUTATION_REGEX: RegEx = RegEx.create_from_string("(?<keyword>do|do!|set) (?<expression>.*)")
var STATIC_LINE_ID_REGEX: RegEx = RegEx.create_from_string("\\[ID:(?<id>.*?)\\]")
var WEIGHTED_RANDOM_SIBLINGS_REGEX: RegEx = RegEx.create_from_string("^\\%(?<weight>[\\d.]+)?( \\[if (?<condition>.+?)\\])? ")
var GOTO_REGEX: RegEx = RegEx.create_from_string("=><? (?<goto>.*)")

var INLINE_RANDOM_REGEX: RegEx = RegEx.create_from_string("\\[\\[(?<options>.*?)\\]\\]")
var INLINE_CONDITIONALS_REGEX: RegEx = RegEx.create_from_string("\\[if (?<condition>.+?)\\](?<body>.*?)\\[\\/if\\]")

var TAGS_REGEX: RegEx = RegEx.create_from_string("\\[#(?<tags>.*?)\\]")

var REPLACEMENTS_REGEX: RegEx = RegEx.create_from_string("{{(.*?)}}")

var ALPHA_NUMERIC: RegEx = RegEx.create_from_string("[^a-zA-Z0-9\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}]+")

var TOKEN_DEFINITIONS: Dictionary = {
	DMConstants.TOKEN_FUNCTION: RegEx.create_from_string("^[a-zA-Z_\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}][a-zA-Z_0-9\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}]*\\("),
	DMConstants.TOKEN_DICTIONARY_REFERENCE: RegEx.create_from_string("^[a-zA-Z_\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}][a-zA-Z_0-9\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}]*\\["),
	DMConstants.TOKEN_PARENS_OPEN: RegEx.create_from_string("^\\("),
	DMConstants.TOKEN_PARENS_CLOSE: RegEx.create_from_string("^\\)"),
	DMConstants.TOKEN_BRACKET_OPEN: RegEx.create_from_string("^\\["),
	DMConstants.TOKEN_BRACKET_CLOSE: RegEx.create_from_string("^\\]"),
	DMConstants.TOKEN_BRACE_OPEN: RegEx.create_from_string("^\\{"),
	DMConstants.TOKEN_BRACE_CLOSE: RegEx.create_from_string("^\\}"),
	DMConstants.TOKEN_COLON: RegEx.create_from_string("^:"),
	DMConstants.TOKEN_COMPARISON: RegEx.create_from_string("^(==|<=|>=|<|>|!=|in )"),
	DMConstants.TOKEN_ASSIGNMENT: RegEx.create_from_string("^(\\+=|\\-=|\\*=|/=|=)"),
	DMConstants.TOKEN_NUMBER: RegEx.create_from_string("^\\-?\\d+(\\.\\d+)?"),
	DMConstants.TOKEN_OPERATOR: RegEx.create_from_string("^(\\+|\\-|\\*|/|%)"),
	DMConstants.TOKEN_COMMA: RegEx.create_from_string("^,"),
	DMConstants.TOKEN_NULL_COALESCE: RegEx.create_from_string("^\\?\\."),
	DMConstants.TOKEN_DOT: RegEx.create_from_string("^\\."),
	DMConstants.TOKEN_STRING: RegEx.create_from_string("^&?(\".*?\"|\'.*?\')"),
	DMConstants.TOKEN_NOT: RegEx.create_from_string("^(not( |$)|!)"),
	DMConstants.TOKEN_AND_OR: RegEx.create_from_string("^(and|or|&&|\\|\\|)( |$)"),
	DMConstants.TOKEN_VARIABLE: RegEx.create_from_string("^[a-zA-Z_\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}][a-zA-Z_0-9\\p{Emoji_Presentation}\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Cyrillic}]*"),
	DMConstants.TOKEN_COMMENT: RegEx.create_from_string("^#.*"),
	DMConstants.TOKEN_CONDITION: RegEx.create_from_string("^(if|elif|else)"),
	DMConstants.TOKEN_BOOL: RegEx.create_from_string("^(true|false)")
}
</file>

<file path="addons/dialogue_manager/compiler/compiler_result.gd">
## The result of using the [DMCompiler] to compile some dialogue.
class_name DMCompilerResult extends RefCounted


## Any paths that were imported into the compiled dialogue file.
var imported_paths: PackedStringArray = []

## Any "using" directives.
var using_states: PackedStringArray = []

## All titles in the file and the line they point to.
var titles: Dictionary = {}

## The first title in the file.
var first_title: String = ""

## All character names.
var character_names: PackedStringArray = []

## Any compilation errors.
var errors: Array[Dictionary] = []

## A map of all compiled lines.
var lines: Dictionary = {}

## The raw dialogue text.
var raw_text: String = ""
</file>

<file path="addons/dialogue_manager/compiler/compiler.gd">
## A compiler of Dialogue Manager dialogue.
class_name DMCompiler extends RefCounted


## Compile a dialogue script.
static func compile_string(text: String, path: String) -> DMCompilerResult:
	var compilation: DMCompilation = DMCompilation.new()
	compilation.compile(text, path)

	var result: DMCompilerResult = DMCompilerResult.new()
	result.imported_paths = compilation.imported_paths
	result.using_states = compilation.using_states
	result.character_names = compilation.character_names
	result.titles = compilation.titles
	result.first_title = compilation.first_title
	result.errors = compilation.errors
	result.lines = compilation.data
	result.raw_text = text

	return result


## Get the line type of a string. The returned string will match one of the [code]TYPE_[/code] constants of [DMConstants].
static func get_line_type(text: String) -> String:
	var compilation: DMCompilation = DMCompilation.new()
	return compilation.get_line_type(text)


## Get the static line ID (eg. [code][ID:SOMETHING][/code]) of some text.
static func get_static_line_id(text: String) -> String:
	var compilation: DMCompilation = DMCompilation.new()
	return compilation.extract_static_line_id(text)


## Get the translatable part of a line.
static func extract_translatable_string(text: String) -> String:
	var compilation: DMCompilation = DMCompilation.new()

	var tree_line = DMTreeLine.new("")
	tree_line.text = text
	var line: DMCompiledLine = DMCompiledLine.new("", compilation.get_line_type(text))
	compilation.parse_character_and_dialogue(tree_line, line, [tree_line], 0, null)

	return line.text


## Get the known titles in a dialogue script.
static func get_titles_in_text(text: String, path: String) -> Dictionary:
	var compilation: DMCompilation = DMCompilation.new()
	compilation.build_line_tree(compilation.inject_imported_files(text, path))
	return compilation.titles
</file>

<file path="addons/dialogue_manager/compiler/expression_parser.gd">
## A class for parsing a condition/mutation expression for use with the [DMCompiler].
class_name DMExpressionParser extends RefCounted


var include_comments: bool = false


# Reference to the common [RegEx] that the parser needs.
var regex: DMCompilerRegEx = DMCompilerRegEx.new()


## Break a string down into an expression.
func tokenise(text: String, line_type: String, index: int) -> Array:
	var tokens: Array[Dictionary] = []
	var limit: int = 0
	while text.strip_edges() != "" and limit < 1000:
		limit += 1
		var found = _find_match(text)
		if found.size() > 0:
			tokens.append({
				index = index,
				type = found.type,
				value = found.value
			})
			index += found.value.length()
			text = found.remaining_text
		elif text.begins_with(" "):
			index += 1
			text = text.substr(1)
		else:
			return _build_token_tree_error([], DMConstants.ERR_INVALID_EXPRESSION, index)

	return _build_token_tree(tokens, line_type, "")[0]


## Extract any expressions from some text
func extract_replacements(text: String, index: int) -> Array[Dictionary]:
	var founds: Array[RegExMatch] = regex.REPLACEMENTS_REGEX.search_all(text)

	if founds == null or founds.size() == 0:
		return []

	var replacements: Array[Dictionary] = []
	for found in founds:
		var replacement: Dictionary = {}
		var value_in_text: String = found.strings[0].substr(0, found.strings[0].length() - 2).substr(2)

		# If there are closing curlie hard-up against the end of a {{...}} block then check for further
		# curlies just outside of the block.
		var text_suffix: String = text.substr(found.get_end(0))
		var expression_suffix: String = ""
		while text_suffix.begins_with("}"):
			expression_suffix += "}"
			text_suffix = text_suffix.substr(1)
		value_in_text += expression_suffix

		var expression: Array = tokenise(value_in_text, DMConstants.TYPE_DIALOGUE, index + found.get_start(1))
		if expression.size() == 0:
			replacement = {
				index = index + found.get_start(1),
				error = DMConstants.ERR_INCOMPLETE_EXPRESSION
			}
		elif expression[0].type == DMConstants.TYPE_ERROR:
			replacement = {
				index = expression[0].i,
				error = expression[0].value
			}
		else:
			replacement = {
				value_in_text = "{{%s}}" % value_in_text,
				expression = expression
			}
		replacements.append(replacement)

	return replacements


#region Helpers


# Create a token that represents an error.
func _build_token_tree_error(tree: Array, error: int, index: int) -> Array:
	tree.insert(0, {
		type = DMConstants.TOKEN_ERROR,
		value = error,
		i = index
	})
	return tree


# Convert a list of tokens into an abstract syntax tree.
func _build_token_tree(tokens: Array[Dictionary], line_type: String, expected_close_token: String) -> Array:
	var tree: Array[Dictionary] = []
	var limit = 0
	while tokens.size() > 0 and limit < 1000:
		limit += 1
		var token = tokens.pop_front()

		var error = _check_next_token(token, tokens, line_type, expected_close_token)
		if error != OK:
			var error_token: Dictionary = tokens[1] if tokens.size() > 1 else token
			return [_build_token_tree_error(tree, error, error_token.index), tokens]

		match token.type:
			DMConstants.TOKEN_COMMENT:
				if include_comments:
					tree.append({
						type = DMConstants.TOKEN_COMMENT,
						value = token.value,
						i = token.index
					})

			DMConstants.TOKEN_FUNCTION:
				var sub_tree = _build_token_tree(tokens, line_type, DMConstants.TOKEN_PARENS_CLOSE)

				if sub_tree[0].size() > 0 and sub_tree[0][0].type == DMConstants.TOKEN_ERROR:
					return [_build_token_tree_error(tree, sub_tree[0][0].value, sub_tree[0][0].i), tokens]

				tree.append({
					type = DMConstants.TOKEN_FUNCTION,
					# Consume the trailing "("
					function = token.value.substr(0, token.value.length() - 1),
					value = _tokens_to_list(sub_tree[0]),
					i = token.index
				})
				tokens = sub_tree[1]

			DMConstants.TOKEN_DICTIONARY_REFERENCE:
				var sub_tree = _build_token_tree(tokens, line_type, DMConstants.TOKEN_BRACKET_CLOSE)

				if sub_tree[0].size() > 0 and sub_tree[0][0].type == DMConstants.TOKEN_ERROR:
					return [_build_token_tree_error(tree, sub_tree[0][0].value, sub_tree[0][0].i), tokens]

				var args = _tokens_to_list(sub_tree[0])
				if args.size() != 1:
					return [_build_token_tree_error(tree, DMConstants.ERR_INVALID_INDEX, token.index), tokens]

				tree.append({
					type = DMConstants.TOKEN_DICTIONARY_REFERENCE,
					# Consume the trailing "["
					variable = token.value.substr(0, token.value.length() - 1),
					value = args[0],
					i = token.index
				})
				tokens = sub_tree[1]

			DMConstants.TOKEN_BRACE_OPEN:
				var sub_tree = _build_token_tree(tokens, line_type, DMConstants.TOKEN_BRACE_CLOSE)

				if sub_tree[0].size() > 0 and sub_tree[0][0].type == DMConstants.TOKEN_ERROR:
					return [_build_token_tree_error(tree, sub_tree[0][0].value, sub_tree[0][0].i), tokens]

				var t = sub_tree[0]
				for i in range(0, t.size() - 2):
					# Convert Lua style dictionaries to string keys
					if t[i].type == DMConstants.TOKEN_VARIABLE and t[i+1].type == DMConstants.TOKEN_ASSIGNMENT:
						t[i].type = DMConstants.TOKEN_STRING
						t[i+1].type = DMConstants.TOKEN_COLON
						t[i+1].erase("value")

				tree.append({
					type = DMConstants.TOKEN_DICTIONARY,
					value = _tokens_to_dictionary(sub_tree[0]),
					i = token.index
				})

				tokens = sub_tree[1]

			DMConstants.TOKEN_BRACKET_OPEN:
				var sub_tree = _build_token_tree(tokens, line_type, DMConstants.TOKEN_BRACKET_CLOSE)

				if sub_tree[0].size() > 0 and sub_tree[0][0].type == DMConstants.TOKEN_ERROR:
					return [_build_token_tree_error(tree, sub_tree[0][0].value, sub_tree[0][0].i), tokens]

				var type = DMConstants.TOKEN_ARRAY
				var value = _tokens_to_list(sub_tree[0])

				# See if this is referencing a nested dictionary value
				if tree.size() > 0:
					var previous_token = tree[tree.size() - 1]
					if previous_token.type in [DMConstants.TOKEN_DICTIONARY_REFERENCE, DMConstants.TOKEN_DICTIONARY_NESTED_REFERENCE]:
						type = DMConstants.TOKEN_DICTIONARY_NESTED_REFERENCE
						value = value[0]

				tree.append({
					type = type,
					value = value,
					i = token.index
				})
				tokens = sub_tree[1]

			DMConstants.TOKEN_PARENS_OPEN:
				var sub_tree = _build_token_tree(tokens, line_type, DMConstants.TOKEN_PARENS_CLOSE)

				if sub_tree[0].size() > 0 and sub_tree[0][0].type == DMConstants.TOKEN_ERROR:
					return [_build_token_tree_error(tree, sub_tree[0][0].value, sub_tree[0][0].i), tokens]

				tree.append({
					type = DMConstants.TOKEN_GROUP,
					value = sub_tree[0],
					i = token.index
				})
				tokens = sub_tree[1]

			DMConstants.TOKEN_PARENS_CLOSE, \
			DMConstants.TOKEN_BRACE_CLOSE, \
			DMConstants.TOKEN_BRACKET_CLOSE:
				if token.type != expected_close_token:
					return [_build_token_tree_error(tree, DMConstants.ERR_UNEXPECTED_CLOSING_BRACKET, token.index), tokens]

				tree.append({
					type = token.type,
					i = token.index
				})

				return [tree, tokens]

			DMConstants.TOKEN_NOT:
				# Double nots negate each other
				if tokens.size() > 0 and tokens.front().type == DMConstants.TOKEN_NOT:
					tokens.pop_front()
				else:
					tree.append({
						type = token.type,
						i = token.index
					})

			DMConstants.TOKEN_COMMA, \
			DMConstants.TOKEN_COLON, \
			DMConstants.TOKEN_DOT, \
			DMConstants.TOKEN_NULL_COALESCE:
				tree.append({
					type = token.type,
					i = token.index
				})

			DMConstants.TOKEN_COMPARISON, \
			DMConstants.TOKEN_ASSIGNMENT, \
			DMConstants.TOKEN_OPERATOR, \
			DMConstants.TOKEN_AND_OR, \
			DMConstants.TOKEN_VARIABLE:
				var value = token.value.strip_edges()
				if value == "&&":
					value = "and"
				elif value == "||":
					value = "or"
				tree.append({
					type = token.type,
					value = value,
					i = token.index
				})

			DMConstants.TOKEN_STRING:
				if token.value.begins_with("&"):
					tree.append({
						type = token.type,
						value = StringName(token.value.substr(2, token.value.length() - 3)),
						i = token.index
					})
				else:
					tree.append({
						type = token.type,
						value = token.value.substr(1, token.value.length() - 2),
						i = token.index
					})

			DMConstants.TOKEN_CONDITION:
				return [_build_token_tree_error(tree, DMConstants.ERR_UNEXPECTED_CONDITION, token.index), token]

			DMConstants.TOKEN_BOOL:
				tree.append({
					type = token.type,
					value = token.value.to_lower() == "true",
					i = token.index
				})

			DMConstants.TOKEN_NUMBER:
				var value = token.value.to_float() if "." in token.value else token.value.to_int()
				# If previous token is a number and this one is a negative number then
				# inject a minus operator token in between them.
				if tree.size() > 0 and token.value.begins_with("-") and tree[tree.size() - 1].type == DMConstants.TOKEN_NUMBER:
					tree.append(({
						type = DMConstants.TOKEN_OPERATOR,
						value = "-",
						i = token.index
					}))
					tree.append({
						type = token.type,
						value = -1 * value,
						i = token.index
					})
				else:
					tree.append({
						type = token.type,
						value = value,
						i = token.index
					})

	if expected_close_token != "":
		var index: int = tokens[0].i if tokens.size() > 0 else 0
		return [_build_token_tree_error(tree, DMConstants.ERR_MISSING_CLOSING_BRACKET, index), tokens]

	return [tree, tokens]


# Check the next token to see if it is valid to follow this one.
func _check_next_token(token: Dictionary, next_tokens: Array[Dictionary], line_type: String, expected_close_token: String) -> Error:
	var next_token: Dictionary = { type = null }
	if next_tokens.size() > 0:
		next_token = next_tokens.front()

	# Guard for assigning in a condition. If the assignment token isn't inside a Lua dictionary
	# then it's an unexpected assignment in a condition line.
	if token.type == DMConstants.TOKEN_ASSIGNMENT and line_type == DMConstants.TYPE_CONDITION and not next_tokens.any(func(t): return t.type == expected_close_token):
		return DMConstants.ERR_UNEXPECTED_ASSIGNMENT

	# Special case for a negative number after this one
	if token.type == DMConstants.TOKEN_NUMBER and next_token.type == DMConstants.TOKEN_NUMBER and next_token.value.begins_with("-"):
		return OK

	var expected_token_types = []
	var unexpected_token_types = []
	match token.type:
		DMConstants.TOKEN_FUNCTION, \
		DMConstants.TOKEN_PARENS_OPEN:
			unexpected_token_types = [
				null,
				DMConstants.TOKEN_COMMA,
				DMConstants.TOKEN_COLON,
				DMConstants.TOKEN_COMPARISON,
				DMConstants.TOKEN_ASSIGNMENT,
				DMConstants.TOKEN_OPERATOR,
				DMConstants.TOKEN_AND_OR,
				DMConstants.TOKEN_DOT
			]

		DMConstants.TOKEN_BRACKET_CLOSE:
			unexpected_token_types = [
				DMConstants.TOKEN_NOT,
				DMConstants.TOKEN_BOOL,
				DMConstants.TOKEN_STRING,
				DMConstants.TOKEN_NUMBER,
				DMConstants.TOKEN_VARIABLE
			]

		DMConstants.TOKEN_BRACE_OPEN:
			expected_token_types = [
				DMConstants.TOKEN_STRING,
				DMConstants.TOKEN_VARIABLE,
				DMConstants.TOKEN_NUMBER,
				DMConstants.TOKEN_BRACE_CLOSE
			]

		DMConstants.TOKEN_PARENS_CLOSE, \
		DMConstants.TOKEN_BRACE_CLOSE:
			unexpected_token_types = [
				DMConstants.TOKEN_NOT,
				DMConstants.TOKEN_ASSIGNMENT,
				DMConstants.TOKEN_BOOL,
				DMConstants.TOKEN_STRING,
				DMConstants.TOKEN_NUMBER,
				DMConstants.TOKEN_VARIABLE
			]

		DMConstants.TOKEN_COMPARISON, \
		DMConstants.TOKEN_OPERATOR, \
		DMConstants.TOKEN_DOT, \
		DMConstants.TOKEN_NULL_COALESCE, \
		DMConstants.TOKEN_NOT, \
		DMConstants.TOKEN_AND_OR, \
		DMConstants.TOKEN_DICTIONARY_REFERENCE:
			unexpected_token_types = [
				null,
				DMConstants.TOKEN_COMMA,
				DMConstants.TOKEN_COLON,
				DMConstants.TOKEN_COMPARISON,
				DMConstants.TOKEN_ASSIGNMENT,
				DMConstants.TOKEN_OPERATOR,
				DMConstants.TOKEN_AND_OR,
				DMConstants.TOKEN_PARENS_CLOSE,
				DMConstants.TOKEN_BRACE_CLOSE,
				DMConstants.TOKEN_BRACKET_CLOSE,
				DMConstants.TOKEN_DOT
			]

		DMConstants.TOKEN_COMMA:
			unexpected_token_types = [
				null,
				DMConstants.TOKEN_COMMA,
				DMConstants.TOKEN_COLON,
				DMConstants.TOKEN_ASSIGNMENT,
				DMConstants.TOKEN_OPERATOR,
				DMConstants.TOKEN_AND_OR,
				DMConstants.TOKEN_PARENS_CLOSE,
				DMConstants.TOKEN_BRACE_CLOSE,
				DMConstants.TOKEN_BRACKET_CLOSE,
				DMConstants.TOKEN_DOT
			]

		DMConstants.TOKEN_COLON:
			unexpected_token_types = [
				DMConstants.TOKEN_COMMA,
				DMConstants.TOKEN_COLON,
				DMConstants.TOKEN_COMPARISON,
				DMConstants.TOKEN_ASSIGNMENT,
				DMConstants.TOKEN_OPERATOR,
				DMConstants.TOKEN_AND_OR,
				DMConstants.TOKEN_PARENS_CLOSE,
				DMConstants.TOKEN_BRACE_CLOSE,
				DMConstants.TOKEN_BRACKET_CLOSE,
				DMConstants.TOKEN_DOT
			]

		DMConstants.TOKEN_BOOL, \
		DMConstants.TOKEN_STRING, \
		DMConstants.TOKEN_NUMBER:
			unexpected_token_types = [
				DMConstants.TOKEN_NOT,
				DMConstants.TOKEN_ASSIGNMENT,
				DMConstants.TOKEN_BOOL,
				DMConstants.TOKEN_STRING,
				DMConstants.TOKEN_NUMBER,
				DMConstants.TOKEN_VARIABLE,
				DMConstants.TOKEN_FUNCTION,
				DMConstants.TOKEN_PARENS_OPEN,
				DMConstants.TOKEN_BRACE_OPEN,
				DMConstants.TOKEN_BRACKET_OPEN
			]

		DMConstants.TOKEN_VARIABLE:
			unexpected_token_types = [
				DMConstants.TOKEN_NOT,
				DMConstants.TOKEN_BOOL,
				DMConstants.TOKEN_STRING,
				DMConstants.TOKEN_NUMBER,
				DMConstants.TOKEN_VARIABLE,
				DMConstants.TOKEN_FUNCTION,
				DMConstants.TOKEN_PARENS_OPEN,
				DMConstants.TOKEN_BRACE_OPEN,
				DMConstants.TOKEN_BRACKET_OPEN
			]

	if (expected_token_types.size() > 0 and not next_token.type in expected_token_types) \
	or (unexpected_token_types.size() > 0 and next_token.type in unexpected_token_types):
		match next_token.type:
			null:
				return DMConstants.ERR_UNEXPECTED_END_OF_EXPRESSION

			DMConstants.TOKEN_FUNCTION:
				return DMConstants.ERR_UNEXPECTED_FUNCTION

			DMConstants.TOKEN_PARENS_OPEN, \
			DMConstants.TOKEN_PARENS_CLOSE:
				return DMConstants.ERR_UNEXPECTED_BRACKET

			DMConstants.TOKEN_COMPARISON, \
			DMConstants.TOKEN_ASSIGNMENT, \
			DMConstants.TOKEN_OPERATOR, \
			DMConstants.TOKEN_NOT, \
			DMConstants.TOKEN_AND_OR:
				return DMConstants.ERR_UNEXPECTED_OPERATOR

			DMConstants.TOKEN_COMMA:
				return DMConstants.ERR_UNEXPECTED_COMMA
			DMConstants.TOKEN_COLON:
				return DMConstants.ERR_UNEXPECTED_COLON
			DMConstants.TOKEN_DOT:
				return DMConstants.ERR_UNEXPECTED_DOT

			DMConstants.TOKEN_BOOL:
				return DMConstants.ERR_UNEXPECTED_BOOLEAN
			DMConstants.TOKEN_STRING:
				return DMConstants.ERR_UNEXPECTED_STRING
			DMConstants.TOKEN_NUMBER:
				return DMConstants.ERR_UNEXPECTED_NUMBER
			DMConstants.TOKEN_VARIABLE:
				return DMConstants.ERR_UNEXPECTED_VARIABLE

		return DMConstants.ERR_INVALID_EXPRESSION

	return OK


# Convert a series of comma separated tokens to an [Array].
func _tokens_to_list(tokens: Array[Dictionary]) -> Array[Array]:
	var list: Array[Array] = []
	var current_item: Array[Dictionary] = []
	for token in tokens:
		if token.type == DMConstants.TOKEN_COMMA:
			list.append(current_item)
			current_item = []
		else:
			current_item.append(token)

	if current_item.size() > 0:
		list.append(current_item)

	return list


# Convert a series of key/value tokens into a [Dictionary]
func _tokens_to_dictionary(tokens: Array[Dictionary]) -> Dictionary:
	var dictionary = {}
	for i in range(0, tokens.size()):
		if tokens[i].type == DMConstants.TOKEN_COLON:
			if tokens.size() == i + 2:
				dictionary[tokens[i - 1]] = tokens[i + 1]
			else:
				dictionary[tokens[i - 1]] = { type = DMConstants.TOKEN_GROUP, value = tokens.slice(i + 1), i = tokens[0].i }

	return dictionary


# Work out what the next token is from a string.
func _find_match(input: String) -> Dictionary:
	for key in regex.TOKEN_DEFINITIONS.keys():
		var regex = regex.TOKEN_DEFINITIONS.get(key)
		var found = regex.search(input)
		if found:
			return {
				type = key,
				remaining_text = input.substr(found.strings[0].length()),
				value = found.strings[0]
			}

	return {}


#endregion
</file>

<file path="addons/dialogue_manager/compiler/resolved_goto_data.gd">
## Data associated with a dialogue jump/goto line.
class_name DMResolvedGotoData extends RefCounted


## The title that was specified
var title: String = ""
## The target line's ID
var next_id: String = ""
## An expression to determine the target line at runtime.
var expression: Array[Dictionary] = []
## The given line text with the jump syntax removed.
var text_without_goto: String = ""
## Whether this is a jump-and-return style jump.
var is_snippet: bool = false
## A parse error if there was one.
var error: int
## The index in the string where
var index: int = 0

# An instance of the compiler [RegEx] list.
var regex: DMCompilerRegEx = DMCompilerRegEx.new()


func _init(text: String, titles: Dictionary) -> void:
	if not "=> " in text and not "=>< " in text: return

	if "=> " in text:
		text_without_goto = text.substr(0, text.find("=> ")).strip_edges()
	elif "=>< " in text:
		is_snippet = true
		text_without_goto = text.substr(0, text.find("=>< ")).strip_edges()

	var found: RegExMatch = regex.GOTO_REGEX.search(text)
	if found == null:
		return

	title = found.strings[found.names.goto].strip_edges()
	index = found.get_start(0)

	if title == "":
		error = DMConstants.ERR_UNKNOWN_TITLE
		return

	# "=> END!" means end the conversation, ignoring any "=><" chains.
	if title == "END!":
		next_id = DMConstants.ID_END_CONVERSATION

	# "=> END" means end the current title (and go back to the previous one if there is one
	# in the stack)
	elif title == "END":
		next_id = DMConstants.ID_END

	elif titles.has(title):
		next_id = titles.get(title)
	elif title.begins_with("{{"):
		var expression_parser: DMExpressionParser = DMExpressionParser.new()
		var title_expression: Array[Dictionary] = expression_parser.extract_replacements(title, 0)
		if title_expression[0].has("error"):
			error = title_expression[0].error
		else:
			expression = title_expression[0].expression
	else:
		next_id = title
		error = DMConstants.ERR_UNKNOWN_TITLE


func _to_string() -> String:
	return "%s =>%s %s (%s)" % [text_without_goto, "<" if is_snippet else "", title, next_id]
</file>

<file path="addons/dialogue_manager/compiler/resolved_line_data.gd">
## Any data associated with inline dialogue BBCodes.
class_name DMResolvedLineData extends RefCounted

## The line's text
var text: String = ""
## A map of pauses against where they are found in the text.
var pauses: Dictionary = {}
## A map of speed changes against where they are found in the text.
var speeds: Dictionary = {}
## A list of any mutations to run and where they are found in the text.
var mutations: Array[Array] = []
## A duration reference for the line. Represented as "auto" or a stringified number.
var time: String = ""


func _init(line: String) -> void:
	text = line
	pauses = {}
	speeds = {}
	mutations = []
	time = ""

	var bbcodes: Array = []

	# Remove any escaped brackets (ie. "\[")
	var escaped_open_brackets: PackedInt32Array = []
	var escaped_close_brackets: PackedInt32Array = []
	for i in range(0, text.length() - 1):
		if text.substr(i, 2) == "\\[":
			text = text.substr(0, i) + "!" + text.substr(i + 2)
			escaped_open_brackets.append(i)
		elif text.substr(i, 2) == "\\]":
			text = text.substr(0, i) + "!" + text.substr(i + 2)
			escaped_close_brackets.append(i)

	# Extract all of the BB codes so that we know the actual text (we could do this easier with
	# a RichTextLabel but then we'd need to await idle_frame which is annoying)
	var bbcode_positions = find_bbcode_positions_in_string(text)
	var accumulaive_length_offset = 0
	for position in bbcode_positions:
		# Ignore our own markers
		if position.code in ["wait", "speed", "/speed", "do", "do!", "set", "next", "if", "else", "/if"]:
			continue

		bbcodes.append({
			bbcode = position.bbcode,
			start = position.start,
			offset_start = position.start - accumulaive_length_offset
		})
		accumulaive_length_offset += position.bbcode.length()

	for bb in bbcodes:
		text = text.substr(0, bb.offset_start) + text.substr(bb.offset_start + bb.bbcode.length())

	# Now find any dialogue markers
	var next_bbcode_position = find_bbcode_positions_in_string(text, false)
	var limit = 0
	while next_bbcode_position.size() > 0 and limit < 1000:
		limit += 1

		var bbcode = next_bbcode_position[0]

		var index = bbcode.start
		var code = bbcode.code
		var raw_args = bbcode.raw_args
		var args = {}
		if code in ["do", "do!", "set"]:
			var compilation: DMCompilation = DMCompilation.new()
			args["value"] = compilation.extract_mutation("%s %s" % [code, raw_args])
		else:
			# Could be something like:
			# 	"=1.0"
			# 	" rate=20 level=10"
			if raw_args and raw_args[0] == "=":
				raw_args = "value" + raw_args
			for pair in raw_args.strip_edges().split(" "):
				if "=" in pair:
					var bits = pair.split("=")
					args[bits[0]] = bits[1]

		match code:
			"wait":
				if pauses.has(index):
					pauses[index] += args.get("value").to_float()
				else:
					pauses[index] = args.get("value").to_float()
			"speed":
				speeds[index] = args.get("value").to_float()
			"/speed":
				speeds[index] = 1.0
			"do", "do!", "set":
				mutations.append([index, args.get("value")])
			"next":
				time = args.get("value") if args.has("value") else "0"

		# Find any BB codes that are after this index and remove the length from their start
		var length = bbcode.bbcode.length()
		for bb in bbcodes:
			if bb.offset_start > bbcode.start:
				bb.offset_start -= length
				bb.start -= length

		# Find any escaped brackets after this that need moving
		for i in range(0, escaped_open_brackets.size()):
			if escaped_open_brackets[i] > bbcode.start:
				escaped_open_brackets[i] -= length
		for i in range(0, escaped_close_brackets.size()):
			if escaped_close_brackets[i] > bbcode.start:
				escaped_close_brackets[i] -= length

		text = text.substr(0, index) + text.substr(index + length)
		next_bbcode_position = find_bbcode_positions_in_string(text, false)

	# Put the BB Codes back in
	for bb in bbcodes:
		text = text.insert(bb.start, bb.bbcode)

	# Put the escaped brackets back in
	for index in escaped_open_brackets:
		text = text.left(index) + "[" + text.right(text.length() - index - 1)
	for index in escaped_close_brackets:
		text = text.left(index) + "]" + text.right(text.length() - index - 1)


func find_bbcode_positions_in_string(string: String, find_all: bool = true, include_conditions: bool = false) -> Array[Dictionary]:
	if not "[" in string: return []

	var positions: Array[Dictionary] = []

	var open_brace_count: int = 0
	var start: int = 0
	var bbcode: String = ""
	var code: String = ""
	var is_finished_code: bool = false
	for i in range(0, string.length()):
		if string[i] == "[":
			if open_brace_count == 0:
				start = i
				bbcode = ""
				code = ""
				is_finished_code = false
			open_brace_count += 1

		else:
			if not is_finished_code and (string[i].to_upper() != string[i] or string[i] == "/" or string[i] == "!"):
				code += string[i]
			else:
				is_finished_code = true

		if open_brace_count > 0:
			bbcode += string[i]

		if string[i] == "]":
			open_brace_count -= 1
			if open_brace_count == 0 and (include_conditions or not code in ["if", "else", "/if"]):
				positions.append({
					bbcode = bbcode,
					code = code,
					start = start,
					end = i,
					raw_args = bbcode.substr(code.length() + 1, bbcode.length() - code.length() - 2).strip_edges()
				})

				if not find_all:
					return positions

	return positions
</file>

<file path="addons/dialogue_manager/compiler/resolved_tag_data.gd">
## Tag data associated with a line of dialogue.
class_name DMResolvedTagData extends RefCounted


## The list of tags.
var tags: PackedStringArray = []
## The line with any tag syntax removed.
var text_without_tags: String = ""

# An instance of the compiler [RegEx].
var regex: DMCompilerRegEx = DMCompilerRegEx.new()


func _init(text: String) -> void:
	var resolved_tags: PackedStringArray = []
	var tag_matches: Array[RegExMatch] = regex.TAGS_REGEX.search_all(text)
	for tag_match in tag_matches:
		text = text.replace(tag_match.get_string(), "")
		var tags = tag_match.get_string().replace("[#", "").replace("]", "").replace(", ", ",").split(",")
		for tag in tags:
			tag = tag.replace("#", "")
			if not tag in resolved_tags:
				resolved_tags.append(tag)

	tags = resolved_tags
	text_without_tags = text
</file>

<file path="addons/dialogue_manager/compiler/tree_line.gd">
## An intermediate representation of a dialogue line before it gets compiled.
class_name DMTreeLine extends RefCounted


## The line number where this dialogue was found (after imported files have had their content imported).
var line_number: int = 0
## The parent [DMTreeLine] of this line.
## This is stored as a Weak Reference so that this RefCounted can elegantly free itself.
## Without it being a Weak Reference, this can easily cause a cyclical reference that keeps this resource alive.
var parent: WeakRef
## The ID of this line.
var id: String
## The type of this line (as a [String] defined in [DMConstants].
var type: String = ""
## Is this line part of a randomised group?
var is_random: bool = false
## The indent count for this line.
var indent: int = 0
## The text of this line.
var text: String = ""
## The child [DMTreeLine]s of this line.
var children: Array[DMTreeLine] = []
## Any doc comments attached to this line.
var notes: String = ""
## Is this a dialogue line that is the child of another dialogue line?
var is_nested_dialogue: bool = false


func _init(initial_id: String) -> void:
	id = initial_id


func _to_string() -> String:
	var tabs = []
	tabs.resize(indent)
	tabs.fill("\t")
	tabs = "".join(tabs)

	return tabs.join([tabs + "{\n",
		"\tid: %s\n" % [id],
		"\ttype: %s\n" % [type],
		"\tis_random: %s\n" % ["true" if is_random else "false"],
		"\ttext: %s\n" % [text],
		"\tnotes: %s\n" % [notes],
		"\tchildren: []\n" if children.size() == 0 else "\tchildren: [\n" + ",\n".join(children.map(func(child): return str(child))) + "]\n",
	"}"])
</file>

<file path="addons/dialogue_manager/components/code_edit_syntax_highlighter.gd">
@tool
class_name DMSyntaxHighlighter extends SyntaxHighlighter


var regex: DMCompilerRegEx = DMCompilerRegEx.new()
var compilation: DMCompilation = DMCompilation.new()
var expression_parser = DMExpressionParser.new()

var cache: Dictionary = {}


func _clear_highlighting_cache() -> void:
	cache.clear()


func _get_line_syntax_highlighting(line: int) -> Dictionary:
	expression_parser.include_comments = true

	var colors: Dictionary = {}
	var text_edit: TextEdit = get_text_edit()
	var text: String = text_edit.get_line(line)

	# Prevent an error from popping up while developing
	if not is_instance_valid(text_edit) or text_edit.theme_overrides.is_empty():
		return colors

	# Disable this, as well as the line at the bottom of this function to remove the cache.
	if text in cache:
		return cache[text]

	var theme: Dictionary = text_edit.theme_overrides

	var index: int = 0

	match DMCompiler.get_line_type(text):
		DMConstants.TYPE_USING:
			colors[index] = { color = theme.conditions_color }
			colors[index + "using ".length()] = { color = theme.text_color }

		DMConstants.TYPE_IMPORT:
			colors[index] = { color = theme.conditions_color }
			var import: RegExMatch = regex.IMPORT_REGEX.search(text)
			if import:
				colors[index + import.get_start("path") - 1] = { color = theme.strings_color }
				colors[index + import.get_end("path") + 1] = { color = theme.conditions_color }
				colors[index + import.get_start("prefix")] = { color = theme.text_color }

		DMConstants.TYPE_COMMENT:
			colors[index] = { color = theme.comments_color }

		DMConstants.TYPE_TITLE:
			colors[index] = { color = theme.titles_color }

		DMConstants.TYPE_CONDITION, DMConstants.TYPE_WHILE, DMConstants.TYPE_MATCH, DMConstants.TYPE_WHEN:
			colors[0] = { color = theme.conditions_color }
			index = text.find(" ")
			if index > -1:
				var expression: Array = expression_parser.tokenise(text.substr(index), DMConstants.TYPE_CONDITION, 0)
				if expression.size() == 0:
					colors[index] = { color = theme.critical_color }
				else:
					_highlight_expression(expression, colors, index)

		DMConstants.TYPE_MUTATION:
			colors[0] = { color = theme.mutations_color }
			index = text.find(" ")
			var expression: Array = expression_parser.tokenise(text.substr(index), DMConstants.TYPE_MUTATION, 0)
			if expression.size() == 0:
				colors[index] = { color = theme.critical_color }
			else:
				_highlight_expression(expression, colors, index)

		DMConstants.TYPE_GOTO:
			if text.strip_edges().begins_with("%"):
				colors[index] = { color = theme.symbols_color }
				index = text.find(" ")
			_highlight_goto(text, colors, index)

		DMConstants.TYPE_RANDOM:
			colors[index] = { color = theme.symbols_color }

		DMConstants.TYPE_DIALOGUE, DMConstants.TYPE_RESPONSE:
			if text.strip_edges().begins_with("%"):
				colors[index] = { color = theme.symbols_color }
				index = text.find(" ", text.find("%"))
			colors[index] = { color = theme.text_color.lerp(theme.symbols_color, 0.5) }

			var dialogue_text: String = text.substr(index, text.find("=>"))

			# Highlight character name (but ignore ":" within line ID reference)
			var split_index: int = dialogue_text.replace("\\:", "??").find(":")
			if text.substr(split_index - 3, 3) != "[ID":
				colors[index + split_index + 1] = { color = theme.text_color }
			else:
				# If there's no character name then just highlight the text as dialogue.
				colors[index] = { color = theme.text_color }

			# Interpolation
			var replacements: Array[RegExMatch] = regex.REPLACEMENTS_REGEX.search_all(dialogue_text)
			for replacement: RegExMatch in replacements:
				var expression_text: String = replacement.get_string().substr(0, replacement.get_string().length() - 2).substr(2)
				var expression: Array = expression_parser.tokenise(expression_text, DMConstants.TYPE_MUTATION, replacement.get_start())
				var expression_index: int = index + replacement.get_start()
				colors[expression_index] = { color = theme.symbols_color }
				if expression.size() == 0 or expression[0].type == DMConstants.TYPE_ERROR:
					colors[expression_index] = { color = theme.critical_color }
				else:
					_highlight_expression(expression, colors, index + 2)
				colors[expression_index + expression_text.length() + 2] = { color = theme.symbols_color }
				colors[expression_index + expression_text.length() + 4] = { color = theme.text_color }
			# Tags (and inline mutations)
			var resolved_line_data: DMResolvedLineData = DMResolvedLineData.new("")
			var bbcodes: Array[Dictionary] = resolved_line_data.find_bbcode_positions_in_string(dialogue_text, true, true)
			for bbcode: Dictionary in bbcodes:
				var tag: String = bbcode.code
				var code: String = bbcode.raw_args
				if code.begins_with("["):
					colors[index + bbcode.start] = { color = theme.symbols_color }
					colors[index + bbcode.start + 2] = { color = theme.text_color }
					var pipe_cursor: int = code.find("|")
					while pipe_cursor > -1:
						colors[index + bbcode.start + pipe_cursor + 1] = { color = theme.symbols_color }
						colors[index + bbcode.start + pipe_cursor + 2] = { color = theme.text_color }
						pipe_cursor = code.find("|", pipe_cursor + 1)
					colors[index + bbcode.end - 1] = { color = theme.symbols_color }
					colors[index + bbcode.end + 1] = { color = theme.text_color }
				else:
					colors[index + bbcode.start] = { color = theme.symbols_color }
					if tag.begins_with("do") or tag.begins_with("set") or tag.begins_with("if"):
						if tag.begins_with("if"):
							colors[index + bbcode.start + 1] = { color = theme.conditions_color }
						else:
							colors[index + bbcode.start + 1] = { color = theme.mutations_color }
						var expression: Array = expression_parser.tokenise(code, DMConstants.TYPE_MUTATION, bbcode.start + bbcode.code.length())
						if expression.size() == 0 or expression[0].type == DMConstants.TYPE_ERROR:
							colors[index + bbcode.start + tag.length() + 1] = { color = theme.critical_color }
						else:
							_highlight_expression(expression, colors, index + 2)
					# else and closing if have no expression
					elif tag.begins_with("else") or tag.begins_with("/if"):
						colors[index + bbcode.start + 1] = { color = theme.conditions_color }
					colors[index + bbcode.end] = { color = theme.symbols_color }
					colors[index + bbcode.end + 1] = { color = theme.text_color }
			# Jumps
			if "=> " in text or "=>< " in text:
				_highlight_goto(text, colors, index)

	# Order the dictionary keys to prevent CodeEdit from having issues
	var ordered_colors: Dictionary = {}
	var ordered_keys: Array = colors.keys()
	ordered_keys.sort()
	for key_index: int in ordered_keys:
		ordered_colors[key_index] = colors[key_index]

	cache[text] = ordered_colors
	return ordered_colors


func _highlight_expression(tokens: Array, colors: Dictionary, index: int) -> int:
	var theme: Dictionary = get_text_edit().theme_overrides
	var last_index: int = index
	for token: Dictionary in tokens:
		last_index = token.i
		match token.type:
			DMConstants.TOKEN_COMMENT:
				colors[index + token.i] = { color = theme.comments_color }

			DMConstants.TOKEN_CONDITION, DMConstants.TOKEN_AND_OR:
				colors[index + token.i] = { color = theme.conditions_color }

			DMConstants.TOKEN_VARIABLE:
				if token.value in ["true", "false"]:
					colors[index + token.i] = { color = theme.conditions_color }
				else:
					colors[index + token.i] = { color = theme.members_color }

			DMConstants.TOKEN_OPERATOR, DMConstants.TOKEN_COLON, \
			DMConstants.TOKEN_COMMA, DMConstants.TOKEN_DOT, DMConstants.TOKEN_NULL_COALESCE, \
			DMConstants.TOKEN_NUMBER, DMConstants.TOKEN_ASSIGNMENT:
				colors[index + token.i] = { color = theme.symbols_color }

			DMConstants.TOKEN_STRING:
				colors[index + token.i] = { color = theme.strings_color }

			DMConstants.TOKEN_FUNCTION:
				colors[index + token.i] = { color = theme.mutations_color }
				colors[index + token.i + token.function.length()] = { color = theme.symbols_color }
				for parameter: Array in token.value:
					last_index = _highlight_expression(parameter, colors, index)
			DMConstants.TOKEN_PARENS_CLOSE:
				colors[index + token.i] = { color = theme.symbols_color }

			DMConstants.TOKEN_DICTIONARY_REFERENCE:
				colors[index + token.i] = { color = theme.members_color }
				colors[index + token.i + token.variable.length()] = { color = theme.symbols_color }
				last_index = _highlight_expression(token.value, colors, index)
			DMConstants.TOKEN_ARRAY:
				colors[index + token.i] = { color = theme.symbols_color }
				for item: Array in token.value:
					last_index = _highlight_expression(item, colors, index)
			DMConstants.TOKEN_BRACKET_CLOSE:
				colors[index + token.i] = { color = theme.symbols_color }

			DMConstants.TOKEN_DICTIONARY:
				colors[index + token.i] = { color = theme.symbols_color }
				last_index = _highlight_expression(token.value.keys() + token.value.values(), colors, index)
			DMConstants.TOKEN_BRACE_CLOSE:
				colors[index + token.i] = { color = theme.symbols_color }
				last_index += 1

			DMConstants.TOKEN_GROUP:
				last_index = _highlight_expression(token.value, colors, index)

	return last_index


func _highlight_goto(text: String, colors: Dictionary, index: int) -> int:
	var theme: Dictionary = get_text_edit().theme_overrides
	var goto_data: DMResolvedGotoData = DMResolvedGotoData.new(text, {})
	colors[goto_data.index] = { color = theme.jumps_color }
	if "{{" in text:
		index = text.find("{{", goto_data.index)
		var last_index: int = 0
		if goto_data.error:
			colors[index + 2] = { color = theme.critical_color }
		else:
			last_index = _highlight_expression(goto_data.expression, colors, index)
		index = text.find("}}", index + last_index)
		colors[index] = { color = theme.jumps_color }

	return index
</file>

<file path="addons/dialogue_manager/components/code_edit.gd">
@tool
class_name DMCodeEdit extends CodeEdit


signal active_title_change(title: String)
signal error_clicked(line_number: int)
signal external_file_requested(path: String, title: String)


# A link back to the owner `MainView`
var main_view

# Theme overrides for syntax highlighting, etc
var theme_overrides: Dictionary:
	set(value):
		theme_overrides = value

		syntax_highlighter = DMSyntaxHighlighter.new()

		# General UI
		add_theme_color_override("font_color", theme_overrides.text_color)
		add_theme_color_override("background_color", theme_overrides.background_color)
		add_theme_color_override("current_line_color", theme_overrides.current_line_color)
		add_theme_font_override("font", get_theme_font("source", "EditorFonts"))
		add_theme_font_size_override("font_size", theme_overrides.font_size * theme_overrides.scale)
		font_size = round(theme_overrides.font_size)
	get:
		return theme_overrides

# Any parse errors
var errors: Array:
	set(next_errors):
		errors = next_errors
		for i in range(0, get_line_count()):
			var is_error: bool = false
			for error in errors:
				if error.line_number == i:
					is_error = true
			mark_line_as_error(i, is_error)
		_on_code_edit_caret_changed()
	get:
		return errors

# The last selection (if there was one) so we can remember it for refocusing
var last_selected_text: String

var font_size: int:
	set(value):
		font_size = value
		add_theme_font_size_override("font_size", font_size * theme_overrides.scale)
	get:
		return font_size

var WEIGHTED_RANDOM_PREFIX: RegEx = RegEx.create_from_string("^\\%[\\d.]+\\s")

var compiler_regex: DMCompilerRegEx = DMCompilerRegEx.new()
var _autoloads: Dictionary[String, String] = {}
var _autoload_member_cache: Dictionary[String, Dictionary] = {}


func _ready() -> void:
	# Add error gutter
	add_gutter(0)
	set_gutter_type(0, TextEdit.GUTTER_TYPE_ICON)

	# Add comment delimiter
	if not has_comment_delimiter("#"):
		add_comment_delimiter("#", "", true)

	syntax_highlighter = DMSyntaxHighlighter.new()

	# Keep track of any autoloads
	ProjectSettings.settings_changed.connect(_on_project_settings_changed)
	_on_project_settings_changed()


func _gui_input(event: InputEvent) -> void:
	# Handle shortcuts that come from the editor
	if event is InputEventKey and event.is_pressed():
		var shortcut: String = Engine.get_meta("DialogueManagerPlugin").get_editor_shortcut(event)
		match shortcut:
			"toggle_comment":
				toggle_comment()
				get_viewport().set_input_as_handled()
			"delete_line":
				delete_current_line()
				get_viewport().set_input_as_handled()
			"move_up":
				move_line(-1)
				get_viewport().set_input_as_handled()
			"move_down":
				move_line(1)
				get_viewport().set_input_as_handled()
			"text_size_increase":
				self.font_size += 1
				get_viewport().set_input_as_handled()
			"text_size_decrease":
				self.font_size -= 1
				get_viewport().set_input_as_handled()
			"text_size_reset":
				self.font_size = theme_overrides.font_size
				get_viewport().set_input_as_handled()

	elif event is InputEventMouse:
		match event.as_text():
			"Ctrl+Mouse Wheel Up", "Command+Mouse Wheel Up":
				self.font_size += 1
				get_viewport().set_input_as_handled()
			"Ctrl+Mouse Wheel Down", "Command+Mouse Wheel Down":
				self.font_size -= 1
				get_viewport().set_input_as_handled()


func _can_drop_data(at_position: Vector2, data) -> bool:
	if typeof(data) != TYPE_DICTIONARY: return false
	if data.type != "files": return false

	var files: PackedStringArray = Array(data.files)
	return files.size() > 0


func _drop_data(at_position: Vector2, data) -> void:
	var replace_regex: RegEx = RegEx.create_from_string("[^a-zA-Z_0-9]+")

	var files: PackedStringArray = Array(data.files)
	for file in files:
		# Don't import the file into itself
		if file == main_view.current_file_path: continue

		if file.get_extension() == "dialogue":
			var path = file.replace("res://", "").replace(".dialogue", "")
			# Find the first non-import line in the file to add our import
			var lines = text.split("\n")
			for i in range(0, lines.size()):
				if not lines[i].begins_with("import "):
					insert_line_at(i, "import \"%s\" as %s\n" % [file, replace_regex.sub(path, "_", true)])
					set_caret_line(i)
					break
		else:
			var cursor: Vector2 = get_line_column_at_pos(at_position)
			if cursor.x > -1 and cursor.y > -1:
				set_cursor(cursor)
				remove_secondary_carets()
				insert_text("\"%s\"" % file, cursor.y, cursor.x)
	grab_focus()


func _request_code_completion(force: bool) -> void:
	var cursor: Vector2 = get_cursor()
	var current_line: String = get_line(cursor.y)

	# Match jumps
	if ("=> " in current_line or "=>< " in current_line) and (cursor.x > current_line.find("=>")):
		var prompt: String = current_line.split("=>")[1]
		if prompt.begins_with("< "):
			prompt = prompt.substr(2)
		else:
			prompt = prompt.substr(1)

		if "=> " in current_line:
			if matches_prompt(prompt, "end"):
				add_code_completion_option(CodeEdit.KIND_CLASS, "END", "END".substr(prompt.length()), theme_overrides.text_color, get_theme_icon("Stop", "EditorIcons"))
			if matches_prompt(prompt, "end!"):
				add_code_completion_option(CodeEdit.KIND_CLASS, "END!", "END!".substr(prompt.length()), theme_overrides.text_color, get_theme_icon("Stop", "EditorIcons"))

		# Get all titles, including those in imports
		for title: String in DMCompiler.get_titles_in_text(text, main_view.current_file_path):
			# Ignore any imported titles that aren't resolved to human readable.
			if title.to_int() > 0:
				continue

			elif "/" in title:
				var bits = title.split("/")
				if matches_prompt(prompt, bits[0]) or matches_prompt(prompt, bits[1]):
					add_code_completion_option(CodeEdit.KIND_CLASS, title, title.substr(prompt.length()), theme_overrides.text_color, get_theme_icon("CombineLines", "EditorIcons"))
			elif matches_prompt(prompt, title):
				add_code_completion_option(CodeEdit.KIND_CLASS, title, title.substr(prompt.length()), theme_overrides.text_color, get_theme_icon("ArrowRight", "EditorIcons"))

	# Match character names
	var name_so_far: String = WEIGHTED_RANDOM_PREFIX.sub(current_line.strip_edges(), "")
	if name_so_far != "" and name_so_far[0].to_upper() == name_so_far[0]:
		# Only show names starting with that character
		var names: PackedStringArray = get_character_names(name_so_far)
		if names.size() > 0:
			for name in names:
				add_code_completion_option(CodeEdit.KIND_CLASS, name + ": ", name.substr(name_so_far.length()) + ": ", theme_overrides.text_color, get_theme_icon("Sprite2D", "EditorIcons"))

	# Match autoloads on mutation lines
	for prefix in ["do ", "set ", "if ", "elif ", "else if ", "match ", "when ", "using "]:
		if (current_line.strip_edges().begins_with(prefix) and (cursor.x > current_line.find(prefix))):
			var expression: String = current_line.substr(0, cursor.x).strip_edges().substr(3)
			# Find the last couple of tokens
			var possible_prompt: String = expression.reverse()
			possible_prompt = possible_prompt.substr(0, possible_prompt.find(" "))
			possible_prompt = possible_prompt.substr(0, possible_prompt.find("("))
			possible_prompt = possible_prompt.reverse()
			var segments: PackedStringArray = possible_prompt.split(".").slice(-2)
			var auto_completes: Array[Dictionary] = []

			# Autoloads and state shortcuts
			if segments.size() == 1:
				var prompt: String = segments[0]
				for autoload in _autoloads.keys():
					if matches_prompt(prompt, autoload):
						auto_completes.append({
							prompt = prompt,
							text = autoload,
							type = "script"
						})
				for autoload in get_state_shortcuts():
					for member: Dictionary in get_members_for_autoload(autoload):
						if matches_prompt(prompt, member.name):
							auto_completes.append({
								prompt = prompt,
								text = member.name,
								type = member.type
							})

			# Members of an autoload
			elif segments[0] in _autoloads.keys() and not current_line.strip_edges().begins_with("using "):
				var prompt: String = segments[1]
				for member: Dictionary in get_members_for_autoload(segments[0]):
					if matches_prompt(prompt, member.name):
						auto_completes.append({
							prompt = prompt,
							text = member.name,
							type = member.type
						})

			auto_completes.sort_custom(func(a, b): return a.text < b.text)

			for auto_complete in auto_completes:
				var icon: Texture2D
				var text: String = auto_complete.text
				match auto_complete.type:
					"script":
						icon = get_theme_icon("Script", "EditorIcons")
					"property":
						icon = get_theme_icon("MemberProperty", "EditorIcons")
					"method":
						icon = get_theme_icon("MemberMethod", "EditorIcons")
						text += "()"
					"signal":
						icon = get_theme_icon("MemberSignal", "EditorIcons")
					"constant":
						icon = get_theme_icon("MemberConstant", "EditorIcons")
				var insert: String = text.substr(auto_complete.prompt.length())
				add_code_completion_option(CodeEdit.KIND_CLASS, text, insert, theme_overrides.text_color, icon)

	update_code_completion_options(true)
	if get_code_completion_options().size() == 0:
		cancel_code_completion()


func _filter_code_completion_candidates(candidates: Array) -> Array:
	# Not sure why but if this method isn't overridden then all completions are wrapped in quotes.
	return candidates


func _confirm_code_completion(replace: bool) -> void:
	var completion = get_code_completion_option(get_code_completion_selected_index())
	begin_complex_operation()
	# Delete any part of the text that we've already typed
	if completion.insert_text.length() > 0:
		for i in range(0, completion.display_text.length() - completion.insert_text.length()):
			backspace()
	# Insert the whole match
	insert_text_at_caret(completion.display_text)
	end_complex_operation()

	if completion.display_text.ends_with("()"):
		set_cursor(get_cursor() - Vector2.RIGHT)

	# Close the autocomplete menu on the next tick
	call_deferred("cancel_code_completion")


#region Helpers


# Get the current caret as a Vector2
func get_cursor() -> Vector2:
	return Vector2(get_caret_column(), get_caret_line())


# Set the caret from a Vector2
func set_cursor(from_cursor: Vector2) -> void:
	set_caret_line(from_cursor.y, false)
	set_caret_column(from_cursor.x, false)


# Check if a prompt is the start of a string without actually being that string
func matches_prompt(prompt: String, matcher: String) -> bool:
	return prompt.length() < matcher.length() and matcher.to_lower().begins_with(prompt.to_lower())


func get_state_shortcuts() -> PackedStringArray:
	# Get any shortcuts defined in settings
	var shortcuts: PackedStringArray = DMSettings.get_setting(DMSettings.STATE_AUTOLOAD_SHORTCUTS, [])
	# Check for "using" clauses
	for line: String in text.split("\n"):
		var found: RegExMatch = compiler_regex.USING_REGEX.search(line)
		if found:
			shortcuts.append(found.strings[found.names.state])
	# Check for any other script sources
	for extra_script_source in DMSettings.get_setting(DMSettings.EXTRA_AUTO_COMPLETE_SCRIPT_SOURCES, []):
		shortcuts.append(extra_script_source)

	return shortcuts


func get_members_for_autoload(autoload_name: String) -> Array[Dictionary]:
	# Debounce method list lookups
	if _autoload_member_cache.has(autoload_name) and _autoload_member_cache.get(autoload_name).get("at") > Time.get_ticks_msec() - 5000:
		return _autoload_member_cache.get(autoload_name).get("members")

	if not _autoloads.has(autoload_name) and not autoload_name.begins_with("res://") and not autoload_name.begins_with("uid://"): return []

	var autoload = load(_autoloads.get(autoload_name, autoload_name))
	var script: Script = autoload if autoload is Script else autoload.get_script()

	if not is_instance_valid(script): return []

	var members: Array[Dictionary] = []
	if script.resource_path.ends_with(".gd"):
		for m: Dictionary in script.get_script_method_list():
			if not m.name.begins_with("@"):
				members.append({
					name = m.name,
					type = "method"
				})
		for m: Dictionary in script.get_script_property_list():
			members.append({
				name = m.name,
				type = "property"
			})
		for m: Dictionary in script.get_script_signal_list():
			members.append({
				name = m.name,
				type = "signal"
			})
		for c: String in script.get_script_constant_map():
			members.append({
				name = c,
				type = "constant"
			})
	elif script.resource_path.ends_with(".cs"):
		var dotnet = load(Engine.get_meta("DialogueManagerPlugin").get_plugin_path() + "/DialogueManager.cs").new()
		for m: Dictionary in dotnet.GetMembersForAutoload(script):
			members.append(m)

	_autoload_member_cache[autoload_name] = {
		at = Time.get_ticks_msec(),
		members = members
	}

	return members


## Get a list of titles from the current text
func get_titles() -> PackedStringArray:
	var titles = PackedStringArray([])
	var lines = text.split("\n")
	for line in lines:
		if line.strip_edges().begins_with("~ "):
			titles.append(line.strip_edges().substr(2))

	return titles


## Work out what the next title above the current line is
func check_active_title() -> void:
	var line_number = get_caret_line()
	var lines = text.split("\n")
	# Look at each line above this one to find the next title line
	for i in range(line_number, -1, -1):
		if lines[i].begins_with("~ "):
			active_title_change.emit(lines[i].replace("~ ", ""))
			return

	active_title_change.emit("")


# Move the caret line to match a given title
func go_to_title(title: String) -> void:
	var lines = text.split("\n")
	for i in range(0, lines.size()):
		if lines[i].strip_edges() == "~ " + title:
			set_caret_line(i)
			center_viewport_to_caret()


func get_character_names(beginning_with: String) -> PackedStringArray:
	var names: PackedStringArray = []
	var lines = text.split("\n")
	for line in lines:
		if ": " in line:
			var name: String = WEIGHTED_RANDOM_PREFIX.sub(line.split(": ")[0].strip_edges(), "")
			if not name in names and matches_prompt(beginning_with, name):
				names.append(name)
	return names


# Mark a line as an error or not
func mark_line_as_error(line_number: int, is_error: bool) -> void:
	# Lines display counting from 1 but are actually indexed from 0
	line_number -= 1

	if line_number < 0: return

	if is_error:
		set_line_background_color(line_number, theme_overrides.error_line_color)
		set_line_gutter_icon(line_number, 0, get_theme_icon("StatusError", "EditorIcons"))
	else:
		set_line_background_color(line_number, theme_overrides.background_color)
		set_line_gutter_icon(line_number, 0, null)


# Insert or wrap some bbcode at the caret/selection
func insert_bbcode(open_tag: String, close_tag: String = "") -> void:
	if close_tag == "":
		insert_text_at_caret(open_tag)
		grab_focus()
	else:
		var selected_text = get_selected_text()
		insert_text_at_caret("%s%s%s" % [open_tag, selected_text, close_tag])
		grab_focus()
		set_caret_column(get_caret_column() - close_tag.length())

# Insert text at current caret position
# Move Caret down 1 line if not => END
func insert_text_at_cursor(text: String) -> void:
	if text != "=> END":
		insert_text_at_caret(text+"\n")
		set_caret_line(get_caret_line()+1)
	else:
		insert_text_at_caret(text)
	grab_focus()


# Toggle the selected lines as comments
func toggle_comment() -> void:
	begin_complex_operation()

	var comment_delimiter: String = delimiter_comments[0]
	var is_first_line: bool = true
	var will_comment: bool = true
	var selections: Array = []
	var line_offsets: Dictionary = {}

	for caret_index in range(0, get_caret_count()):
		var from_line: int = get_caret_line(caret_index)
		var from_column: int = get_caret_column(caret_index)
		var to_line: int = get_caret_line(caret_index)
		var to_column: int = get_caret_column(caret_index)

		if has_selection(caret_index):
			from_line = get_selection_from_line(caret_index)
			to_line = get_selection_to_line(caret_index)
			from_column = get_selection_from_column(caret_index)
			to_column = get_selection_to_column(caret_index)

		selections.append({
			from_line = from_line,
			from_column = from_column,
			to_line = to_line,
			to_column = to_column
		})

		for line_number in range(from_line, to_line + 1):
			if line_offsets.has(line_number): continue

			var line_text: String = get_line(line_number)

			# The first line determines if we are commenting or uncommentingg
			if is_first_line:
				is_first_line = false
				will_comment = not line_text.strip_edges().begins_with(comment_delimiter)

			# Only comment/uncomment if the current line needs to
			if will_comment:
				set_line(line_number, comment_delimiter + line_text)
				line_offsets[line_number] = 1
			elif line_text.begins_with(comment_delimiter):
				set_line(line_number, line_text.substr(comment_delimiter.length()))
				line_offsets[line_number] = -1
			else:
				line_offsets[line_number] = 0

	for caret_index in range(0, get_caret_count()):
		var selection: Dictionary = selections[caret_index]
		select(
			selection.from_line,
			selection.from_column + line_offsets[selection.from_line],
			selection.to_line,
			selection.to_column + line_offsets[selection.to_line],
			caret_index
		)
		set_caret_column(selection.from_column + line_offsets[selection.from_line], false, caret_index)

	end_complex_operation()

	text_set.emit()
	text_changed.emit()


# Remove the current line
func delete_current_line() -> void:
	var cursor = get_cursor()
	if get_line_count() == 1:
		select_all()
	elif cursor.y == 0:
		select(0, 0, 1, 0)
	else:
		select(cursor.y - 1, get_line_width(cursor.y - 1), cursor.y, get_line_width(cursor.y))
	delete_selection()
	text_changed.emit()


# Move the selected lines up or down
func move_line(offset: int) -> void:
	offset = clamp(offset, -1, 1)

	var starting_scroll := scroll_vertical
	var cursor = get_cursor()
	var reselect: bool = false
	var from: int = cursor.y
	var to: int = cursor.y
	if has_selection():
		reselect = true
		from = get_selection_from_line()
		to = get_selection_to_line()

	var lines := text.split("\n")

	# Prevent the lines from being out of bounds
	if from + offset < 0 or to + offset >= lines.size(): return

	var target_from_index = from - 1 if offset == -1 else to + 1
	var target_to_index = to if offset == -1 else from
	var line_to_move = lines[target_from_index]
	lines.remove_at(target_from_index)
	lines.insert(target_to_index, line_to_move)

	text = "\n".join(lines)

	cursor.y += offset
	set_cursor(cursor)
	from += offset
	to += offset
	if reselect:
		select(from, 0, to, get_line_width(to))

	text_changed.emit()
	scroll_vertical = starting_scroll + offset


#endregion

#region Signals


func _on_project_settings_changed() -> void:
	_autoloads = {}
	var project = ConfigFile.new()
	project.load("res://project.godot")
	for autoload in project.get_section_keys("autoload"):
		if autoload != "DialogueManager":
			_autoloads[autoload] = project.get_value("autoload", autoload).substr(1)


func _on_code_edit_symbol_validate(symbol: String) -> void:
	if symbol.begins_with("res://") and symbol.ends_with(".dialogue"):
		set_symbol_lookup_word_as_valid(true)
		return

	for title in get_titles():
		if symbol == title:
			set_symbol_lookup_word_as_valid(true)
			return
	set_symbol_lookup_word_as_valid(false)


func _on_code_edit_symbol_lookup(symbol: String, line: int, column: int) -> void:
	if symbol.begins_with("res://") and symbol.ends_with(".dialogue"):
		external_file_requested.emit(symbol, "")
	else:
		go_to_title(symbol)


func _on_code_edit_text_changed() -> void:
	request_code_completion(true)


func _on_code_edit_text_set() -> void:
	queue_redraw()


func _on_code_edit_caret_changed() -> void:
	check_active_title()
	last_selected_text = get_selected_text()


func _on_code_edit_gutter_clicked(line: int, gutter: int) -> void:
	var line_errors = errors.filter(func(error): return error.line_number == line)
	if line_errors.size() > 0:
		error_clicked.emit(line)


#endregion
</file>

<file path="addons/dialogue_manager/components/code_edit.tscn">
[gd_scene load_steps=4 format=3 uid="uid://civ6shmka5e8u"]

[ext_resource type="Script" uid="uid://klpiq4tk3t7a" path="res://addons/dialogue_manager/components/code_edit_syntax_highlighter.gd" id="1_58cfo"]
[ext_resource type="Script" uid="uid://djeybvlb332mp" path="res://addons/dialogue_manager/components/code_edit.gd" id="1_g324i"]

[sub_resource type="SyntaxHighlighter" id="SyntaxHighlighter_cobxx"]
script = ExtResource("1_58cfo")

[node name="CodeEdit" type="CodeEdit"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
text = "~ title_thing

if this = \"that\" or 'this'
Nathan: Something
- Then [if test.thing() == 2.0] => somewhere
- Other => END!

~ somewhere

set has_something = true
=> END"
highlight_all_occurrences = true
highlight_current_line = true
draw_tabs = true
syntax_highlighter = SubResource("SyntaxHighlighter_cobxx")
scroll_past_end_of_file = true
minimap_draw = true
symbol_lookup_on_click = true
line_folding = true
gutters_draw_line_numbers = true
gutters_draw_fold_gutter = true
delimiter_strings = Array[String](["\" \""])
delimiter_comments = Array[String](["#"])
code_completion_enabled = true
code_completion_prefixes = Array[String]([">", "<"])
indent_automatic = true
auto_brace_completion_enabled = true
auto_brace_completion_highlight_matching = true
auto_brace_completion_pairs = {
"\"": "\"",
"(": ")",
"[": "]",
"{": "}"
}
script = ExtResource("1_g324i")

[connection signal="caret_changed" from="." to="." method="_on_code_edit_caret_changed"]
[connection signal="gutter_clicked" from="." to="." method="_on_code_edit_gutter_clicked"]
[connection signal="symbol_lookup" from="." to="." method="_on_code_edit_symbol_lookup"]
[connection signal="symbol_validate" from="." to="." method="_on_code_edit_symbol_validate"]
[connection signal="text_changed" from="." to="." method="_on_code_edit_text_changed"]
[connection signal="text_set" from="." to="." method="_on_code_edit_text_set"]
</file>

<file path="addons/dialogue_manager/components/download_update_panel.gd">
@tool
extends Control


signal failed()
signal updated(updated_to_version: String)


const DialogueConstants = preload("../constants.gd")

const TEMP_FILE_NAME = "user://temp.zip"


@onready var logo: TextureRect = %Logo
@onready var label: Label = $VBox/Label
@onready var http_request: HTTPRequest = $HTTPRequest
@onready var download_button: Button = %DownloadButton

var next_version_release: Dictionary:
	set(value):
		next_version_release = value
		label.text = DialogueConstants.translate(&"update.is_available_for_download") % value.tag_name.substr(1)
	get:
		return next_version_release


func _ready() -> void:
	$VBox/Center/DownloadButton.text = DialogueConstants.translate(&"update.download_update")
	$VBox/Center2/NotesButton.text = DialogueConstants.translate(&"update.release_notes")


### Signals


func _on_download_button_pressed() -> void:
	# Safeguard the actual dialogue manager repo from accidentally updating itself
	if FileAccess.file_exists("res://tests/test_basic_dialogue.gd"):
		prints("You can't update the addon from within itself.")
		failed.emit()
		return

	http_request.request(next_version_release.zipball_url)
	download_button.disabled = true
	download_button.text = DialogueConstants.translate(&"update.downloading")


func _on_http_request_request_completed(result: int, response_code: int, headers: PackedStringArray, body: PackedByteArray) -> void:
	if result != HTTPRequest.RESULT_SUCCESS:
		failed.emit()
		return

	# Save the downloaded zip
	var zip_file: FileAccess = FileAccess.open(TEMP_FILE_NAME, FileAccess.WRITE)
	zip_file.store_buffer(body)
	zip_file.close()

	OS.move_to_trash(ProjectSettings.globalize_path("res://addons/dialogue_manager"))

	var zip_reader: ZIPReader = ZIPReader.new()
	zip_reader.open(TEMP_FILE_NAME)
	var files: PackedStringArray = zip_reader.get_files()

	var base_path = files[1]
	# Remove archive folder
	files.remove_at(0)
	# Remove assets folder
	files.remove_at(0)

	for path in files:
		var new_file_path: String = path.replace(base_path, "")
		if path.ends_with("/"):
			DirAccess.make_dir_recursive_absolute("res://addons/%s" % new_file_path)
		else:
			var file: FileAccess = FileAccess.open("res://addons/%s" % new_file_path, FileAccess.WRITE)
			file.store_buffer(zip_reader.read_file(path))

	zip_reader.close()
	DirAccess.remove_absolute(TEMP_FILE_NAME)

	updated.emit(next_version_release.tag_name.substr(1))


func _on_notes_button_pressed() -> void:
	OS.shell_open(next_version_release.html_url)
</file>

<file path="addons/dialogue_manager/components/download_update_panel.tscn">
[gd_scene load_steps=3 format=3 uid="uid://qdxrxv3c3hxk"]

[ext_resource type="Script" uid="uid://kpwo418lb2t2" path="res://addons/dialogue_manager/components/download_update_panel.gd" id="1_4tm1k"]
[ext_resource type="Texture2D" uid="uid://d3baj6rygkb3f" path="res://addons/dialogue_manager/assets/update.svg" id="2_4o2m6"]

[node name="DownloadUpdatePanel" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_4tm1k")

[node name="HTTPRequest" type="HTTPRequest" parent="."]

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -1.0
offset_top = 9.0
offset_right = -1.0
offset_bottom = 9.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="Logo" type="TextureRect" parent="VBox"]
unique_name_in_owner = true
clip_contents = true
custom_minimum_size = Vector2(300, 80)
layout_mode = 2
texture = ExtResource("2_4o2m6")
stretch_mode = 5

[node name="Label" type="Label" parent="VBox"]
layout_mode = 2
text = "v1.2.3 is available for download."
horizontal_alignment = 1

[node name="Center" type="CenterContainer" parent="VBox"]
layout_mode = 2

[node name="DownloadButton" type="Button" parent="VBox/Center"]
unique_name_in_owner = true
layout_mode = 2
text = "Download update"

[node name="Center2" type="CenterContainer" parent="VBox"]
layout_mode = 2

[node name="NotesButton" type="LinkButton" parent="VBox/Center2"]
layout_mode = 2
text = "Read release notes"

[connection signal="request_completed" from="HTTPRequest" to="." method="_on_http_request_request_completed"]
[connection signal="pressed" from="VBox/Center/DownloadButton" to="." method="_on_download_button_pressed"]
[connection signal="pressed" from="VBox/Center2/NotesButton" to="." method="_on_notes_button_pressed"]
</file>

<file path="addons/dialogue_manager/components/editor_property/editor_property_control.gd">
@tool
extends HBoxContainer


signal pressed()
signal resource_changed(next_resource: Resource)


const ITEM_NEW = 100
const ITEM_QUICK_LOAD = 200
const ITEM_LOAD = 201
const ITEM_EDIT = 300
const ITEM_CLEAR = 301
const ITEM_FILESYSTEM = 400


@onready var button: Button = $ResourceButton
@onready var menu_button: Button = $MenuButton
@onready var menu: PopupMenu = $Menu
@onready var quick_open_dialog: ConfirmationDialog = $QuickOpenDialog
@onready var files_list = $QuickOpenDialog/FilesList
@onready var new_dialog: FileDialog = $NewDialog
@onready var open_dialog: FileDialog = $OpenDialog

var editor_plugin: EditorPlugin

var resource: Resource:
	set(next_resource):
		resource = next_resource
		if button:
			button.resource = resource
	get:
		return resource

var is_waiting_for_file: bool = false
var quick_selected_file: String = ""


func _ready() -> void:
	menu_button.icon = get_theme_icon("GuiDropdown", "EditorIcons")
	editor_plugin = Engine.get_meta("DialogueManagerPlugin")


func build_menu() -> void:
	menu.clear()

	menu.add_icon_item(editor_plugin._get_plugin_icon(), "New Dialogue", ITEM_NEW)
	menu.add_separator()
	menu.add_icon_item(get_theme_icon("Load", "EditorIcons"), "Quick Load", ITEM_QUICK_LOAD)
	menu.add_icon_item(get_theme_icon("Load", "EditorIcons"), "Load", ITEM_LOAD)
	if resource:
		menu.add_icon_item(get_theme_icon("Edit", "EditorIcons"), "Edit", ITEM_EDIT)
		menu.add_icon_item(get_theme_icon("Clear", "EditorIcons"), "Clear", ITEM_CLEAR)
		menu.add_separator()
		menu.add_item("Show in FileSystem", ITEM_FILESYSTEM)

	menu.size = Vector2.ZERO


### Signals


func _on_new_dialog_file_selected(path: String) -> void:
	editor_plugin.main_view.new_file(path)
	is_waiting_for_file = false
	if Engine.get_meta("DMCache").has_file(path):
		resource_changed.emit(load(path))
	else:
		var next_resource: Resource = await editor_plugin.import_plugin.compiled_resource
		next_resource.resource_path = path
		resource_changed.emit(next_resource)


func _on_open_dialog_file_selected(file: String) -> void:
	resource_changed.emit(load(file))


func _on_file_dialog_canceled() -> void:
	is_waiting_for_file = false


func _on_resource_button_pressed() -> void:
	if is_instance_valid(resource):
		EditorInterface.call_deferred("edit_resource", resource)
	else:
		build_menu()
		menu.position = get_viewport().position + Vector2i(
			button.global_position.x + button.size.x - menu.size.x,
			2 + menu_button.global_position.y + button.size.y
		)
		menu.popup()


func _on_resource_button_resource_dropped(next_resource: Resource) -> void:
	resource_changed.emit(next_resource)


func _on_menu_button_pressed() -> void:
	build_menu()
	menu.position = get_viewport().position + Vector2i(
		menu_button.global_position.x + menu_button.size.x - menu.size.x,
		2 + menu_button.global_position.y + menu_button.size.y
	)
	menu.popup()


func _on_menu_id_pressed(id: int) -> void:
	match id:
		ITEM_NEW:
			is_waiting_for_file = true
			new_dialog.popup_centered()

		ITEM_QUICK_LOAD:
			quick_selected_file = ""
			files_list.files = Engine.get_meta("DMCache").get_files()
			if resource:
				files_list.select_file(resource.resource_path)
			quick_open_dialog.popup_centered()
			files_list.focus_filter()

		ITEM_LOAD:
			is_waiting_for_file = true
			open_dialog.popup_centered()

		ITEM_EDIT:
			EditorInterface.call_deferred("edit_resource", resource)

		ITEM_CLEAR:
			resource_changed.emit(null)

		ITEM_FILESYSTEM:
			var file_system = EditorInterface.get_file_system_dock()
			file_system.navigate_to_path(resource.resource_path)


func _on_files_list_file_double_clicked(file_path: String) -> void:
	resource_changed.emit(load(file_path))
	quick_open_dialog.hide()


func _on_files_list_file_selected(file_path: String) -> void:
	quick_selected_file = file_path


func _on_quick_open_dialog_confirmed() -> void:
	if quick_selected_file != "":
		resource_changed.emit(load(quick_selected_file))
</file>

<file path="addons/dialogue_manager/components/editor_property/editor_property_control.tscn">
[gd_scene load_steps=4 format=3 uid="uid://ycn6uaj7dsrh"]

[ext_resource type="Script" uid="uid://dooe2pflnqtve" path="res://addons/dialogue_manager/components/editor_property/editor_property_control.gd" id="1_het12"]
[ext_resource type="PackedScene" uid="uid://b16uuqjuof3n5" path="res://addons/dialogue_manager/components/editor_property/resource_button.tscn" id="2_hh3d4"]
[ext_resource type="PackedScene" uid="uid://dnufpcdrreva3" path="res://addons/dialogue_manager/components/files_list.tscn" id="3_l8fp6"]

[node name="PropertyEditorButton" type="HBoxContainer"]
offset_right = 40.0
offset_bottom = 40.0
size_flags_horizontal = 3
theme_override_constants/separation = 0
script = ExtResource("1_het12")

[node name="ResourceButton" parent="." instance=ExtResource("2_hh3d4")]
layout_mode = 2
text = "<empty>"
text_overrun_behavior = 3
clip_text = true

[node name="MenuButton" type="Button" parent="."]
layout_mode = 2

[node name="Menu" type="PopupMenu" parent="."]

[node name="QuickOpenDialog" type="ConfirmationDialog" parent="."]
title = "Find Dialogue Resource"
size = Vector2i(400, 600)
min_size = Vector2i(400, 600)
ok_button_text = "Open"

[node name="FilesList" parent="QuickOpenDialog" instance=ExtResource("3_l8fp6")]

[node name="NewDialog" type="FileDialog" parent="."]
size = Vector2i(900, 750)
min_size = Vector2i(900, 750)
dialog_hide_on_ok = true
filters = PackedStringArray("*.dialogue ; Dialogue")

[node name="OpenDialog" type="FileDialog" parent="."]
title = "Open a File"
size = Vector2i(900, 750)
min_size = Vector2i(900, 750)
ok_button_text = "Open"
dialog_hide_on_ok = true
file_mode = 0
filters = PackedStringArray("*.dialogue ; Dialogue")

[connection signal="pressed" from="ResourceButton" to="." method="_on_resource_button_pressed"]
[connection signal="resource_dropped" from="ResourceButton" to="." method="_on_resource_button_resource_dropped"]
[connection signal="pressed" from="MenuButton" to="." method="_on_menu_button_pressed"]
[connection signal="id_pressed" from="Menu" to="." method="_on_menu_id_pressed"]
[connection signal="confirmed" from="QuickOpenDialog" to="." method="_on_quick_open_dialog_confirmed"]
[connection signal="file_double_clicked" from="QuickOpenDialog/FilesList" to="." method="_on_files_list_file_double_clicked"]
[connection signal="file_selected" from="QuickOpenDialog/FilesList" to="." method="_on_files_list_file_selected"]
[connection signal="canceled" from="NewDialog" to="." method="_on_file_dialog_canceled"]
[connection signal="file_selected" from="NewDialog" to="." method="_on_new_dialog_file_selected"]
[connection signal="canceled" from="OpenDialog" to="." method="_on_file_dialog_canceled"]
[connection signal="file_selected" from="OpenDialog" to="." method="_on_open_dialog_file_selected"]
</file>

<file path="addons/dialogue_manager/components/editor_property/editor_property.gd">
@tool
extends EditorProperty


const DialoguePropertyEditorControl = preload("./editor_property_control.tscn")


var editor_plugin: EditorPlugin

var control = DialoguePropertyEditorControl.instantiate()
var current_value: Resource
var is_updating: bool = false


func _init() -> void:
	add_child(control)

	control.resource = current_value

	control.pressed.connect(_on_button_pressed)
	control.resource_changed.connect(_on_resource_changed)


func _update_property() -> void:
	var next_value = get_edited_object()[get_edited_property()]

	# The resource might have been deleted elsewhere so check that it's not in a weird state
	if is_instance_valid(next_value) and not next_value.resource_path.ends_with(".dialogue"):
		emit_changed(get_edited_property(), null)
		return

	if next_value == current_value: return

	is_updating = true
	current_value = next_value
	control.resource = current_value
	is_updating = false


### Signals


func _on_button_pressed() -> void:
	editor_plugin.edit(current_value)


func _on_resource_changed(next_resource: Resource) -> void:
	emit_changed(get_edited_property(), next_resource)
</file>

<file path="addons/dialogue_manager/components/editor_property/resource_button.gd">
@tool
extends Button


signal resource_dropped(next_resource: Resource)


var resource: Resource:
	set(next_resource):
		resource = next_resource
		if resource:
			icon = Engine.get_meta("DialogueManagerPlugin")._get_plugin_icon()
			text = resource.resource_path.get_file().replace(".dialogue", "")
		else:
			icon = null
			text = "<empty>"
	get:
		return resource


func _notification(what: int) -> void:
	match what:
		NOTIFICATION_DRAG_BEGIN:
			var data = get_viewport().gui_get_drag_data()
			if typeof(data) == TYPE_DICTIONARY and data.type == "files" and data.files.size() > 0 and data.files[0].ends_with(".dialogue"):
				add_theme_stylebox_override("normal", get_theme_stylebox("focus", "LineEdit"))
				add_theme_stylebox_override("hover", get_theme_stylebox("focus", "LineEdit"))

		NOTIFICATION_DRAG_END:
			self.resource = resource
			remove_theme_stylebox_override("normal")
			remove_theme_stylebox_override("hover")


func _can_drop_data(at_position: Vector2, data) -> bool:
	if typeof(data) != TYPE_DICTIONARY: return false
	if data.type != "files": return false

	var files: PackedStringArray = Array(data.files).filter(func(f): return f.get_extension() == "dialogue")
	return files.size() > 0


func _drop_data(at_position: Vector2, data) -> void:
	var files: PackedStringArray = Array(data.files).filter(func(f): return f.get_extension() == "dialogue")

	if files.size() == 0: return

	resource_dropped.emit(load(files[0]))
</file>

<file path="addons/dialogue_manager/components/editor_property/resource_button.tscn">
[gd_scene load_steps=2 format=3 uid="uid://b16uuqjuof3n5"]

[ext_resource type="Script" uid="uid://damhqta55t67c" path="res://addons/dialogue_manager/components/editor_property/resource_button.gd" id="1_7u2i7"]

[node name="ResourceButton" type="Button"]
offset_right = 8.0
offset_bottom = 8.0
size_flags_horizontal = 3
script = ExtResource("1_7u2i7")
</file>

<file path="addons/dialogue_manager/components/errors_panel.gd">
@tool
extends HBoxContainer


signal error_pressed(line_number)


const DialogueConstants = preload("../constants.gd")


@onready var error_button: Button = $ErrorButton
@onready var next_button: Button = $NextButton
@onready var count_label: Label = $CountLabel
@onready var previous_button: Button = $PreviousButton

## The index of the current error being shown
var error_index: int = 0:
	set(next_error_index):
		error_index = wrap(next_error_index, 0, errors.size())
		show_error()
	get:
		return error_index

## The list of all errors
var errors: Array = []:
	set(next_errors):
		errors = next_errors
		self.error_index = 0
	get:
		return errors


func _ready() -> void:
	apply_theme()
	hide()


## Set up colors and icons
func apply_theme() -> void:
	error_button.add_theme_color_override("font_color", get_theme_color("error_color", "Editor"))
	error_button.add_theme_color_override("font_hover_color", get_theme_color("error_color", "Editor"))
	error_button.icon = get_theme_icon("StatusError", "EditorIcons")
	previous_button.icon = get_theme_icon("ArrowLeft", "EditorIcons")
	next_button.icon = get_theme_icon("ArrowRight", "EditorIcons")


## Move the error index to match a given line
func show_error_for_line_number(line_number: int) -> void:
	for i in range(0, errors.size()):
		if errors[i].line_number == line_number:
			self.error_index = i


## Show the current error
func show_error() -> void:
	if errors.size() == 0:
		hide()
	else:
		show()
		count_label.text = DialogueConstants.translate(&"n_of_n").format({ index = error_index + 1, total = errors.size() })
		var error = errors[error_index]
		error_button.text = DialogueConstants.translate(&"errors.line_and_message").format({ line = error.line_number, column = error.column_number, message = DialogueConstants.get_error_message(error.error) })
		if error.has("external_error"):
			error_button.text += " " + DialogueConstants.get_error_message(error.external_error)


### Signals


func _on_errors_panel_theme_changed() -> void:
	apply_theme()


func _on_error_button_pressed() -> void:
	error_pressed.emit(errors[error_index].line_number, errors[error_index].column_number)


func _on_previous_button_pressed() -> void:
	self.error_index -= 1
	_on_error_button_pressed()


func _on_next_button_pressed() -> void:
	self.error_index += 1
	_on_error_button_pressed()
</file>

<file path="addons/dialogue_manager/components/errors_panel.tscn">
[gd_scene load_steps=4 format=3 uid="uid://cs8pwrxr5vxix"]

[ext_resource type="Script" uid="uid://d2l8nlb6hhrfp" path="res://addons/dialogue_manager/components/errors_panel.gd" id="1_nfm3c"]

[sub_resource type="Image" id="Image_w0gko"]
data = {
"data": PackedByteArray(255, 255, 255, 0, 255, 255, 255, 0, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 131, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 131, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 131, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 231, 255, 93, 93, 55, 255, 97, 97, 58, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 93, 93, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 97, 97, 42, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 98, 98, 47, 255, 97, 97, 42, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 93, 93, 233, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 94, 94, 46, 255, 93, 93, 236, 255, 93, 93, 233, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0),
"format": "RGBA8",
"height": 16,
"mipmaps": false,
"width": 16
}

[sub_resource type="ImageTexture" id="ImageTexture_s6fxl"]
image = SubResource("Image_w0gko")

[node name="ErrorsPanel" type="HBoxContainer"]
visible = false
offset_right = 1024.0
offset_bottom = 600.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_nfm3c")
metadata/_edit_layout_mode = 1

[node name="ErrorButton" type="Button" parent="."]
layout_mode = 2
size_flags_horizontal = 3
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_colors/font_hover_color = Color(0, 0, 0, 1)
theme_override_constants/h_separation = 3
icon = SubResource("ImageTexture_s6fxl")
flat = true
alignment = 0
text_overrun_behavior = 4

[node name="Spacer" type="Control" parent="."]
custom_minimum_size = Vector2(40, 0)
layout_mode = 2

[node name="PreviousButton" type="Button" parent="."]
layout_mode = 2
icon = SubResource("ImageTexture_s6fxl")
flat = true

[node name="CountLabel" type="Label" parent="."]
layout_mode = 2

[node name="NextButton" type="Button" parent="."]
layout_mode = 2
icon = SubResource("ImageTexture_s6fxl")
flat = true

[connection signal="pressed" from="ErrorButton" to="." method="_on_error_button_pressed"]
[connection signal="pressed" from="PreviousButton" to="." method="_on_previous_button_pressed"]
[connection signal="pressed" from="NextButton" to="." method="_on_next_button_pressed"]
</file>

<file path="addons/dialogue_manager/components/files_list.gd">
@tool
extends VBoxContainer


signal file_selected(file_path: String)
signal file_popup_menu_requested(at_position: Vector2)
signal file_double_clicked(file_path: String)
signal file_middle_clicked(file_path: String)


const DialogueConstants = preload("../constants.gd")

const MODIFIED_SUFFIX = "(*)"


@export var icon: Texture2D

@onready var filter_edit: LineEdit = $FilterEdit
@onready var list: ItemList = $List

var file_map: Dictionary = {}

var current_file_path: String = ""
var last_selected_file_path: String = ""

var files: PackedStringArray = []:
	set(next_files):
		files = next_files
		files.sort()
		update_file_map()
		apply_filter()
	get:
		return files

var unsaved_files: Array[String] = []

var filter: String = "":
	set(next_filter):
		filter = next_filter
		apply_filter()
	get:
		return filter


func _ready() -> void:
	apply_theme()

	filter_edit.placeholder_text = DialogueConstants.translate(&"files_list.filter")


func focus_filter() -> void:
	filter_edit.grab_focus()


func select_file(file: String) -> void:
	list.deselect_all()
	for i in range(0, list.get_item_count()):
		var item_text = list.get_item_text(i).replace(MODIFIED_SUFFIX, "")
		if item_text == get_nice_file(file, item_text.count("/") + 1):
			list.select(i)
			last_selected_file_path = file


func mark_file_as_unsaved(file: String, is_unsaved: bool) -> void:
	if not file in unsaved_files and is_unsaved:
		unsaved_files.append(file)
	elif file in unsaved_files and not is_unsaved:
		unsaved_files.erase(file)
	apply_filter()


func update_file_map() -> void:
	file_map = {}
	for file in files:
		var nice_file: String = get_nice_file(file)

		# See if a value with just the file name is already in the map
		for key in file_map.keys():
			if file_map[key] == nice_file:
				var bit_count = nice_file.count("/") + 2

				var existing_nice_file = get_nice_file(key, bit_count)
				nice_file = get_nice_file(file, bit_count)

				while nice_file == existing_nice_file:
					bit_count += 1
					existing_nice_file = get_nice_file(key, bit_count)
					nice_file = get_nice_file(file, bit_count)

				file_map[key] = existing_nice_file

		file_map[file] = nice_file


func get_nice_file(file_path: String, path_bit_count: int = 1) -> String:
	var bits = file_path.replace("res://", "").replace(".dialogue", "").split("/")
	bits = bits.slice(-path_bit_count)
	return "/".join(bits)


func apply_filter() -> void:
	list.clear()
	for file in file_map.keys():
		if filter == "" or filter.to_lower() in file.to_lower():
			var nice_file = file_map[file]
			if file in unsaved_files:
				nice_file += MODIFIED_SUFFIX
			var new_id := list.add_item(nice_file)
			list.set_item_icon(new_id, icon)

	select_file(current_file_path)


func apply_theme() -> void:
	if is_instance_valid(filter_edit):
		filter_edit.right_icon = get_theme_icon("Search", "EditorIcons")
	if is_instance_valid(list):
		list.add_theme_stylebox_override("panel", get_theme_stylebox("panel", "Panel"))


### Signals


func _on_theme_changed() -> void:
	apply_theme()


func _on_filter_edit_text_changed(new_text: String) -> void:
	self.filter = new_text


func _on_list_item_clicked(index: int, at_position: Vector2, mouse_button_index: int) -> void:
	var item_text = list.get_item_text(index).replace(MODIFIED_SUFFIX, "")
	var file = file_map.find_key(item_text)

	if mouse_button_index == MOUSE_BUTTON_LEFT or mouse_button_index == MOUSE_BUTTON_RIGHT:
		select_file(file)
		file_selected.emit(file)
		if mouse_button_index == MOUSE_BUTTON_RIGHT:
			file_popup_menu_requested.emit(at_position)

	if mouse_button_index == MOUSE_BUTTON_MIDDLE:
		file_middle_clicked.emit(file)


func _on_list_item_activated(index: int) -> void:
	var item_text = list.get_item_text(index).replace(MODIFIED_SUFFIX, "")
	var file = file_map.find_key(item_text)
	select_file(file)
	file_double_clicked.emit(file)
</file>

<file path="addons/dialogue_manager/components/files_list.tscn">
[gd_scene load_steps=3 format=3 uid="uid://dnufpcdrreva3"]

[ext_resource type="Script" uid="uid://dqa4a4wwoo0aa" path="res://addons/dialogue_manager/components/files_list.gd" id="1_cytii"]
[ext_resource type="Texture2D" uid="uid://d3lr2uas6ax8v" path="res://addons/dialogue_manager/assets/icon.svg" id="2_3ijx1"]

[node name="FilesList" type="VBoxContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_vertical = 3
script = ExtResource("1_cytii")
icon = ExtResource("2_3ijx1")

[node name="FilterEdit" type="LineEdit" parent="."]
layout_mode = 2
placeholder_text = "Filter files"
clear_button_enabled = true

[node name="List" type="ItemList" parent="."]
layout_mode = 2
size_flags_vertical = 3
allow_rmb_select = true

[connection signal="theme_changed" from="." to="." method="_on_theme_changed"]
[connection signal="text_changed" from="FilterEdit" to="." method="_on_filter_edit_text_changed"]
[connection signal="item_activated" from="List" to="." method="_on_list_item_activated"]
[connection signal="item_clicked" from="List" to="." method="_on_list_item_clicked"]
</file>

<file path="addons/dialogue_manager/components/find_in_files.gd">
@tool
extends Control

signal result_selected(path: String, cursor: Vector2, length: int)


const DialogueConstants = preload("../constants.gd")


@export var main_view: Control
@export var code_edit: CodeEdit

@onready var input: LineEdit = %Input
@onready var search_button: Button = %SearchButton
@onready var match_case_button: CheckBox = %MatchCaseButton
@onready var replace_toggle: CheckButton = %ReplaceToggle
@onready var replace_container: VBoxContainer = %ReplaceContainer
@onready var replace_input: LineEdit = %ReplaceInput
@onready var replace_selected_button: Button = %ReplaceSelectedButton
@onready var replace_all_button: Button = %ReplaceAllButton
@onready var results_container: VBoxContainer = %ResultsContainer
@onready var result_template: HBoxContainer = %ResultTemplate

var current_results: Dictionary = {}:
	set(value):
		current_results = value
		update_results_view()
		if current_results.size() == 0:
			replace_selected_button.disabled = true
			replace_all_button.disabled = true
		else:
			replace_selected_button.disabled = false
			replace_all_button.disabled = false
	get:
		return current_results

var selections: PackedStringArray = []


func prepare() -> void:
	input.grab_focus()

	var template_label = result_template.get_node("Label")
	template_label.get_theme_stylebox(&"focus").bg_color = code_edit.theme_overrides.current_line_color
	template_label.add_theme_font_override(&"normal_font", code_edit.get_theme_font(&"font"))

	replace_toggle.set_pressed_no_signal(false)
	replace_container.hide()

	$VBoxContainer/HBoxContainer/FindContainer/Label.text = DialogueConstants.translate(&"search.find")
	input.placeholder_text = DialogueConstants.translate(&"search.placeholder")
	input.text = ""
	search_button.text = DialogueConstants.translate(&"search.find_all")
	match_case_button.text = DialogueConstants.translate(&"search.match_case")
	replace_toggle.text = DialogueConstants.translate(&"search.toggle_replace")
	$VBoxContainer/HBoxContainer/ReplaceContainer/ReplaceLabel.text = DialogueConstants.translate(&"search.replace_with")
	replace_input.placeholder_text = DialogueConstants.translate(&"search.replace_placeholder")
	replace_input.text = ""
	replace_all_button.text = DialogueConstants.translate(&"search.replace_all")
	replace_selected_button.text = DialogueConstants.translate(&"search.replace_selected")

	selections.clear()
	self.current_results = {}

#region helpers


func update_results_view() -> void:
	for child in results_container.get_children():
		child.queue_free()

	for path in current_results.keys():
		var path_label: Label = Label.new()
		path_label.text = path
		# Show open files
		if main_view.open_buffers.has(path):
			path_label.text += "(*)"
		results_container.add_child(path_label)
		for path_result in current_results.get(path):
			var result_item: HBoxContainer = result_template.duplicate()

			var checkbox: CheckBox = result_item.get_node("CheckBox") as CheckBox
			var key: String = get_selection_key(path, path_result)
			checkbox.toggled.connect(func(is_pressed):
				if is_pressed:
					if not selections.has(key):
						selections.append(key)
				else:
					if selections.has(key):
						selections.remove_at(selections.find(key))
			)
			checkbox.set_pressed_no_signal(selections.has(key))
			checkbox.visible = replace_toggle.button_pressed

			var result_label: RichTextLabel = result_item.get_node("Label") as RichTextLabel
			var colors: Dictionary = code_edit.theme_overrides
			var highlight: String = ""
			if replace_toggle.button_pressed:
				var matched_word: String = "[bgcolor=" + colors.critical_color.to_html() + "][color=" + colors.text_color.to_html() + "]" + path_result.matched_text + "[/color][/bgcolor]"
				highlight = "[s]" + matched_word + "[/s][bgcolor=" + colors.notice_color.to_html() + "][color=" + colors.text_color.to_html() + "]" + replace_input.text + "[/color][/bgcolor]"
			else:
				highlight = "[bgcolor=" + colors.notice_color.to_html() + "][color=" + colors.text_color.to_html() + "]" + path_result.matched_text + "[/color][/bgcolor]"
			var text: String = path_result.text.substr(0, path_result.index) + highlight + path_result.text.substr(path_result.index + path_result.query.length())
			result_label.text = "%s: %s" % [str(path_result.line).lpad(4), text]
			result_label.gui_input.connect(func(event):
				if event is InputEventMouseButton and (event as InputEventMouseButton).button_index == MOUSE_BUTTON_LEFT and (event as InputEventMouseButton).double_click:
					result_selected.emit(path, Vector2(path_result.index, path_result.line), path_result.query.length())
			)

			results_container.add_child(result_item)


func find_in_files() -> Dictionary:
	var results: Dictionary = {}

	var q: String = input.text
	var cache = Engine.get_meta("DMCache")
	var file: FileAccess
	for path in cache.get_files():
		var path_results: Array = []
		var lines: PackedStringArray = []

		if main_view.open_buffers.has(path):
			lines = main_view.open_buffers.get(path).text.split("\n")
		else:
			file = FileAccess.open(path, FileAccess.READ)
			lines = file.get_as_text().split("\n")

		for i in range(0, lines.size()):
			var index: int = find_in_line(lines[i], q)
			while index > -1:
				path_results.append({
					line = i,
					index = index,
					text = lines[i],
					matched_text = lines[i].substr(index, q.length()),
					query = q
				})
				index = find_in_line(lines[i], q, index + q.length())

		if file != null and file.is_open():
			file.close()

		if path_results.size() > 0:
			results[path] = path_results

	return results


func get_selection_key(path: String, path_result: Dictionary) -> String:
	return "%s-%d-%d" % [path, path_result.line, path_result.index]


func find_in_line(line: String, query: String, from_index: int = 0) -> int:
	if match_case_button.button_pressed:
		return line.find(query, from_index)
	else:
		return line.findn(query, from_index)


func replace_results(only_selected: bool) -> void:
	var file: FileAccess
	var lines: PackedStringArray = []
	for path in current_results:
		if main_view.open_buffers.has(path):
			lines = main_view.open_buffers.get(path).text.split("\n")
		else:
			file = FileAccess.open(path, FileAccess.READ_WRITE)
			lines = file.get_as_text().split("\n")

		# Read the results in reverse because we're going to be modifying them as we go
		var path_results: Array = current_results.get(path).duplicate()
		path_results.reverse()
		for path_result in path_results:
			var key: String = get_selection_key(path, path_result)
			if not only_selected or (only_selected and selections.has(key)):
				lines[path_result.line] = lines[path_result.line].substr(0, path_result.index) + replace_input.text + lines[path_result.line].substr(path_result.index + path_result.matched_text.length())

		var replaced_text: String = "\n".join(lines)
		if file != null and file.is_open():
			file.seek(0)
			file.store_string(replaced_text)
			file.close()
		else:
			main_view.open_buffers.get(path).text = replaced_text
			if main_view.current_file_path == path:
				code_edit.text = replaced_text

	current_results = find_in_files()


#endregion

#region signals


func _on_search_button_pressed() -> void:
	selections.clear()
	self.current_results = find_in_files()


func _on_input_text_submitted(new_text: String) -> void:
	_on_search_button_pressed()


func _on_replace_toggle_toggled(toggled_on: bool) -> void:
	replace_container.visible = toggled_on
	if toggled_on:
		replace_input.grab_focus()
	update_results_view()


func _on_replace_input_text_changed(new_text: String) -> void:
	update_results_view()


func _on_replace_selected_button_pressed() -> void:
	replace_results(true)


func _on_replace_all_button_pressed() -> void:
	replace_results(false)


func _on_match_case_button_toggled(toggled_on: bool) -> void:
	_on_search_button_pressed()


#endregion
</file>

<file path="addons/dialogue_manager/components/find_in_files.tscn">
[gd_scene load_steps=3 format=3 uid="uid://0n7hwviyyly4"]

[ext_resource type="Script" uid="uid://q368fmxxa8sd" path="res://addons/dialogue_manager/components/find_in_files.gd" id="1_3xicy"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_owohg"]
bg_color = Color(0.266667, 0.278431, 0.352941, 0.243137)
corner_detail = 1

[node name="FindInFiles" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1_3xicy")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="HBoxContainer" type="HBoxContainer" parent="VBoxContainer"]
layout_mode = 2

[node name="FindContainer" type="VBoxContainer" parent="VBoxContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="VBoxContainer/HBoxContainer/FindContainer"]
layout_mode = 2
text = "Find:"

[node name="Input" type="LineEdit" parent="VBoxContainer/HBoxContainer/FindContainer"]
unique_name_in_owner = true
layout_mode = 2
clear_button_enabled = true

[node name="FindToolbar" type="HBoxContainer" parent="VBoxContainer/HBoxContainer/FindContainer"]
layout_mode = 2

[node name="SearchButton" type="Button" parent="VBoxContainer/HBoxContainer/FindContainer/FindToolbar"]
unique_name_in_owner = true
layout_mode = 2
text = "Find all..."

[node name="MatchCaseButton" type="CheckBox" parent="VBoxContainer/HBoxContainer/FindContainer/FindToolbar"]
unique_name_in_owner = true
layout_mode = 2
text = "Match case"

[node name="Control" type="Control" parent="VBoxContainer/HBoxContainer/FindContainer/FindToolbar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ReplaceToggle" type="CheckButton" parent="VBoxContainer/HBoxContainer/FindContainer/FindToolbar"]
unique_name_in_owner = true
layout_mode = 2
text = "Replace"

[node name="ReplaceContainer" type="VBoxContainer" parent="VBoxContainer/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3

[node name="ReplaceLabel" type="Label" parent="VBoxContainer/HBoxContainer/ReplaceContainer"]
layout_mode = 2
text = "Replace with:"

[node name="ReplaceInput" type="LineEdit" parent="VBoxContainer/HBoxContainer/ReplaceContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
clear_button_enabled = true

[node name="ReplaceToolbar" type="HBoxContainer" parent="VBoxContainer/HBoxContainer/ReplaceContainer"]
layout_mode = 2

[node name="ReplaceSelectedButton" type="Button" parent="VBoxContainer/HBoxContainer/ReplaceContainer/ReplaceToolbar"]
unique_name_in_owner = true
layout_mode = 2
text = "Replace selected"

[node name="ReplaceAllButton" type="Button" parent="VBoxContainer/HBoxContainer/ReplaceContainer/ReplaceToolbar"]
unique_name_in_owner = true
layout_mode = 2
text = "Replace all"

[node name="VBoxContainer" type="VBoxContainer" parent="VBoxContainer"]
layout_mode = 2

[node name="ReplaceToolbar" type="HBoxContainer" parent="VBoxContainer/VBoxContainer"]
layout_mode = 2

[node name="ScrollContainer" type="ScrollContainer" parent="VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
follow_focus = true

[node name="ResultsContainer" type="VBoxContainer" parent="VBoxContainer/ScrollContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 0

[node name="ResultTemplate" type="HBoxContainer" parent="."]
unique_name_in_owner = true
layout_mode = 0
offset_left = 155.0
offset_top = -74.0
offset_right = 838.0
offset_bottom = -51.0

[node name="CheckBox" type="CheckBox" parent="ResultTemplate"]
layout_mode = 2

[node name="Label" type="RichTextLabel" parent="ResultTemplate"]
layout_mode = 2
size_flags_horizontal = 3
focus_mode = 2
theme_override_styles/focus = SubResource("StyleBoxFlat_owohg")
bbcode_enabled = true
text = "Result"
fit_content = true
scroll_active = false

[connection signal="text_submitted" from="VBoxContainer/HBoxContainer/FindContainer/Input" to="." method="_on_input_text_submitted"]
[connection signal="pressed" from="VBoxContainer/HBoxContainer/FindContainer/FindToolbar/SearchButton" to="." method="_on_search_button_pressed"]
[connection signal="toggled" from="VBoxContainer/HBoxContainer/FindContainer/FindToolbar/MatchCaseButton" to="." method="_on_match_case_button_toggled"]
[connection signal="toggled" from="VBoxContainer/HBoxContainer/FindContainer/FindToolbar/ReplaceToggle" to="." method="_on_replace_toggle_toggled"]
[connection signal="text_changed" from="VBoxContainer/HBoxContainer/ReplaceContainer/ReplaceInput" to="." method="_on_replace_input_text_changed"]
[connection signal="pressed" from="VBoxContainer/HBoxContainer/ReplaceContainer/ReplaceToolbar/ReplaceSelectedButton" to="." method="_on_replace_selected_button_pressed"]
[connection signal="pressed" from="VBoxContainer/HBoxContainer/ReplaceContainer/ReplaceToolbar/ReplaceAllButton" to="." method="_on_replace_all_button_pressed"]
</file>

<file path="addons/dialogue_manager/components/search_and_replace.gd">
@tool
extends VBoxContainer


signal open_requested()
signal close_requested()


const DialogueConstants = preload("../constants.gd")


@onready var input: LineEdit = $Search/Input
@onready var result_label: Label = $Search/ResultLabel
@onready var previous_button: Button = $Search/PreviousButton
@onready var next_button: Button = $Search/NextButton
@onready var match_case_button: CheckBox = $Search/MatchCaseCheckBox
@onready var replace_check_button: CheckButton = $Search/ReplaceCheckButton
@onready var replace_panel: HBoxContainer = $Replace
@onready var replace_input: LineEdit = $Replace/Input
@onready var replace_button: Button = $Replace/ReplaceButton
@onready var replace_all_button: Button = $Replace/ReplaceAllButton

# The code edit we will be affecting (for some reason exporting this didn't work)
var code_edit: CodeEdit:
	set(next_code_edit):
		code_edit = next_code_edit
		code_edit.gui_input.connect(_on_text_edit_gui_input)
		code_edit.text_changed.connect(_on_text_edit_text_changed)
	get:
		return code_edit

var results: Array = []
var result_index: int = -1:
	set(next_result_index):
		result_index = next_result_index
		if results.size() > 0:
			var r = results[result_index]
			code_edit.set_caret_line(r[0])
			code_edit.select(r[0], r[1], r[0], r[1] + r[2])
		else:
			result_index = -1
			if is_instance_valid(code_edit):
				code_edit.deselect()

		result_label.text = DialogueConstants.translate(&"n_of_n").format({ index = result_index + 1, total = results.size() })
	get:
		return result_index


func _ready() -> void:
	apply_theme()

	input.placeholder_text = DialogueConstants.translate(&"search.placeholder")
	previous_button.tooltip_text = DialogueConstants.translate(&"search.previous")
	next_button.tooltip_text = DialogueConstants.translate(&"search.next")
	match_case_button.text = DialogueConstants.translate(&"search.match_case")
	$Search/ReplaceCheckButton.text = DialogueConstants.translate(&"search.toggle_replace")
	replace_button.text = DialogueConstants.translate(&"search.replace")
	replace_all_button.text = DialogueConstants.translate(&"search.replace_all")
	$Replace/ReplaceLabel.text = DialogueConstants.translate(&"search.replace_with")

	self.result_index = -1

	replace_panel.hide()
	replace_button.disabled = true
	replace_all_button.disabled = true

	hide()


func focus_line_edit() -> void:
	input.grab_focus()
	input.select_all()


func apply_theme() -> void:
	if is_instance_valid(previous_button):
		previous_button.icon = get_theme_icon("ArrowLeft", "EditorIcons")
	if is_instance_valid(next_button):
		next_button.icon = get_theme_icon("ArrowRight", "EditorIcons")


# Find text in the code
func search(text: String = "", default_result_index: int = 0) -> void:
	results.clear()

	if text == "":
		text = input.text

	var lines = code_edit.text.split("\n")
	for line_number in range(0, lines.size()):
		var line = lines[line_number]

		var column = find_in_line(line, text, 0)
		while column > -1:
			results.append([line_number, column, text.length()])
			column = find_in_line(line, text, column + 1)

	if results.size() > 0:
		replace_button.disabled = false
		replace_all_button.disabled = false
	else:
		replace_button.disabled = true
		replace_all_button.disabled = true

	self.result_index = clamp(default_result_index, 0, results.size() - 1)


# Find text in a string and match case if requested
func find_in_line(line: String, text: String, from_index: int = 0) -> int:
	if match_case_button.button_pressed:
		return line.find(text, from_index)
	else:
		return line.findn(text, from_index)


#region Signals


func _on_text_edit_gui_input(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed():
		match event.as_text():
			"Ctrl+F", "Command+F":
				open_requested.emit()
				get_viewport().set_input_as_handled()
			"Ctrl+Shift+R", "Command+Shift+R":
				replace_check_button.set_pressed(true)
				open_requested.emit()
				get_viewport().set_input_as_handled()


func _on_text_edit_text_changed() -> void:
	results.clear()


func _on_search_and_replace_theme_changed() -> void:
	apply_theme()


func _on_input_text_changed(new_text: String) -> void:
	search(new_text)


func _on_previous_button_pressed() -> void:
	self.result_index = wrapi(result_index - 1, 0, results.size())


func _on_next_button_pressed() -> void:
	self.result_index = wrapi(result_index + 1, 0, results.size())


func _on_search_and_replace_visibility_changed() -> void:
	if is_instance_valid(input):
		if visible:
			input.grab_focus()
			var selection = code_edit.get_selected_text()
			if input.text == "" and selection != "":
				input.text = selection
				search(selection)
			else:
				search()
		else:
			input.text = ""


func _on_input_gui_input(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed():
		match event.as_text():
			"Enter":
				search(input.text)
			"Escape":
				emit_signal("close_requested")


func _on_replace_button_pressed() -> void:
	if result_index == -1: return

	# Replace the selection at result index
	var r: Array = results[result_index]
	code_edit.begin_complex_operation()
	var lines: PackedStringArray = code_edit.text.split("\n")
	var line: String = lines[r[0]]
	line = line.substr(0, r[1]) + replace_input.text + line.substr(r[1] + r[2])
	lines[r[0]] = line
	code_edit.text = "\n".join(lines)
	code_edit.end_complex_operation()
	code_edit.text_changed.emit()

	search(input.text, result_index)


func _on_replace_all_button_pressed() -> void:
	if match_case_button.button_pressed:
		code_edit.text = code_edit.text.replace(input.text, replace_input.text)
	else:
		code_edit.text = code_edit.text.replacen(input.text, replace_input.text)
	search()
	code_edit.text_changed.emit()


func _on_replace_check_button_toggled(button_pressed: bool) -> void:
	replace_panel.visible = button_pressed
	if button_pressed:
		replace_input.grab_focus()


func _on_input_focus_entered() -> void:
	if results.size() == 0:
		search()
	else:
		self.result_index = result_index


func _on_match_case_check_box_toggled(button_pressed: bool) -> void:
	search()


#endregion
</file>

<file path="addons/dialogue_manager/components/search_and_replace.tscn">
[gd_scene load_steps=2 format=3 uid="uid://gr8nakpbrhby"]

[ext_resource type="Script" uid="uid://cijsmjkq21cdq" path="res://addons/dialogue_manager/components/search_and_replace.gd" id="1_8oj1f"]

[node name="SearchAndReplace" type="VBoxContainer"]
visible = false
anchors_preset = 10
anchor_right = 1.0
offset_bottom = 31.0
grow_horizontal = 2
size_flags_horizontal = 3
script = ExtResource("1_8oj1f")

[node name="Search" type="HBoxContainer" parent="."]
layout_mode = 2

[node name="Input" type="LineEdit" parent="Search"]
layout_mode = 2
size_flags_horizontal = 3
placeholder_text = "Text to search for"
metadata/_edit_use_custom_anchors = true

[node name="MatchCaseCheckBox" type="CheckBox" parent="Search"]
layout_mode = 2
text = "Match case"

[node name="VSeparator" type="VSeparator" parent="Search"]
layout_mode = 2

[node name="PreviousButton" type="Button" parent="Search"]
layout_mode = 2
tooltip_text = "Previous"
flat = true

[node name="ResultLabel" type="Label" parent="Search"]
layout_mode = 2
text = "0 of 0"

[node name="NextButton" type="Button" parent="Search"]
layout_mode = 2
tooltip_text = "Next"
flat = true

[node name="VSeparator2" type="VSeparator" parent="Search"]
layout_mode = 2

[node name="ReplaceCheckButton" type="CheckButton" parent="Search"]
layout_mode = 2
text = "Replace"

[node name="Replace" type="HBoxContainer" parent="."]
visible = false
layout_mode = 2

[node name="ReplaceLabel" type="Label" parent="Replace"]
layout_mode = 2
text = "Replace with:"

[node name="Input" type="LineEdit" parent="Replace"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ReplaceButton" type="Button" parent="Replace"]
layout_mode = 2
disabled = true
text = "Replace"
flat = true

[node name="ReplaceAllButton" type="Button" parent="Replace"]
layout_mode = 2
disabled = true
text = "Replace all"
flat = true

[connection signal="theme_changed" from="." to="." method="_on_search_and_replace_theme_changed"]
[connection signal="visibility_changed" from="." to="." method="_on_search_and_replace_visibility_changed"]
[connection signal="focus_entered" from="Search/Input" to="." method="_on_input_focus_entered"]
[connection signal="gui_input" from="Search/Input" to="." method="_on_input_gui_input"]
[connection signal="text_changed" from="Search/Input" to="." method="_on_input_text_changed"]
[connection signal="toggled" from="Search/MatchCaseCheckBox" to="." method="_on_match_case_check_box_toggled"]
[connection signal="pressed" from="Search/PreviousButton" to="." method="_on_previous_button_pressed"]
[connection signal="pressed" from="Search/NextButton" to="." method="_on_next_button_pressed"]
[connection signal="toggled" from="Search/ReplaceCheckButton" to="." method="_on_replace_check_button_toggled"]
[connection signal="focus_entered" from="Replace/Input" to="." method="_on_input_focus_entered"]
[connection signal="gui_input" from="Replace/Input" to="." method="_on_input_gui_input"]
[connection signal="pressed" from="Replace/ReplaceButton" to="." method="_on_replace_button_pressed"]
[connection signal="pressed" from="Replace/ReplaceAllButton" to="." method="_on_replace_all_button_pressed"]
</file>

<file path="addons/dialogue_manager/components/title_list.gd">
@tool
extends VBoxContainer

signal title_selected(title: String)


const DialogueConstants = preload("../constants.gd")


@onready var filter_edit: LineEdit = $FilterEdit
@onready var list: ItemList = $List

var titles: PackedStringArray:
	set(next_titles):
		titles = next_titles
		apply_filter()
	get:
		return titles

var filter: String:
	set(next_filter):
		filter = next_filter
		apply_filter()
	get:
		return filter


func _ready() -> void:
	apply_theme()

	filter_edit.placeholder_text = DialogueConstants.translate(&"titles_list.filter")


func select_title(title: String) -> void:
	list.deselect_all()
	for i in range(0, list.get_item_count()):
		if list.get_item_text(i) == title.strip_edges():
			list.select(i)


func apply_filter() -> void:
	list.clear()
	for title in titles:
		if filter == "" or filter.to_lower() in title.to_lower():
			list.add_item(title.strip_edges())


func apply_theme() -> void:
	if is_instance_valid(filter_edit):
		filter_edit.right_icon = get_theme_icon("Search", "EditorIcons")
	if is_instance_valid(list):
		list.add_theme_stylebox_override("panel", get_theme_stylebox("panel", "Panel"))


### Signals


func _on_theme_changed() -> void:
	apply_theme()


func _on_filter_edit_text_changed(new_text: String) -> void:
	self.filter = new_text


func _on_list_item_clicked(index: int, at_position: Vector2, mouse_button_index: int) -> void:
	if mouse_button_index == MOUSE_BUTTON_LEFT:
		var title = list.get_item_text(index)
		title_selected.emit(title)
</file>

<file path="addons/dialogue_manager/components/title_list.tscn">
[gd_scene load_steps=2 format=3 uid="uid://ctns6ouwwd68i"]

[ext_resource type="Script" uid="uid://d0k2wndjj0ifm" path="res://addons/dialogue_manager/components/title_list.gd" id="1_5qqmd"]

[node name="TitleList" type="VBoxContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1_5qqmd")

[node name="FilterEdit" type="LineEdit" parent="."]
layout_mode = 2
placeholder_text = "Filter titles"
clear_button_enabled = true

[node name="List" type="ItemList" parent="."]
layout_mode = 2
size_flags_vertical = 3
allow_reselect = true

[connection signal="theme_changed" from="." to="." method="_on_theme_changed"]
[connection signal="text_changed" from="FilterEdit" to="." method="_on_filter_edit_text_changed"]
[connection signal="item_clicked" from="List" to="." method="_on_list_item_clicked"]
</file>

<file path="addons/dialogue_manager/components/update_button.gd">
@tool
extends Button

const DialogueConstants = preload("../constants.gd")
const DialogueSettings = preload("../settings.gd")

const REMOTE_RELEASES_URL = "https://api.github.com/repos/nathanhoad/godot_dialogue_manager/releases"


@onready var http_request: HTTPRequest = $HTTPRequest
@onready var download_dialog: AcceptDialog = $DownloadDialog
@onready var download_update_panel = $DownloadDialog/DownloadUpdatePanel
@onready var needs_reload_dialog: AcceptDialog = $NeedsReloadDialog
@onready var update_failed_dialog: AcceptDialog = $UpdateFailedDialog
@onready var timer: Timer = $Timer

var needs_reload: bool = false

# A lambda that gets called just before refreshing the plugin. Return false to stop the reload.
var on_before_refresh: Callable = func(): return true


func _ready() -> void:
	hide()
	apply_theme()

	# Check for updates on GitHub
	check_for_update()

	# Check again every few hours
	timer.start(60 * 60 * 12)


# Convert a version number to an actually comparable number
func version_to_number(version: String) -> int:
	var bits = version.split(".")
	return bits[0].to_int() * 1000000 + bits[1].to_int() * 1000 + bits[2].to_int()


func apply_theme() -> void:
	var color: Color = get_theme_color("success_color", "Editor")

	if needs_reload:
		color = get_theme_color("error_color", "Editor")
		icon = get_theme_icon("Reload", "EditorIcons")
		add_theme_color_override("icon_normal_color", color)
		add_theme_color_override("icon_focus_color", color)
		add_theme_color_override("icon_hover_color", color)

	add_theme_color_override("font_color", color)
	add_theme_color_override("font_focus_color", color)
	add_theme_color_override("font_hover_color", color)


func check_for_update() -> void:
	if DialogueSettings.get_user_value("check_for_updates", true):
		http_request.request(REMOTE_RELEASES_URL)


### Signals


func _on_http_request_request_completed(result: int, response_code: int, headers: PackedStringArray, body: PackedByteArray) -> void:
	if result != HTTPRequest.RESULT_SUCCESS: return

	var current_version: String = Engine.get_meta("DialogueManagerPlugin").get_version()

	# Work out the next version from the releases information on GitHub
	var response = JSON.parse_string(body.get_string_from_utf8())
	if typeof(response) != TYPE_ARRAY: return

	# GitHub releases are in order of creation, not order of version
	var versions = (response as Array).filter(func(release):
		var version: String = release.tag_name.substr(1)
		var major_version: int = version.split(".")[0].to_int()
		var current_major_version: int = current_version.split(".")[0].to_int()
		return major_version == current_major_version and version_to_number(version) > version_to_number(current_version)
	)
	if versions.size() > 0:
		download_update_panel.next_version_release = versions[0]
		text = DialogueConstants.translate(&"update.available").format({ version = versions[0].tag_name.substr(1) })
		show()


func _on_update_button_pressed() -> void:
	if needs_reload:
		var will_refresh = on_before_refresh.call()
		if will_refresh:
			EditorInterface.restart_editor(true)
	else:
		var scale: float = EditorInterface.get_editor_scale()
		download_dialog.min_size = Vector2(300, 250) * scale
		download_dialog.popup_centered()


func _on_download_dialog_close_requested() -> void:
	download_dialog.hide()


func _on_download_update_panel_updated(updated_to_version: String) -> void:
	download_dialog.hide()

	needs_reload_dialog.dialog_text = DialogueConstants.translate(&"update.needs_reload")
	needs_reload_dialog.ok_button_text = DialogueConstants.translate(&"update.reload_ok_button")
	needs_reload_dialog.cancel_button_text = DialogueConstants.translate(&"update.reload_cancel_button")
	needs_reload_dialog.popup_centered()

	needs_reload = true
	text = DialogueConstants.translate(&"update.reload_project")
	apply_theme()


func _on_download_update_panel_failed() -> void:
	download_dialog.hide()
	update_failed_dialog.dialog_text = DialogueConstants.translate(&"update.failed")
	update_failed_dialog.popup_centered()


func _on_needs_reload_dialog_confirmed() -> void:
	EditorInterface.restart_editor(true)


func _on_timer_timeout() -> void:
	if not needs_reload:
		check_for_update()
</file>

<file path="addons/dialogue_manager/components/update_button.tscn">
[gd_scene load_steps=3 format=3 uid="uid://co8yl23idiwbi"]

[ext_resource type="Script" uid="uid://cr1tt12dh5ecr" path="res://addons/dialogue_manager/components/update_button.gd" id="1_d2tpb"]
[ext_resource type="PackedScene" uid="uid://qdxrxv3c3hxk" path="res://addons/dialogue_manager/components/download_update_panel.tscn" id="2_iwm7r"]

[node name="UpdateButton" type="Button"]
visible = false
offset_right = 8.0
offset_bottom = 8.0
theme_override_colors/font_color = Color(0, 0, 0, 1)
theme_override_colors/font_hover_color = Color(0, 0, 0, 1)
theme_override_colors/font_focus_color = Color(0, 0, 0, 1)
text = "v2.9.0 available"
flat = true
script = ExtResource("1_d2tpb")

[node name="HTTPRequest" type="HTTPRequest" parent="."]

[node name="DownloadDialog" type="AcceptDialog" parent="."]
title = "Download update"
size = Vector2i(400, 300)
unresizable = true
min_size = Vector2i(300, 250)
ok_button_text = "Close"

[node name="DownloadUpdatePanel" parent="DownloadDialog" instance=ExtResource("2_iwm7r")]

[node name="UpdateFailedDialog" type="AcceptDialog" parent="."]
dialog_text = "You have been updated to version 2.4.3"

[node name="NeedsReloadDialog" type="ConfirmationDialog" parent="."]

[node name="Timer" type="Timer" parent="."]
wait_time = 14400.0

[connection signal="pressed" from="." to="." method="_on_update_button_pressed"]
[connection signal="request_completed" from="HTTPRequest" to="." method="_on_http_request_request_completed"]
[connection signal="close_requested" from="DownloadDialog" to="." method="_on_download_dialog_close_requested"]
[connection signal="failed" from="DownloadDialog/DownloadUpdatePanel" to="." method="_on_download_update_panel_failed"]
[connection signal="updated" from="DownloadDialog/DownloadUpdatePanel" to="." method="_on_download_update_panel_updated"]
[connection signal="confirmed" from="NeedsReloadDialog" to="." method="_on_needs_reload_dialog_confirmed"]
[connection signal="timeout" from="Timer" to="." method="_on_timer_timeout"]
</file>

<file path="addons/dialogue_manager/constants.gd">
class_name DMConstants extends RefCounted


const USER_CONFIG_PATH = "user://dialogue_manager_user_config.json"
const CACHE_PATH = "user://dialogue_manager_cache.json"


enum MutationBehaviour {
	Wait,
	DoNotWait,
	Skip
}

enum TranslationSource {
	None,
	Guess,
	CSV,
	PO
}

# Token types

const TOKEN_FUNCTION = &"function"
const TOKEN_DICTIONARY_REFERENCE = &"dictionary_reference"
const TOKEN_DICTIONARY_NESTED_REFERENCE = &"dictionary_nested_reference"
const TOKEN_GROUP = &"group"
const TOKEN_ARRAY = &"array"
const TOKEN_DICTIONARY = &"dictionary"
const TOKEN_PARENS_OPEN = &"parens_open"
const TOKEN_PARENS_CLOSE = &"parens_close"
const TOKEN_BRACKET_OPEN = &"bracket_open"
const TOKEN_BRACKET_CLOSE = &"bracket_close"
const TOKEN_BRACE_OPEN = &"brace_open"
const TOKEN_BRACE_CLOSE = &"brace_close"
const TOKEN_COLON = &"colon"
const TOKEN_COMPARISON = &"comparison"
const TOKEN_ASSIGNMENT = &"assignment"
const TOKEN_OPERATOR = &"operator"
const TOKEN_COMMA = &"comma"
const TOKEN_NULL_COALESCE = &"null_coalesce"
const TOKEN_DOT = &"dot"
const TOKEN_CONDITION = &"condition"
const TOKEN_BOOL = &"bool"
const TOKEN_NOT = &"not"
const TOKEN_AND_OR = &"and_or"
const TOKEN_STRING = &"string"
const TOKEN_NUMBER = &"number"
const TOKEN_VARIABLE = &"variable"
const TOKEN_COMMENT = &"comment"

const TOKEN_VALUE = &"value"
const TOKEN_ERROR = &"error"

# Line types

const TYPE_UNKNOWN = &""
const TYPE_IMPORT = &"import"
const TYPE_USING = &"using"
const TYPE_COMMENT = &"comment"
const TYPE_RESPONSE = &"response"
const TYPE_TITLE = &"title"
const TYPE_CONDITION = &"condition"
const TYPE_WHILE = &"while"
const TYPE_MATCH = &"match"
const TYPE_WHEN = &"when"
const TYPE_MUTATION = &"mutation"
const TYPE_GOTO = &"goto"
const TYPE_DIALOGUE = &"dialogue"
const TYPE_RANDOM = &"random"
const TYPE_ERROR = &"error"

# Line IDs

const ID_NULL = &""
const ID_ERROR = &"error"
const ID_ERROR_INVALID_TITLE = &"invalid title"
const ID_ERROR_TITLE_HAS_NO_BODY = &"title has no body"
const ID_END = &"end"
const ID_END_CONVERSATION = &"end!"

# Errors

const ERR_ERRORS_IN_IMPORTED_FILE = 100
const ERR_FILE_ALREADY_IMPORTED = 101
const ERR_DUPLICATE_IMPORT_NAME = 102
const ERR_EMPTY_TITLE = 103
const ERR_DUPLICATE_TITLE = 104
const ERR_TITLE_INVALID_CHARACTERS = 106
const ERR_UNKNOWN_TITLE = 107
const ERR_INVALID_TITLE_REFERENCE = 108
const ERR_TITLE_REFERENCE_HAS_NO_CONTENT = 109
const ERR_INVALID_EXPRESSION = 110
const ERR_UNEXPECTED_CONDITION = 111
const ERR_DUPLICATE_ID = 112
const ERR_MISSING_ID = 113
const ERR_INVALID_INDENTATION = 114
const ERR_INVALID_CONDITION_INDENTATION = 115
const ERR_INCOMPLETE_EXPRESSION = 116
const ERR_INVALID_EXPRESSION_FOR_VALUE = 117
const ERR_UNKNOWN_LINE_SYNTAX = 118
const ERR_TITLE_BEGINS_WITH_NUMBER = 119
const ERR_UNEXPECTED_END_OF_EXPRESSION = 120
const ERR_UNEXPECTED_FUNCTION = 121
const ERR_UNEXPECTED_BRACKET = 122
const ERR_UNEXPECTED_CLOSING_BRACKET = 123
const ERR_MISSING_CLOSING_BRACKET = 124
const ERR_UNEXPECTED_OPERATOR = 125
const ERR_UNEXPECTED_COMMA = 126
const ERR_UNEXPECTED_COLON = 127
const ERR_UNEXPECTED_DOT = 128
const ERR_UNEXPECTED_BOOLEAN = 129
const ERR_UNEXPECTED_STRING = 130
const ERR_UNEXPECTED_NUMBER = 131
const ERR_UNEXPECTED_VARIABLE = 132
const ERR_INVALID_INDEX = 133
const ERR_UNEXPECTED_ASSIGNMENT = 134
const ERR_UNKNOWN_USING = 135
const ERR_EXPECTED_WHEN_OR_ELSE = 136
const ERR_ONLY_ONE_ELSE_ALLOWED = 137
const ERR_WHEN_MUST_BELONG_TO_MATCH = 138
const ERR_CONCURRENT_LINE_WITHOUT_ORIGIN = 139
const ERR_GOTO_NOT_ALLOWED_ON_CONCURRECT_LINES = 140
const ERR_UNEXPECTED_SYNTAX_ON_NESTED_DIALOGUE_LINE = 141
const ERR_NESTED_DIALOGUE_INVALID_JUMP = 142


## Get the error message
static func get_error_message(error: int) -> String:
	match error:
		ERR_ERRORS_IN_IMPORTED_FILE:
			return translate(&"errors.import_errors")
		ERR_FILE_ALREADY_IMPORTED:
			return translate(&"errors.already_imported")
		ERR_DUPLICATE_IMPORT_NAME:
			return translate(&"errors.duplicate_import")
		ERR_EMPTY_TITLE:
			return translate(&"errors.empty_title")
		ERR_DUPLICATE_TITLE:
			return translate(&"errors.duplicate_title")
		ERR_TITLE_INVALID_CHARACTERS:
			return translate(&"errors.invalid_title_string")
		ERR_TITLE_BEGINS_WITH_NUMBER:
			return translate(&"errors.invalid_title_number")
		ERR_UNKNOWN_TITLE:
			return translate(&"errors.unknown_title")
		ERR_INVALID_TITLE_REFERENCE:
			return translate(&"errors.jump_to_invalid_title")
		ERR_TITLE_REFERENCE_HAS_NO_CONTENT:
			return translate(&"errors.title_has_no_content")
		ERR_INVALID_EXPRESSION:
			return translate(&"errors.invalid_expression")
		ERR_UNEXPECTED_CONDITION:
			return translate(&"errors.unexpected_condition")
		ERR_DUPLICATE_ID:
			return translate(&"errors.duplicate_id")
		ERR_MISSING_ID:
			return translate(&"errors.missing_id")
		ERR_INVALID_INDENTATION:
			return translate(&"errors.invalid_indentation")
		ERR_INVALID_CONDITION_INDENTATION:
			return translate(&"errors.condition_has_no_content")
		ERR_INCOMPLETE_EXPRESSION:
			return translate(&"errors.incomplete_expression")
		ERR_INVALID_EXPRESSION_FOR_VALUE:
			return translate(&"errors.invalid_expression_for_value")
		ERR_FILE_NOT_FOUND:
			return translate(&"errors.file_not_found")
		ERR_UNEXPECTED_END_OF_EXPRESSION:
			return translate(&"errors.unexpected_end_of_expression")
		ERR_UNEXPECTED_FUNCTION:
			return translate(&"errors.unexpected_function")
		ERR_UNEXPECTED_BRACKET:
			return translate(&"errors.unexpected_bracket")
		ERR_UNEXPECTED_CLOSING_BRACKET:
			return translate(&"errors.unexpected_closing_bracket")
		ERR_MISSING_CLOSING_BRACKET:
			return translate(&"errors.missing_closing_bracket")
		ERR_UNEXPECTED_OPERATOR:
			return translate(&"errors.unexpected_operator")
		ERR_UNEXPECTED_COMMA:
			return translate(&"errors.unexpected_comma")
		ERR_UNEXPECTED_COLON:
			return translate(&"errors.unexpected_colon")
		ERR_UNEXPECTED_DOT:
			return translate(&"errors.unexpected_dot")
		ERR_UNEXPECTED_BOOLEAN:
			return translate(&"errors.unexpected_boolean")
		ERR_UNEXPECTED_STRING:
			return translate(&"errors.unexpected_string")
		ERR_UNEXPECTED_NUMBER:
			return translate(&"errors.unexpected_number")
		ERR_UNEXPECTED_VARIABLE:
			return translate(&"errors.unexpected_variable")
		ERR_INVALID_INDEX:
			return translate(&"errors.invalid_index")
		ERR_UNEXPECTED_ASSIGNMENT:
			return translate(&"errors.unexpected_assignment")
		ERR_UNKNOWN_USING:
			return translate(&"errors.unknown_using")
		ERR_EXPECTED_WHEN_OR_ELSE:
			return translate(&"errors.expected_when_or_else")
		ERR_ONLY_ONE_ELSE_ALLOWED:
			return translate(&"errors.only_one_else_allowed")
		ERR_WHEN_MUST_BELONG_TO_MATCH:
			return translate(&"errors.when_must_belong_to_match")
		ERR_CONCURRENT_LINE_WITHOUT_ORIGIN:
			return translate(&"errors.concurrent_line_without_origin")
		ERR_GOTO_NOT_ALLOWED_ON_CONCURRECT_LINES:
			return translate(&"errors.goto_not_allowed_on_concurrect_lines")
		ERR_UNEXPECTED_SYNTAX_ON_NESTED_DIALOGUE_LINE:
			return translate(&"errors.unexpected_syntax_on_nested_dialogue_line")
		ERR_NESTED_DIALOGUE_INVALID_JUMP:
			return translate(&"errors.err_nested_dialogue_invalid_jump")

	return translate(&"errors.unknown")


static func translate(string: String) -> String:
	var base_path = new().get_script().resource_path.get_base_dir()

	var language: String = TranslationServer.get_tool_locale()
	var translations_path: String = "%s/l10n/%s.po" % [base_path, language]
	var fallback_translations_path: String = "%s/l10n/%s.po" % [base_path, TranslationServer.get_tool_locale().substr(0, 2)]
	var en_translations_path: String = "%s/l10n/en.po" % base_path
	var translations: Translation = load(translations_path if FileAccess.file_exists(translations_path) else (fallback_translations_path if FileAccess.file_exists(fallback_translations_path) else en_translations_path))
	return translations.get_message(string)
</file>

<file path="addons/dialogue_manager/dialogue_label.gd">
@icon("./assets/icon.svg")

@tool

## A RichTextLabel specifically for use with [b]Dialogue Manager[/b] dialogue.
class_name DialogueLabel extends RichTextLabel


## Emitted for each letter typed out.
signal spoke(letter: String, letter_index: int, speed: float)

## Emitted when typing paused for a `[wait]`
signal paused_typing(duration: float)

## Emitted when the player skips the typing of dialogue.
signal skipped_typing()

## Emitted when typing finishes.
signal finished_typing()


# The action to press to skip typing.
@export var skip_action: StringName = &"ui_cancel"

## The speed with which the text types out.
@export var seconds_per_step: float = 0.02

## Automatically have a brief pause when these characters are encountered.
@export var pause_at_characters: String = ".?!"

## Don't auto pause if the character after the pause is one of these.
@export var skip_pause_at_character_if_followed_by: String = ")\""

## Don't auto pause after these abbreviations (only if "." is in `pause_at_characters`).[br]
## Abbreviations are limitted to 5 characters in length [br]
## Does not support multi-period abbreviations (ex. "p.m.")
@export var skip_pause_at_abbreviations: PackedStringArray = ["Mr", "Mrs", "Ms", "Dr", "etc", "eg", "ex"]

## The amount of time to pause when exposing a character present in `pause_at_characters`.
@export var seconds_per_pause_step: float = 0.3

var _already_mutated_indices: PackedInt32Array = []


## The current line of dialogue.
var dialogue_line:
	set(next_dialogue_line):
		dialogue_line = next_dialogue_line
		custom_minimum_size = Vector2.ZERO
		text = ""
		text = dialogue_line.text
	get:
		return dialogue_line

## Whether the label is currently typing itself out.
var is_typing: bool = false:
	set(value):
		var is_finished: bool = is_typing != value and value == false
		is_typing = value
		if is_finished:
			finished_typing.emit()
	get:
		return is_typing

var _last_wait_index: int = -1
var _last_mutation_index: int = -1
var _waiting_seconds: float = 0
var _is_awaiting_mutation: bool = false


func _process(delta: float) -> void:
	if self.is_typing:
		# Type out text
		if visible_ratio < 1:
			# See if we are waiting
			if _waiting_seconds > 0:
				_waiting_seconds = _waiting_seconds - delta
			# If we are no longer waiting then keep typing
			if _waiting_seconds <= 0:
				_type_next(delta, _waiting_seconds)
		else:
			# Make sure any mutations at the end of the line get run
			_mutate_inline_mutations(get_total_character_count())
			self.is_typing = false


func _unhandled_input(event: InputEvent) -> void:
	# Note: this will no longer be reached if using Dialogue Manager > 2.32.2. To make skip handling
	# simpler (so all of mouse/keyboard/joypad are together) it is now the responsibility of the
	# dialogue balloon.
	if self.is_typing and visible_ratio < 1 and InputMap.has_action(skip_action) and event.is_action_pressed(skip_action):
		get_viewport().set_input_as_handled()
		skip_typing()


## Start typing out the text
func type_out() -> void:
	text = dialogue_line.text
	visible_characters = 0
	visible_ratio = 0
	_waiting_seconds = 0
	_last_wait_index = -1
	_last_mutation_index = -1
	_already_mutated_indices.clear()

	self.is_typing = true

	# Allow typing listeners a chance to connect
	await get_tree().process_frame

	if get_total_character_count() == 0:
		self.is_typing = false
	elif seconds_per_step == 0:
		_mutate_remaining_mutations()
		visible_characters = get_total_character_count()
		self.is_typing = false


## Stop typing out the text and jump right to the end
func skip_typing() -> void:
	_mutate_remaining_mutations()
	visible_characters = get_total_character_count()
	self.is_typing = false
	skipped_typing.emit()


# Type out the next character(s)
func _type_next(delta: float, seconds_needed: float) -> void:
	if _is_awaiting_mutation: return

	if visible_characters == get_total_character_count():
		return

	if _last_mutation_index != visible_characters:
		_last_mutation_index = visible_characters
		_mutate_inline_mutations(visible_characters)
		if _is_awaiting_mutation: return

	var additional_waiting_seconds: float = _get_pause(visible_characters)

	# Pause on characters like "."
	if _should_auto_pause():
		additional_waiting_seconds += seconds_per_pause_step

	# Pause at literal [wait] directives
	if _last_wait_index != visible_characters and additional_waiting_seconds > 0:
		_last_wait_index = visible_characters
		_waiting_seconds += additional_waiting_seconds
		paused_typing.emit(_get_pause(visible_characters))
	else:
		visible_characters += 1
		if visible_characters <= get_total_character_count():
			spoke.emit(get_parsed_text()[visible_characters - 1], visible_characters - 1, _get_speed(visible_characters))
		# See if there's time to type out some more in this frame
		seconds_needed += seconds_per_step * (1.0 / _get_speed(visible_characters))
		if seconds_needed > delta:
			_waiting_seconds += seconds_needed
		else:
			_type_next(delta, seconds_needed)


# Get the pause for the current typing position if there is one
func _get_pause(at_index: int) -> float:
	return dialogue_line.pauses.get(at_index, 0)


# Get the speed for the current typing position
func _get_speed(at_index: int) -> float:
	var speed: float = 1
	for index in dialogue_line.speeds:
		if index > at_index:
			return speed
		speed = dialogue_line.speeds[index]
	return speed


# Run any inline mutations that haven't been run yet
func _mutate_remaining_mutations() -> void:
	for i in range(visible_characters, get_total_character_count() + 1):
		_mutate_inline_mutations(i)


# Run any mutations at the current typing position
func _mutate_inline_mutations(index: int) -> void:
	for inline_mutation in dialogue_line.inline_mutations:
		# inline mutations are an array of arrays in the form of [character index, resolvable function]
		if inline_mutation[0] > index:
			return
		if inline_mutation[0] == index and not _already_mutated_indices.has(index):
			_is_awaiting_mutation = true
			# The DialogueManager can't be referenced directly here so we need to get it by its path
			await Engine.get_singleton("DialogueManager")._mutate(inline_mutation[1], dialogue_line.extra_game_states, true)
			_is_awaiting_mutation = false

	_already_mutated_indices.append(index)


# Determine if the current autopause character at the cursor should qualify to pause typing.
func _should_auto_pause() -> bool:
	if visible_characters == 0: return false

	var parsed_text: String = get_parsed_text()

	# Avoid outofbounds when the label auto-translates and the text changes to one shorter while typing out
	# Note: visible characters can be larger than parsed_text after a translation event
	if visible_characters >= parsed_text.length(): return false

	# Ignore pause characters if they are next to a non-pause character
	if parsed_text[visible_characters] in skip_pause_at_character_if_followed_by.split():
		return false

	# Ignore "." if it's between two numbers
	if visible_characters > 3 and parsed_text[visible_characters - 1] == ".":
		var possible_number: String = parsed_text.substr(visible_characters - 2, 3)
		if str(float(possible_number)).pad_decimals(1) == possible_number:
			return false

	# Ignore "." if it's used in an abbreviation
	# Note: does NOT support multi-period abbreviations (ex. p.m.)
	if "." in pause_at_characters and parsed_text[visible_characters - 1] == ".":
		for abbreviation in skip_pause_at_abbreviations:
			if visible_characters >= abbreviation.length():
				var previous_characters: String = parsed_text.substr(visible_characters - abbreviation.length() - 1, abbreviation.length())
				if previous_characters == abbreviation:
					return false

	# Ignore two non-"." characters next to each other
	var other_pause_characters: PackedStringArray = pause_at_characters.replace(".", "").split()
	if visible_characters > 1 and parsed_text[visible_characters - 1] in other_pause_characters and parsed_text[visible_characters] in other_pause_characters:
		return false

	return parsed_text[visible_characters - 1] in pause_at_characters.split()
</file>

<file path="addons/dialogue_manager/dialogue_label.tscn">
[gd_scene load_steps=2 format=3 uid="uid://ckvgyvclnwggo"]

[ext_resource type="Script" uid="uid://g32um0mltv5d" path="res://addons/dialogue_manager/dialogue_label.gd" id="1_cital"]

[node name="DialogueLabel" type="RichTextLabel"]
anchors_preset = 10
anchor_right = 1.0
grow_horizontal = 2
mouse_filter = 1
bbcode_enabled = true
fit_content = true
scroll_active = false
shortcut_keys_enabled = false
meta_underlined = false
hint_underlined = false
deselect_on_focus_loss_enabled = false
visible_characters_behavior = 1
script = ExtResource("1_cital")
skip_pause_at_abbreviations = PackedStringArray("Mr", "Mrs", "Ms", "Dr", "etc", "eg", "ex")
</file>

<file path="addons/dialogue_manager/dialogue_line.gd">
## A line of dialogue returned from [code]DialogueManager[/code].
class_name DialogueLine extends RefCounted


## The ID of this line
var id: String

## The internal type of this dialogue object. One of [code]TYPE_DIALOGUE[/code] or [code]TYPE_MUTATION[/code]
var type: String = DMConstants.TYPE_DIALOGUE

## The next line ID after this line.
var next_id: String = ""

## The character name that is saying this line.
var character: String = ""

## A dictionary of variable replacements fo the character name. Generally for internal use only.
var character_replacements: Array[Dictionary] = []

## The dialogue being spoken.
var text: String = ""

## A dictionary of replacements for the text. Generally for internal use only.
var text_replacements: Array[Dictionary] = []

## The key to use for translating this line.
var translation_key: String = ""

## A map for when and for how long to pause while typing out the dialogue text.
var pauses: Dictionary = {}

## A map for speed changes when typing out the dialogue text.
var speeds: Dictionary = {}

## A map of any mutations to run while typing out the dialogue text.
var inline_mutations: Array[Array] = []

## A list of responses attached to this line of dialogue.
var responses: Array = []

## A list of lines that are spoken simultaneously with this one.
var concurrent_lines: Array[DialogueLine] = []

## A list of any extra game states to check when resolving variables and mutations.
var extra_game_states: Array = []

## How long to show this line before advancing to the next. Either a float (of seconds), [code]"auto"[/code], or [code]null[/code].
var time: String = ""

## Any #tags that were included in the line
var tags: PackedStringArray = []

## The mutation details if this is a mutation line (where [code]type == TYPE_MUTATION[/code]).
var mutation: Dictionary = {}

## The conditions to check before including this line in the flow of dialogue. If failed the line will be skipped over.
var conditions: Dictionary = {}


func _init(data: Dictionary = {}) -> void:
	if data.size() > 0:
		id = data.id
		next_id = data.next_id
		type = data.type
		extra_game_states = data.get("extra_game_states", [])

		match type:
			DMConstants.TYPE_DIALOGUE:
				character = data.character
				character_replacements = data.get("character_replacements", [] as Array[Dictionary])
				text = data.text
				text_replacements = data.get("text_replacements", [] as Array[Dictionary])
				translation_key = data.get("translation_key", data.text)
				pauses = data.get("pauses", {})
				speeds = data.get("speeds", {})
				inline_mutations = data.get("inline_mutations", [] as Array[Array])
				time = data.get("time", "")
				tags = data.get("tags", [])
				concurrent_lines = data.get("concurrent_lines", [] as Array[DialogueLine])

			DMConstants.TYPE_MUTATION:
				mutation = data.mutation


func _to_string() -> String:
	match type:
		DMConstants.TYPE_DIALOGUE:
			return "<DialogueLine character=\"%s\" text=\"%s\">" % [character, text]
		DMConstants.TYPE_MUTATION:
			return "<DialogueLine mutation>"
	return ""


func get_tag_value(tag_name: String) -> String:
	var wrapped := "%s=" % tag_name
	for t in tags:
		if t.begins_with(wrapped):
			return t.replace(wrapped, "").strip_edges()
	return ""
</file>

<file path="addons/dialogue_manager/dialogue_manager.gd">
extends Node

const DialogueResource = preload("./dialogue_resource.gd")
const DialogueLine = preload("./dialogue_line.gd")
const DialogueResponse = preload("./dialogue_response.gd")

const DMConstants = preload("./constants.gd")
const Builtins = preload("./utilities/builtins.gd")
const DMSettings = preload("./settings.gd")
const DMCompiler = preload("./compiler/compiler.gd")
const DMCompilerResult = preload("./compiler/compiler_result.gd")
const DMResolvedLineData = preload("./compiler/resolved_line_data.gd")


## Emitted when a dialogue balloon is created and dialogue starts
signal dialogue_started(resource: DialogueResource)

## Emitted when a title is encountered while traversing dialogue, usually when jumping from a
## goto line
signal passed_title(title: String)

## Emitted when a line of dialogue is encountered.
signal got_dialogue(line: DialogueLine)

## Emitted when a mutation is encountered.
signal mutated(mutation: Dictionary)

## Emitted when some dialogue has reached the end.
signal dialogue_ended(resource: DialogueResource)

## Used internally.
signal bridge_get_next_dialogue_line_completed(line: DialogueLine)

## Used internally
signal bridge_dialogue_started(resource: DialogueResource)

## Used inernally
signal bridge_mutated()


## The list of globals that dialogue can query
var game_states: Array = []

## Allow dialogue to call singletons
var include_singletons: bool = true

## Allow dialogue to call static methods/properties on classes
var include_classes: bool = true

## Manage translation behaviour
var translation_source: DMConstants.TranslationSource = DMConstants.TranslationSource.Guess

## Used to resolve the current scene. Override if your game manages the current scene itself.
var get_current_scene: Callable = func():
	var current_scene: Node = Engine.get_main_loop().current_scene
	if current_scene == null:
		current_scene = Engine.get_main_loop().root.get_child(Engine.get_main_loop().root.get_child_count() - 1)
	return current_scene

var _has_loaded_autoloads: bool = false
var _autoloads: Dictionary = {}

var _node_properties: Array = []
var _method_info_cache: Dictionary = {}

var _dotnet_dialogue_manager: RefCounted


func _ready() -> void:
	# Cache the known Node2D properties
	_node_properties = ["Script Variables"]
	var temp_node: Node2D = Node2D.new()
	for property in temp_node.get_property_list():
		_node_properties.append(property.name)
	temp_node.free()

	# Make the dialogue manager available as a singleton
	if not Engine.has_singleton("DialogueManager"):
		Engine.register_singleton("DialogueManager", self)


## Step through lines and run any mutations until we either hit some dialogue or the end of the conversation
func get_next_dialogue_line(resource: DialogueResource, key: String = "", extra_game_states: Array = [], mutation_behaviour: DMConstants.MutationBehaviour = DMConstants.MutationBehaviour.Wait) -> DialogueLine:
	# You have to provide a valid dialogue resource
	if resource == null:
		assert(false, DMConstants.translate(&"runtime.no_resource"))
	if resource.lines.size() == 0:
		assert(false, DMConstants.translate(&"runtime.no_content").format({ file_path = resource.resource_path }))

	# Inject any "using" states into the game_states
	for state_name in resource.using_states:
		var autoload = Engine.get_main_loop().root.get_node_or_null(state_name)
		if autoload == null:
			printerr(DMConstants.translate(&"runtime.unknown_autoload").format({ autoload = state_name }))
		else:
			extra_game_states = [autoload] + extra_game_states

	# Inject "self" into the extra game states.
	extra_game_states = [{ "self": resource }] + extra_game_states

	# Get the line data
	var dialogue: DialogueLine = await get_line(resource, key, extra_game_states)

	# If our dialogue is nothing then we hit the end
	if not _is_valid(dialogue):
		dialogue_ended.emit.call_deferred(resource)
		return null

	# Run the mutation if it is one
	if dialogue.type == DMConstants.TYPE_MUTATION:
		var actual_next_id: String = dialogue.next_id.split("|")[0]
		match mutation_behaviour:
			DMConstants.MutationBehaviour.Wait:
				await _mutate(dialogue.mutation, extra_game_states)
			DMConstants.MutationBehaviour.DoNotWait:
				_mutate(dialogue.mutation, extra_game_states)
			DMConstants.MutationBehaviour.Skip:
				pass
		if actual_next_id in [DMConstants.ID_END_CONVERSATION, DMConstants.ID_NULL, null]:
			# End the conversation
			dialogue_ended.emit.call_deferred(resource)
			return null
		else:
			return await get_next_dialogue_line(resource, dialogue.next_id, extra_game_states, mutation_behaviour)
	else:
		got_dialogue.emit(dialogue)
		return dialogue


## Get a line by its ID
func get_line(resource: DialogueResource, key: String, extra_game_states: Array) -> DialogueLine:
	key = key.strip_edges()

	# See if we were given a stack instead of just the one key
	var stack: Array = key.split("|")
	key = stack.pop_front()
	var id_trail: String = "" if stack.size() == 0 else "|" + "|".join(stack)

	# Key is blank so just use the first title (or start of file)
	if key == null or key == "":
		if resource.first_title.is_empty():
			key = resource.lines.keys()[0]
		else:
			key = resource.first_title

	# See if we just ended the conversation
	if key in [DMConstants.ID_END, DMConstants.ID_NULL, null]:
		if stack.size() > 0:
			return await get_line(resource, "|".join(stack), extra_game_states)
		else:
			return null
	elif key == DMConstants.ID_END_CONVERSATION:
		return null

	# See if it is a title
	if key.begins_with("~ "):
		key = key.substr(2)
	if resource.titles.has(key):
		key = resource.titles.get(key)

	if key in resource.titles.values():
		passed_title.emit(resource.titles.find_key(key))

	if not resource.lines.has(key):
		assert(false, DMConstants.translate(&"errors.key_not_found").format({ key = key }))

	var data: Dictionary = resource.lines.get(key)

	# If next_id is an expression we need to resolve it.
	if data.has(&"next_id_expression"):
		data.next_id = await _resolve(data.next_id_expression, extra_game_states)

	# This title key points to another title key so we should jump there instead
	if data.type == DMConstants.TYPE_TITLE and data.next_id in resource.titles.values():
		return await get_line(resource, data.next_id + id_trail, extra_game_states)

	# Handle match statements
	if data.type == DMConstants.TYPE_MATCH:
		var value = await _resolve_condition_value(data, extra_game_states)
		var else_cases: Array[Dictionary] = data.cases.filter(func(s): return s.has("is_else"))
		var else_case: Dictionary = {} if else_cases.size() == 0 else else_cases.front()
		var next_id: String = ""
		for case in data.cases:
			if case == else_case:
				continue
			elif await _check_case_value(value, case, extra_game_states):
				next_id = case.next_id
				break
		# Nothing matched so check for else case
		if next_id == "":
			if not else_case.is_empty():
				next_id = else_case.next_id
			else:
				next_id = data.next_id_after
		return await get_line(resource, next_id + id_trail, extra_game_states)

	# Check for weighted random lines.
	if data.has(&"siblings"):
		# Only count siblings that pass their condition (if they have one).
		var successful_siblings: Array = data.siblings.filter(func(sibling): return not sibling.has("condition") or await _check_condition(sibling, extra_game_states))
		var target_weight: float = randf_range(0, successful_siblings.reduce(func(total, sibling): return total + sibling.weight, 0))
		var cummulative_weight: float = 0
		for sibling in successful_siblings:
			if target_weight < cummulative_weight + sibling.weight:
				data = resource.lines.get(sibling.id)
				break
			else:
				cummulative_weight += sibling.weight

	# If this line is blank and it's the last line then check for returning snippets.
	if data.type in [DMConstants.TYPE_COMMENT, DMConstants.TYPE_UNKNOWN]:
		if data.next_id in [DMConstants.ID_END, DMConstants.ID_NULL, null]:
			if stack.size() > 0:
				return await get_line(resource, "|".join(stack), extra_game_states)
			else:
				return null
		else:
			return await get_line(resource, data.next_id + id_trail, extra_game_states)

	# If the line is a random block then go to the start of the block.
	elif data.type == DMConstants.TYPE_RANDOM:
		data = resource.lines.get(data.next_id)

	# Check conditions.
	elif data.type in [DMConstants.TYPE_CONDITION, DMConstants.TYPE_WHILE]:
		# "else" will have no actual condition.
		if await _check_condition(data, extra_game_states):
			return await get_line(resource, data.next_id + id_trail, extra_game_states)
		elif data.has("next_sibling_id") and not data.next_sibling_id.is_empty():
			return await get_line(resource, data.next_sibling_id + id_trail, extra_game_states)
		else:
			return await get_line(resource, data.next_id_after + id_trail, extra_game_states)

	# Evaluate jumps.
	elif data.type == DMConstants.TYPE_GOTO:
		if data.is_snippet and not id_trail.begins_with("|" + data.next_id_after):
			id_trail = "|" + data.next_id_after + id_trail
		return await get_line(resource, data.next_id + id_trail, extra_game_states)

	elif data.type == DMConstants.TYPE_DIALOGUE:
		if not data.has(&"id"):
			data.id = key

	# Set up a line object.
	var line: DialogueLine = await create_dialogue_line(data, extra_game_states)

	# If the jump point somehow has no content then just end.
	if not line: return null

	# Find any simultaneously said lines.
	if data.has(&"concurrent_lines"):
		# If the list includes this line then it isn't the origin line so ignore it.
		if not data.concurrent_lines.has(data.id):
			# Resolve IDs to their actual lines.
			for line_id: String in data.concurrent_lines:
				line.concurrent_lines.append(await get_line(resource, line_id, extra_game_states))

	# If we are the first of a list of responses then get the other ones.
	if data.type == DMConstants.TYPE_RESPONSE:
		# Note: For some reason C# has occasional issues with using the responses property directly
		# so instead we use set and get here.
		line.set(&"responses", await _get_responses(data.get(&"responses", []), resource, id_trail, extra_game_states))
		return line

	# Inject the next node's responses if they have any.
	if resource.lines.has(line.next_id):
		var next_line: Dictionary = resource.lines.get(line.next_id)

		# If the response line is marked as a title then make sure to emit the passed_title signal.
		if line.next_id in resource.titles.values():
			passed_title.emit(resource.titles.find_key(line.next_id))

		# If the responses come from a snippet then we need to come back here afterwards.
		if next_line.type == DMConstants.TYPE_GOTO and next_line.is_snippet and not id_trail.begins_with("|" + next_line.next_id_after):
			id_trail = "|" + next_line.next_id_after + id_trail

		# If the next line is a title then check where it points to see if that is a set of responses.
		while [DMConstants.TYPE_TITLE, DMConstants.TYPE_GOTO].has(next_line.type) and resource.lines.has(next_line.next_id):
			next_line = resource.lines.get(next_line.next_id)

		if next_line != null and next_line.type == DMConstants.TYPE_RESPONSE:
			# Note: For some reason C# has occasional issues with using the responses property directly
			# so instead we use set and get here.
			line.set(&"responses", await _get_responses(next_line.get(&"responses", []), resource, id_trail, extra_game_states))

	line.next_id = "|".join(stack) if line.next_id == DMConstants.ID_NULL else line.next_id + id_trail
	return line

## Replace any variables, etc in the text.
func get_resolved_line_data(data: Dictionary, extra_game_states: Array = []) -> DMResolvedLineData:
	var text: String = translate(data)

	# Resolve variables
	for replacement in data.get(&"text_replacements", [] as Array[Dictionary]):
		var value = await _resolve(replacement.expression.duplicate(true), extra_game_states)
		var index: int = text.find(replacement.value_in_text)
		if index == -1:
			# The replacement wasn't found but maybe the regular quotes have been replaced
			# by special quotes while translating.
			index = text.replace("", "\"").replace("", "\"").find(replacement.value_in_text)
		if index > -1:
			text = text.substr(0, index) + str(value) + text.substr(index + replacement.value_in_text.length())

	var compilation: DMCompilation = DMCompilation.new()

	# Resolve random groups
	for found in compilation.regex.INLINE_RANDOM_REGEX.search_all(text):
		var options = found.get_string(&"options").split(&"|")
		text = text.replace(&"[[%s]]" % found.get_string(&"options"), options[randi_range(0, options.size() - 1)])

	# Do a pass on the markers to find any conditionals
	var markers: DMResolvedLineData = DMResolvedLineData.new(text)

	# Resolve any conditionals and update marker positions as needed
	if data.type == DMConstants.TYPE_DIALOGUE:
		var resolved_text: String = markers.text
		var conditionals: Array[RegExMatch] = compilation.regex.INLINE_CONDITIONALS_REGEX.search_all(resolved_text)
		var replacements: Array = []
		for conditional in conditionals:
			var condition_raw: String = conditional.strings[conditional.names.condition]
			var body: String = conditional.strings[conditional.names.body]
			var body_else: String = ""
			if &"[else]" in body:
				var bits = body.split(&"[else]")
				body = bits[0]
				body_else = bits[1]
			var condition: Dictionary = compilation.extract_condition("if " + condition_raw, false, 0)
			# If the condition fails then use the else of ""
			if not await _check_condition({ condition = condition }, extra_game_states):
				body = body_else
			replacements.append({
				start = conditional.get_start(),
				end = conditional.get_end(),
				string = conditional.get_string(),
				body = body
			})

		for i in range(replacements.size() - 1, -1, -1):
			var r: Dictionary = replacements[i]
			resolved_text = resolved_text.substr(0, r.start) + r.body + resolved_text.substr(r.end, 9999)
			# Move any other markers now that the text has changed
			var offset: int = r.end - r.start - r.body.length()
			for key in [&"pauses", &"speeds", &"time"]:
				if markers.get(key) == null: continue
				var marker = markers.get(key)
				var next_marker: Dictionary = {}
				for index in marker:
					if index < r.start:
						next_marker[index] = marker[index]
					elif index > r.start:
						next_marker[index - offset] = marker[index]
				markers.set(key, next_marker)
			var mutations: Array[Array] = markers.mutations
			var next_mutations: Array[Array] = []
			for mutation in mutations:
				var index = mutation[0]
				if index < r.start:
					next_mutations.append(mutation)
				elif index > r.start:
					next_mutations.append([index - offset, mutation[1]])
			markers.mutations = next_mutations

		markers.text = resolved_text

	return markers


## Replace any variables, etc in the character name
func get_resolved_character(data: Dictionary, extra_game_states: Array = []) -> String:
	var character: String = data.get(&"character", "")

	# Resolve variables
	for replacement in data.get(&"character_replacements", []):
		var value = await _resolve(replacement.expression.duplicate(true), extra_game_states)
		var index: int = character.find(replacement.value_in_text)
		if index > -1:
			character = character.substr(0, index) + str(value) + character.substr(index + replacement.value_in_text.length())

	# Resolve random groups
	var random_regex: RegEx = RegEx.new()
	random_regex.compile("\\[\\[(?<options>.*?)\\]\\]")
	for found in random_regex.search_all(character):
		var options = found.get_string(&"options").split("|")
		character = character.replace("[[%s]]" % found.get_string(&"options"), options[randi_range(0, options.size() - 1)])

	return character


## Generate a dialogue resource on the fly from some text
func create_resource_from_text(text: String) -> Resource:
	var result: DMCompilerResult = DMCompiler.compile_string(text, "")

	if result.errors.size() > 0:
		printerr(DMConstants.translate(&"runtime.errors").format({ count = result.errors.size() }))
		for error in result.errors:
			printerr(DMConstants.translate(&"runtime.error_detail").format({
				line = error.line_number + 1,
				message = DMConstants.get_error_message(error.error)
			}))
		assert(false, DMConstants.translate(&"runtime.errors_see_details").format({ count = result.errors.size() }))

	var resource: DialogueResource = DialogueResource.new()
	resource.using_states = result.using_states
	resource.titles = result.titles
	resource.first_title = result.first_title
	resource.character_names = result.character_names
	resource.lines = result.lines
	resource.raw_text = text

	return resource


#region Balloon helpers


## Show the example balloon
func show_example_dialogue_balloon(resource: DialogueResource, title: String = "", extra_game_states: Array = []) -> CanvasLayer:
	var balloon: Node = load(_get_example_balloon_path()).instantiate()
	_start_balloon.call_deferred(balloon, resource, title, extra_game_states)
	return balloon


## Show the configured dialogue balloon
func show_dialogue_balloon(resource: DialogueResource, title: String = "", extra_game_states: Array = []) -> Node:
	var balloon_path: String = DMSettings.get_setting(DMSettings.BALLOON_PATH, _get_example_balloon_path())
	if not ResourceLoader.exists(balloon_path):
		balloon_path = _get_example_balloon_path()
	return show_dialogue_balloon_scene(balloon_path, resource, title, extra_game_states)


## Show a given balloon scene
func show_dialogue_balloon_scene(balloon_scene, resource: DialogueResource, title: String = "", extra_game_states: Array = []) -> Node:
	if balloon_scene is String:
		balloon_scene = load(balloon_scene)
	if balloon_scene is PackedScene:
		balloon_scene = balloon_scene.instantiate()

	var balloon: Node = balloon_scene
	_start_balloon.call_deferred(balloon, resource, title, extra_game_states)
	return balloon


## Resolve a static line ID to an actual line ID
func static_id_to_line_id(resource: DialogueResource, static_id: String) -> String:
	var ids = static_id_to_line_ids(resource, static_id)
	if ids.size() == 0: return ""
	return ids[0]


## Resolve a static line ID to any actual line IDs that match
func static_id_to_line_ids(resource: DialogueResource, static_id: String) -> PackedStringArray:
	return resource.lines.values().filter(func(l): return l.get(&"translation_key", "") == static_id).map(func(l): return l.id)


# Call "start" on the given balloon.
func _start_balloon(balloon: Node, resource: DialogueResource, title: String, extra_game_states: Array) -> void:
	get_current_scene.call().add_child(balloon)

	if balloon.has_method(&"start"):
		balloon.start(resource, title, extra_game_states)
	elif balloon.has_method(&"Start"):
		balloon.Start(resource, title, extra_game_states)
	else:
		assert(false, DMConstants.translate(&"runtime.dialogue_balloon_missing_start_method"))

	dialogue_started.emit(resource)
	bridge_dialogue_started.emit(resource)


# Get the path to the example balloon
func _get_example_balloon_path() -> String:
	var is_small_window: bool = ProjectSettings.get_setting("display/window/size/viewport_width") < 400
	var balloon_path: String = "/example_balloon/small_example_balloon.tscn" if is_small_window else "/example_balloon/example_balloon.tscn"
	return get_script().resource_path.get_base_dir() + balloon_path


#endregion

#region dotnet bridge


func _get_dotnet_dialogue_manager() -> RefCounted:
	if not is_instance_valid(_dotnet_dialogue_manager):
		_dotnet_dialogue_manager = load(get_script().resource_path.get_base_dir() + "/DialogueManager.cs").new()
	return _dotnet_dialogue_manager


func _bridge_get_new_instance() -> Node:
	# For some reason duplicating the node with its signals doesn't work so we have to copy them over manually
	var instance = new()
	for s: Dictionary in dialogue_started.get_connections():
		instance.dialogue_started.connect(s.callable)
	for s: Dictionary in passed_title.get_connections():
		instance.passed_title.connect(s.callable)
	for s: Dictionary in got_dialogue.get_connections():
		instance.got_dialogue.connect(s.callable)
	for s: Dictionary in mutated.get_connections():
		instance.mutated.connect(s.callable)
	for s: Dictionary in dialogue_ended.get_connections():
		instance.dialogue_ended.connect(s.callable)
	instance.get_current_scene = get_current_scene
	return instance


func _bridge_get_next_dialogue_line(resource: DialogueResource, key: String, extra_game_states: Array = []) -> void:
	# dotnet needs at least one await tick of the signal gets called too quickly
	await Engine.get_main_loop().process_frame

	var line = await get_next_dialogue_line(resource, key, extra_game_states)
	bridge_get_next_dialogue_line_completed.emit(line)


func _bridge_mutate(mutation: Dictionary, extra_game_states: Array, is_inline_mutation: bool = false) -> void:
	await _mutate(mutation, extra_game_states, is_inline_mutation)
	bridge_mutated.emit()


#endregion

#region Internal helpers


# Show a message or crash with error
func show_error_for_missing_state_value(message: String, will_show: bool = true) -> void:
	if not will_show: return

	if DMSettings.get_setting(DMSettings.IGNORE_MISSING_STATE_VALUES, false):
		push_error(message)
	elif will_show:
		# If you're here then you're missing a method or property in your game state. The error
		# message down in the debugger will give you some more information.
		assert(false, message)


# Translate a string
func translate(data: Dictionary) -> String:
	if TranslationServer.get_loaded_locales().size() == 0 or translation_source == DMConstants.TranslationSource.None:
		return data.text

	var translation_key: String = data.get(&"translation_key", data.text)

	if translation_key == "" or translation_key == data.text:
		return tr(data.text)
	else:
		# Line IDs work slightly differently depending on whether the translation came from a
		# CSV or a PO file. CSVs use the line ID (or the line itself) as the translatable string
		# whereas POs use the ID as context and the line itself as the translatable string.
		match translation_source:
			DMConstants.TranslationSource.PO:
				return tr(data.text, StringName(translation_key))

			DMConstants.TranslationSource.CSV:
				return tr(translation_key)

			DMConstants.TranslationSource.Guess:
				var translation_files: Array = ProjectSettings.get_setting(&"internationalization/locale/translations")
				if translation_files.filter(func(f: String): return f.get_extension() in [&"po", &"mo"]).size() > 0:
					# Assume PO
					return tr(data.text, StringName(translation_key))
				else:
					# Assume CSV
					return tr(translation_key)

	return tr(translation_key)


# Create a line of dialogue
func create_dialogue_line(data: Dictionary, extra_game_states: Array) -> DialogueLine:
	match data.type:
		DMConstants.TYPE_DIALOGUE:
			var resolved_data: DMResolvedLineData = await get_resolved_line_data(data, extra_game_states)
			return DialogueLine.new({
				id = data.get(&"id", ""),
				type = DMConstants.TYPE_DIALOGUE,
				next_id = data.next_id,
				character = await get_resolved_character(data, extra_game_states),
				character_replacements = data.get(&"character_replacements", [] as Array[Dictionary]),
				text = resolved_data.text,
				text_replacements = data.get(&"text_replacements", [] as Array[Dictionary]),
				translation_key = data.get(&"translation_key", data.text),
				pauses = resolved_data.pauses,
				speeds = resolved_data.speeds,
				inline_mutations = resolved_data.mutations,
				time = resolved_data.time,
				tags = data.get(&"tags", []),
				extra_game_states = extra_game_states
			})

		DMConstants.TYPE_RESPONSE:
			return DialogueLine.new({
				id = data.get(&"id", ""),
				type = DMConstants.TYPE_RESPONSE,
				next_id = data.next_id,
				tags = data.get(&"tags", []),
				extra_game_states = extra_game_states
			})

		DMConstants.TYPE_MUTATION:
			return DialogueLine.new({
				id = data.get(&"id", ""),
				type = DMConstants.TYPE_MUTATION,
				next_id = data.next_id,
				mutation = data.mutation,
				extra_game_states = extra_game_states
			})

	return null


# Create a response
func create_response(data: Dictionary, extra_game_states: Array) -> DialogueResponse:
	var resolved_data: DMResolvedLineData = await get_resolved_line_data(data, extra_game_states)
	return DialogueResponse.new({
		id = data.get(&"id", ""),
		type = DMConstants.TYPE_RESPONSE,
		next_id = data.next_id,
		is_allowed = data.is_allowed,
		condition_as_text = data.get(&"condition_as_text", ""),
		character = await get_resolved_character(data, extra_game_states),
		character_replacements = data.get(&"character_replacements", [] as Array[Dictionary]),
		text = resolved_data.text,
		text_replacements = data.get(&"text_replacements", [] as Array[Dictionary]),
		tags = data.get(&"tags", []),
		translation_key = data.get(&"translation_key", data.text),
	})


# Get the current game states
func _get_game_states(extra_game_states: Array) -> Array:
	if not _has_loaded_autoloads:
		_has_loaded_autoloads = true
		# Add any autoloads to a generic state so we can refer to them by name
		for child in Engine.get_main_loop().root.get_children():
			# Ignore the dialogue manager
			if child.name == &"DialogueManager": continue
			# Ignore the current main scene
			if Engine.get_main_loop().current_scene and child.name == Engine.get_main_loop().current_scene.name: continue
			# Add the node to our known autoloads
			_autoloads[child.name] = child
		game_states = [_autoloads]
		# Add any other state shortcuts from settings
		for node_name in DMSettings.get_setting(DMSettings.STATE_AUTOLOAD_SHORTCUTS, ""):
			var state: Node = Engine.get_main_loop().root.get_node_or_null(NodePath(node_name))
			if state:
				game_states.append(state)

	var current_scene: Node = get_current_scene.call()
	var unique_states: Array = []
	for state in extra_game_states + [current_scene] + game_states:
		if state != null and not unique_states.has(state):
			unique_states.append(state)
	return unique_states


# Check if a condition is met
func _check_condition(data: Dictionary, extra_game_states: Array) -> bool:
	return bool(await _resolve_condition_value(data, extra_game_states))


# Resolve a condition's expression value
func _resolve_condition_value(data: Dictionary, extra_game_states: Array) -> Variant:
	if data.get(&"condition", null) == null: return true
	if data.condition.is_empty(): return true

	return await _resolve(data.condition.expression.duplicate(true), extra_game_states)


# Check if a match value matches a case value
func _check_case_value(match_value: Variant, data: Dictionary, extra_game_states: Array) -> bool:
	if data.get(&"condition", null) == null: return true
	if data.condition.is_empty(): return true

	var expression: Array[Dictionary] = data.condition.expression.duplicate(true)

	# Check for multiple values
	var expressions_to_check: Array = []
	var previous_comma_index: int = 0
	for i in range(0, expression.size()):
		if expression[i].type == DMConstants.TOKEN_COMMA:
			expressions_to_check.append(expression.slice(previous_comma_index, i))
			previous_comma_index = i + 1
		elif i == expression.size() - 1:
			expressions_to_check.append(expression.slice(previous_comma_index))

	for expression_to_check in expressions_to_check:
		# If the when is a comparison when insert the match value as the first value to compare to
		var already_compared: bool = false
		if expression_to_check[0].type == DMConstants.TOKEN_COMPARISON:
			expression_to_check.insert(0, {
				type = DMConstants.TOKEN_VALUE,
				value = match_value
			})
			already_compared = true

		var resolved_value = await _resolve(expression_to_check, extra_game_states)
		if (already_compared and resolved_value) or match_value == resolved_value:
			return true

	return false


# Make a change to game state or run a method
func _mutate(mutation: Dictionary, extra_game_states: Array, is_inline_mutation: bool = false) -> void:
	var expression: Array[Dictionary] = mutation.expression

	# Handle built in mutations
	if expression[0].type == DMConstants.TOKEN_FUNCTION and expression[0].function in [&"wait", &"Wait", &"debug", &"Debug"]:
		var args: Array = await _resolve_each(expression[0].value, extra_game_states)
		match expression[0].function:
			&"wait", &"Wait":
				mutated.emit(mutation.merged({ is_inline = is_inline_mutation }))
				await Engine.get_main_loop().create_timer(float(args[0])).timeout
				return

			&"debug", &"Debug":
				prints("Debug:", args)
				await Engine.get_main_loop().process_frame

	# Or pass through to the resolver
	else:
		if not _mutation_contains_assignment(mutation.expression) and not is_inline_mutation:
			mutated.emit(mutation.merged({ is_inline = is_inline_mutation }))

		if mutation.get("is_blocking", true):
			await _resolve(mutation.expression.duplicate(true), extra_game_states)
			return
		else:
			_resolve(mutation.expression.duplicate(true), extra_game_states)

	# Wait one frame to give the dialogue handler a chance to yield
	await Engine.get_main_loop().process_frame


# Check if a mutation contains an assignment token.
func _mutation_contains_assignment(mutation: Array) -> bool:
	for token in mutation:
		if token.type == DMConstants.TOKEN_ASSIGNMENT:
			return true
	return false


# Replace an array of line IDs with their response prompts
func _get_responses(ids: Array, resource: DialogueResource, id_trail: String, extra_game_states: Array) -> Array[DialogueResponse]:
	var responses: Array[DialogueResponse] = []
	for id in ids:
		var data: Dictionary = resource.lines.get(id).duplicate(true)
		data.is_allowed = await _check_condition(data, extra_game_states)
		var response: DialogueResponse = await create_response(data, extra_game_states)
		response.next_id += id_trail
		responses.append(response)

	return responses


# Get a value on the current scene or game state
func _get_state_value(property: String, extra_game_states: Array):
	# Special case for static primitive calls
	if property == "Color":
		return Color()
	elif property == "Vector2":
		return Vector2.ZERO
	elif property == "Vector3":
		return Vector3.ZERO
	elif property == "Vector4":
		return Vector4.ZERO
	elif property == "Quaternion":
		return Quaternion()

	var expression = Expression.new()
	if expression.parse(property) != OK:
		assert(false, DMConstants.translate(&"runtime.invalid_expression").format({ expression = property, error = expression.get_error_text() }))

	# Warn about possible name collisions
	_warn_about_state_name_collisions(property, extra_game_states)

	for state in _get_game_states(extra_game_states):
		if typeof(state) == TYPE_DICTIONARY:
			if state.has(property):
				return state.get(property)
		else:
			# Try for a C# constant first
			if state.get_script() \
			and state.get_script().resource_path.ends_with(".cs") \
			and _get_dotnet_dialogue_manager().ThingHasConstant(state, property):
				return _get_dotnet_dialogue_manager().ResolveThingConstant(state, property)

			# Otherwise just let Godot try and resolve it.
			var result = expression.execute([], state, false)
			if not expression.has_execute_failed():
				return result

	if include_singletons and Engine.has_singleton(property):
		return Engine.get_singleton(property)

	if include_classes:
		for class_data in ProjectSettings.get_global_class_list():
			if class_data.get(&"class") == property:
				return load(class_data.path).new()

	show_error_for_missing_state_value(DMConstants.translate(&"runtime.property_not_found").format({ property = property, states = _get_state_shortcut_names(extra_game_states) }))


# Print warnings for top-level state name collisions.
func _warn_about_state_name_collisions(target_key: String, extra_game_states: Array) -> void:
	# Don't run the check if this is a release build
	if not OS.is_debug_build(): return
	# Also don't run if the setting is off
	if not DMSettings.get_setting(DMSettings.WARN_ABOUT_METHOD_PROPERTY_OR_SIGNAL_NAME_CONFLICTS, false): return

	# Get the list of state shortcuts.
	var state_shortcuts: Array = []
	for node_name in DMSettings.get_setting(DMSettings.STATE_AUTOLOAD_SHORTCUTS, ""):
		var state: Node = Engine.get_main_loop().root.get_node_or_null(NodePath(node_name))
		if state:
			state_shortcuts.append(state)

	# Check any top level names for a collision
	var states_with_key: Array = []
	for state in extra_game_states + [get_current_scene.call()] + state_shortcuts:
		if state is Dictionary:
			if state.keys().has(target_key):
				states_with_key.append("Dictionary")
		else:
			var script: Script = (state as Object).get_script()
			if script == null:
				continue

			for method in script.get_script_method_list():
				if method.name == target_key and not states_with_key.has(state.name):
					states_with_key.append(state.name)
					break

			for property in script.get_script_property_list():
				if property.name == target_key and not states_with_key.has(state.name):
					states_with_key.append(state.name)
					break

			for signal_info in script.get_script_signal_list():
				if signal_info.name == target_key and not states_with_key.has(state.name):
					states_with_key.append(state.name)
					break

	if states_with_key.size() > 1:
		push_warning(DMConstants.translate(&"runtime.top_level_states_share_name").format({ states = ", ".join(states_with_key), key = target_key }))


# Set a value on the current scene or game state
func _set_state_value(property: String, value, extra_game_states: Array) -> void:
	for state in _get_game_states(extra_game_states):
		if typeof(state) == TYPE_DICTIONARY:
			if state.has(property):
				state[property] = value
				return
		elif _thing_has_property(state, property):
			state.set(property, value)
			return

	if property.to_snake_case() != property:
		show_error_for_missing_state_value(DMConstants.translate(&"runtime.property_not_found_missing_export").format({ property = property, states = _get_state_shortcut_names(extra_game_states) }))
	else:
		show_error_for_missing_state_value(DMConstants.translate(&"runtime.property_not_found").format({ property = property, states = _get_state_shortcut_names(extra_game_states) }))


# Get the list of state shortcut names
func _get_state_shortcut_names(extra_game_states: Array) -> String:
	var states = _get_game_states(extra_game_states)
	states.erase(_autoloads)
	return ", ".join(states.map(func(s): return "\"%s\"" % (s.name if "name" in s else s)))


# Resolve an array of expressions.
func _resolve_each(array: Array, extra_game_states: Array) -> Array:
	var results: Array = []
	for item in array:
		if not item[0].type in [DMConstants.TOKEN_BRACE_CLOSE, DMConstants.TOKEN_BRACKET_CLOSE, DMConstants.TOKEN_PARENS_CLOSE]:
			results.append(await _resolve(item.duplicate(true), extra_game_states))
	return results


# Collapse any expressions
func _resolve(tokens: Array, extra_game_states: Array):
	var i: int = 0
	var limit: int = 0

	# Handle groups first
	for token in tokens:
		if token.type == DMConstants.TOKEN_GROUP:
			token.type = DMConstants.TOKEN_VALUE
			token.value = await _resolve(token.value, extra_game_states)

	# Then variables/methods
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]

		if token.type == DMConstants.TOKEN_NULL_COALESCE:
			var caller: Dictionary = tokens[i - 1]
			if caller.value == null:
				# If the caller is null then the method/property is also null
				caller.type = DMConstants.TOKEN_VALUE
				caller.value = null
				tokens.remove_at(i + 1)
				tokens.remove_at(i)
			else:
				token.type = DMConstants.TOKEN_DOT

		elif token.type == DMConstants.TOKEN_FUNCTION:
			var function_name: String = token.function
			var args = await _resolve_each(token.value, extra_game_states)
			if tokens[i - 1].type == DMConstants.TOKEN_DOT:
				# If we are calling a deeper function then we need to collapse the
				# value into the thing we are calling the function on
				var caller: Dictionary = tokens[i - 2]
				if Builtins.is_supported(caller.value):
					caller.type = DMConstants.TOKEN_VALUE
					caller.value = Builtins.resolve_method(caller.value, function_name, args)
					tokens.remove_at(i)
					tokens.remove_at(i - 1)
					i -= 2
				elif _thing_has_method(caller.value, function_name, args):
					caller.type = DMConstants.TOKEN_VALUE
					caller.value = await _resolve_thing_method(caller.value, function_name, args)
					tokens.remove_at(i)
					tokens.remove_at(i - 1)
					i -= 2
				else:
					show_error_for_missing_state_value(DMConstants.translate(&"runtime.method_not_callable").format({ method = function_name, object = str(caller.value) }))
			else:
				var found: bool = false
				match function_name:
					&"str":
						token.type = DMConstants.TOKEN_VALUE
						token.value = str(args[0])
						found = true
					&"Vector2":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Vector2(args[0], args[1])
						found = true
					&"Vector2i":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Vector2i(args[0], args[1])
						found = true
					&"Vector3":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Vector3(args[0], args[1], args[2])
						found = true
					&"Vector3i":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Vector3i(args[0], args[1], args[2])
						found = true
					&"Vector4":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Vector4(args[0], args[1], args[2], args[3])
						found = true
					&"Vector4i":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Vector4i(args[0], args[1], args[2], args[3])
						found = true
					&"Quaternion":
						token.type = DMConstants.TOKEN_VALUE
						token.value = Quaternion(args[0], args[1], args[2], args[3])
						found = true
					&"Callable":
						token.type = DMConstants.TOKEN_VALUE
						match args.size():
							0:
								token.value = Callable()
							1:
								token.value = Callable(args[0])
							2:
								token.value = Callable(args[0], args[1])
						found = true
					&"Color":
						token.type = DMConstants.TOKEN_VALUE
						match args.size():
							0:
								token.value = Color()
							1:
								token.value = Color(args[0])
							2:
								token.value = Color(args[0], args[1])
							3:
								token.value = Color(args[0], args[1], args[2])
							4:
								token.value = Color(args[0], args[1], args[2], args[3])
						found = true
					&"load", &"Load":
						token.type = DMConstants.TOKEN_VALUE
						token.value = load(args[0])
						found = true
					&"roll_dice", &"RollDice":
						token.type = DMConstants.TOKEN_VALUE
						token.value = randi_range(1, args[0])
						found = true
					_:
						# Check for top level name conflicts
						_warn_about_state_name_collisions(function_name, extra_game_states)

						for state in _get_game_states(extra_game_states):
							if _thing_has_method(state, function_name, args):
								token.type = DMConstants.TOKEN_VALUE
								token.value = await _resolve_thing_method(state, function_name, args)
								found = true
								break

				show_error_for_missing_state_value(DMConstants.translate(&"runtime.method_not_found").format({
					method = args[0] if function_name in ["call", "call_deferred"] else function_name,
					states = _get_state_shortcut_names(extra_game_states)
				}), not found)

		elif token.type == DMConstants.TOKEN_DICTIONARY_REFERENCE:
			var value
			if i > 0 and tokens[i - 1].type == DMConstants.TOKEN_DOT:
				# If we are deep referencing then we need to get the parent object.
				# `parent.value` is the actual object and `token.variable` is the name of
				# the property within it.
				value = tokens[i - 2].value[token.variable]
				# Clean up the previous tokens
				token.erase("variable")
				tokens.remove_at(i - 1)
				tokens.remove_at(i - 2)
				i -= 2
			else:
				# Otherwise we can just get this variable as a normal state reference
				value = _get_state_value(token.variable, extra_game_states)

			var index = await _resolve(token.value, extra_game_states)
			if typeof(value) == TYPE_DICTIONARY:
				if tokens.size() > i + 1 and tokens[i + 1].type == DMConstants.TOKEN_ASSIGNMENT:
					# If the next token is an assignment then we need to leave this as a reference
					# so that it can be resolved once everything ahead of it has been resolved
					token.type = "dictionary"
					token.value = value
					token.key = index
				else:
					if value.has(index):
						token.type = DMConstants.TOKEN_VALUE
						token.value = value[index]
					else:
						show_error_for_missing_state_value(DMConstants.translate(&"runtime.key_not_found").format({ key = str(index), dictionary = token.variable }))
			elif typeof(value) == TYPE_ARRAY:
				if tokens.size() > i + 1 and tokens[i + 1].type == DMConstants.TOKEN_ASSIGNMENT:
					# If the next token is an assignment then we need to leave this as a reference
					# so that it can be resolved once everything ahead of it has been resolved
					token.type = "array"
					token.value = value
					token.key = index
				else:
					if index >= 0 and index < value.size():
						token.type = DMConstants.TOKEN_VALUE
						token.value = value[index]
					else:
						show_error_for_missing_state_value(DMConstants.translate(&"runtime.array_index_out_of_bounds").format({ index = index, array = token.variable }))

		elif token.type == DMConstants.TOKEN_DICTIONARY_NESTED_REFERENCE:
			var dictionary: Dictionary = tokens[i - 1]
			var index = await _resolve(token.value, extra_game_states)
			var value = dictionary.value
			if typeof(value) == TYPE_DICTIONARY:
				if tokens.size() > i + 1 and tokens[i + 1].type == DMConstants.TOKEN_ASSIGNMENT:
					# If the next token is an assignment then we need to leave this as a reference
					# so that it can be resolved once everything ahead of it has been resolved
					dictionary.type = "dictionary"
					dictionary.key = index
					dictionary.value = value
					tokens.remove_at(i)
					i -= 1
				else:
					if dictionary.value.has(index):
						dictionary.value = value.get(index)
						tokens.remove_at(i)
						i -= 1
					else:
						show_error_for_missing_state_value(DMConstants.translate(&"runtime.key_not_found").format({ key = str(index), dictionary = value }))
			elif typeof(value) == TYPE_ARRAY:
				if tokens.size() > i + 1 and tokens[i + 1].type == DMConstants.TOKEN_ASSIGNMENT:
					# If the next token is an assignment then we need to leave this as a reference
					# so that it can be resolved once everything ahead of it has been resolved
					dictionary.type = "array"
					dictionary.value = value
					dictionary.key = index
					tokens.remove_at(i)
					i -= 1
				else:
					if index >= 0 and index < value.size():
						dictionary.value = value[index]
						tokens.remove_at(i)
						i -= 1
					else:
						show_error_for_missing_state_value(DMConstants.translate(&"runtime.array_index_out_of_bounds").format({ index = index, array = value }))

		elif token.type == DMConstants.TOKEN_ARRAY:
			token.type = DMConstants.TOKEN_VALUE
			token.value = await _resolve_each(token.value, extra_game_states)

		elif token.type == DMConstants.TOKEN_DICTIONARY:
			token.type = DMConstants.TOKEN_VALUE
			var dictionary = {}
			for key in token.value.keys():
				var resolved_key = await _resolve([key], extra_game_states)
				var preresolved_value = token.value.get(key)
				if typeof(preresolved_value) != TYPE_ARRAY:
					preresolved_value = [preresolved_value]
				var resolved_value = await _resolve(preresolved_value, extra_game_states)
				dictionary[resolved_key] = resolved_value
			token.value = dictionary

		elif token.type == DMConstants.TOKEN_VARIABLE or token.type == DMConstants.TOKEN_NUMBER:
			if str(token.value) == "null":
				token.type = DMConstants.TOKEN_VALUE
				token.value = null
			elif str(token.value) == "self":
				token.type = DMConstants.TOKEN_VALUE
				token.value = extra_game_states[0].self
			elif tokens[i - 1].type == DMConstants.TOKEN_DOT:
				var caller: Dictionary = tokens[i - 2]
				var property = token.value
				if tokens.size() > i + 1 and tokens[i + 1].type == DMConstants.TOKEN_ASSIGNMENT:
					# If the next token is an assignment then we need to leave this as a reference
					# so that it can be resolved once everything ahead of it has been resolved
					caller.type = "property"
					caller.property = property
				else:
					# If we are requesting a deeper property then we need to collapse the
					# value into the thing we are referencing from
					caller.type = DMConstants.TOKEN_VALUE
					if Builtins.is_supported(caller.value):
						caller.value = Builtins.resolve_property(caller.value, property)
					else:
						caller.value = caller.value.get(property)
				tokens.remove_at(i)
				tokens.remove_at(i - 1)
				i -= 2
			elif tokens.size() > i + 1 and tokens[i + 1].type == DMConstants.TOKEN_ASSIGNMENT:
				# It's a normal variable but we will be assigning to it so don't resolve
				# it until everything after it has been resolved
				token.type = "variable"
			else:
				if token.type == DMConstants.TOKEN_NUMBER:
					token.type = DMConstants.TOKEN_VALUE
					token.value = token.value
				else:
					token.type = DMConstants.TOKEN_VALUE
					token.value = _get_state_value(str(token.value), extra_game_states)

		i += 1

	# Then multiply and divide
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]
		if token.type == DMConstants.TOKEN_OPERATOR and token.value in ["*", "/", "%"]:
			token.type = DMConstants.TOKEN_VALUE
			token.value = _apply_operation(token.value, tokens[i - 1].value, tokens[i + 1].value)
			tokens.remove_at(i + 1)
			tokens.remove_at(i - 1)
			i -= 1
		i += 1

	if limit >= 1000:
		assert(false, DMConstants.translate(&"runtime.something_went_wrong"))

	# Then addition and subtraction
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]
		if token.type == DMConstants.TOKEN_OPERATOR and token.value in ["+", "-"]:
			token.type = DMConstants.TOKEN_VALUE
			token.value = _apply_operation(token.value, tokens[i - 1].value, tokens[i + 1].value)
			tokens.remove_at(i + 1)
			tokens.remove_at(i - 1)
			i -= 1
		i += 1

	if limit >= 1000:
		assert(false, DMConstants.translate(&"runtime.something_went_wrong"))

	# Then negations
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]
		if token.type == DMConstants.TOKEN_NOT:
			token.type = DMConstants.TOKEN_VALUE
			token.value = not tokens[i + 1].value
			tokens.remove_at(i + 1)
			i -= 1
		i += 1

	if limit >= 1000:
		assert(false, DMConstants.translate(&"runtime.something_went_wrong"))

	# Then comparisons
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]
		if token.type == DMConstants.TOKEN_COMPARISON:
			token.type = DMConstants.TOKEN_VALUE
			token.value = _compare(token.value, tokens[i - 1].value, tokens[i + 1].value)
			tokens.remove_at(i + 1)
			tokens.remove_at(i - 1)
			i -= 1
		i += 1

	if limit >= 1000:
		assert(false, DMConstants.translate(&"runtime.something_went_wrong"))

	# Then and/or
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]
		if token.type == DMConstants.TOKEN_AND_OR:
			token.type = DMConstants.TOKEN_VALUE
			token.value = _apply_operation(token.value, tokens[i - 1].value, tokens[i + 1].value)
			tokens.remove_at(i + 1)
			tokens.remove_at(i - 1)
			i -= 1
		i += 1

	if limit >= 1000:
		assert(false, DMConstants.translate(&"runtime.something_went_wrong"))

	# Lastly, resolve any assignments
	i = 0
	limit = 0
	while i < tokens.size() and limit < 1000:
		limit += 1
		var token: Dictionary = tokens[i]
		if token.type == DMConstants.TOKEN_ASSIGNMENT:
			var lhs: Dictionary = tokens[i - 1]
			var value

			match lhs.type:
				&"variable":
					value = _apply_operation(token.value, _get_state_value(lhs.value, extra_game_states), tokens[i + 1].value)
					_set_state_value(lhs.value, value, extra_game_states)
				&"property":
					value = _apply_operation(token.value, lhs.value.get(lhs.property), tokens[i + 1].value)
					if typeof(lhs.value) == TYPE_DICTIONARY:
						lhs.value[lhs.property] = value
					else:
						lhs.value.set(lhs.property, value)
				&"dictionary":
					value = _apply_operation(token.value, lhs.value.get(lhs.key, null), tokens[i + 1].value)
					lhs.value[lhs.key] = value
				&"array":
					show_error_for_missing_state_value(
						DMConstants.translate(&"runtime.array_index_out_of_bounds").format({ index = lhs.key, array = lhs.value }),
						lhs.key >= lhs.value.size()
					)
					value = _apply_operation(token.value, lhs.value[lhs.key], tokens[i + 1].value)
					lhs.value[lhs.key] = value
				_:
					show_error_for_missing_state_value(DMConstants.translate(&"runtime.left_hand_size_cannot_be_assigned_to"))

			token.type = DMConstants.TOKEN_VALUE
			token.value = value
			tokens.remove_at(i + 1)
			tokens.remove_at(i - 1)
			i -= 1
		i += 1

	if limit >= 1000:
		assert(false, DMConstants.translate(&"runtime.something_went_wrong"))

	return tokens[0].value


# Compare two values.
func _compare(operator: String, first_value, second_value) -> bool:
	match operator:
		&"in":
			if first_value == null or second_value == null:
				return false
			else:
				return first_value in second_value
		&"<":
			if first_value == null:
				return true
			elif second_value == null:
				return false
			else:
				return first_value < second_value
		&">":
			if first_value == null:
				return false
			elif second_value == null:
				return true
			else:
				return first_value > second_value
		&"<=":
			if first_value == null:
				return true
			elif second_value == null:
				return false
			else:
				return first_value <= second_value
		&">=":
			if first_value == null:
				return false
			elif second_value == null:
				return true
			else:
				return first_value >= second_value
		&"==":
			if first_value == null:
				if typeof(second_value) == TYPE_BOOL:
					return second_value == false
				else:
					return second_value == null
			else:
				return first_value == second_value
		&"!=":
			if first_value == null:
				if typeof(second_value) == TYPE_BOOL:
					return second_value == true
				else:
					return second_value != null
			else:
				return first_value != second_value

	return false


# Apply an operation from one value to another.
func _apply_operation(operator: String, first_value, second_value):
	match operator:
		&"=":
			return second_value
		&"+", &"+=":
			return first_value + second_value
		&"-", &"-=":
			return first_value - second_value
		&"/", &"/=":
			return first_value / second_value
		&"*", &"*=":
			return first_value * second_value
		&"%":
			return first_value % second_value
		&"and":
			return first_value and second_value
		&"or":
			return first_value or second_value

	assert(false, DMConstants.translate(&"runtime.unknown_operator"))


# Check if a dialogue line contains meaningful information.
func _is_valid(line: DialogueLine) -> bool:
	if line == null:
		return false
	if line.type == DMConstants.TYPE_MUTATION and line.mutation == null:
		return false
	if line.type == DMConstants.TYPE_RESPONSE and line.get(&"responses").size() == 0:
		return false
	return true


# Check that a thing has a given method.
func _thing_has_method(thing, method: String, args: Array) -> bool:
	if not is_instance_valid(thing):
		return false

	if Builtins.is_supported(thing, method):
		return thing != _autoloads
	elif thing is Dictionary:
		return false

	if method in [&"call", &"call_deferred"]:
		return thing.has_method(args[0])

	if method == &"emit_signal":
		return thing.has_signal(args[0])

	if thing.has_method(method):
		return true

	if thing.get_script() and thing.get_script().resource_path.ends_with(".cs"):
		# If we get this far then the method might be a C# method with a Task return type
		return _get_dotnet_dialogue_manager().ThingHasMethod(thing, method, args)

	return false


# Check if a given property exists
func _thing_has_property(thing: Object, property: String) -> bool:
	if thing == null:
		return false

	for p in thing.get_property_list():
		if _node_properties.has(p.name):
			# Ignore any properties on the base Node
			continue
		if p.name == property:
			return true

	if thing.get_script() and thing.get_script().resource_path.ends_with(".cs"):
		# If we get this far then the property might be a C# constant.
		return _get_dotnet_dialogue_manager().ThingHasConstant(thing, property)

	return false


func _get_method_info_for(thing: Variant, method: String, args: Array) -> Dictionary:
	# Use the thing instance id as a key for the caching dictionary.
	var thing_instance_id: int = thing.get_instance_id()
	if not _method_info_cache.has(thing_instance_id):
		var methods: Dictionary = {}
		for m in thing.get_method_list():
			methods["%s:%d" % [m.name, m.args.size()]] = m
			if not methods.has(m.name):
				methods[m.name] = m
		_method_info_cache[thing_instance_id] = methods

	var methods: Dictionary = _method_info_cache.get(thing_instance_id, {})
	var method_key: String = "%s:%d" % [method, args.size()]
	if methods.has(method_key):
		return methods.get(method_key)
	else:
		return methods.get(method)


func _resolve_thing_method(thing, method: String, args: Array):
	if Builtins.is_supported(thing):
		var result = Builtins.resolve_method(thing, method, args)
		if not Builtins.has_resolve_method_failed():
			return result

	if thing.has_method(method):
		# Try to convert any literals to the right type
		var method_info: Dictionary = _get_method_info_for(thing, method, args)
		var method_args: Array = method_info.args
		if method_info.flags & METHOD_FLAG_VARARG == 0 and method_args.size() < args.size():
			assert(false, DMConstants.translate(&"runtime.expected_n_got_n_args").format({ expected = method_args.size(), method = method, received = args.size()}))
		for i in range(0, min(method_args.size(), args.size())):
			var m: Dictionary = method_args[i]
			var to_type: int = typeof(args[i])
			if m.type == TYPE_ARRAY:
				match m.hint_string:
					&"String":
						to_type = TYPE_PACKED_STRING_ARRAY
					&"int":
						to_type = TYPE_PACKED_INT64_ARRAY
					&"float":
						to_type = TYPE_PACKED_FLOAT64_ARRAY
					&"Vector2":
						to_type = TYPE_PACKED_VECTOR2_ARRAY
					&"Vector3":
						to_type = TYPE_PACKED_VECTOR3_ARRAY
					_:
						if m.hint_string != "":
							assert(false, DMConstants.translate(&"runtime.unsupported_array_type").format({ type = m.hint_string}))
			if typeof(args[i]) != to_type:
				args[i] = convert(args[i], to_type)

		return await thing.callv(method, args)

	# If we get here then it's probably a C# method with a Task return type
	var dotnet_dialogue_manager = _get_dotnet_dialogue_manager()
	dotnet_dialogue_manager.ResolveThingMethod(thing, method, args)
	return await dotnet_dialogue_manager.Resolved
</file>

<file path="addons/dialogue_manager/dialogue_resource.gd">
@tool
@icon("./assets/icon.svg")

## A collection of dialogue lines for use with [code]DialogueManager[/code].
class_name DialogueResource extends Resource


const DialogueLine = preload("./dialogue_line.gd")

## A list of state shortcuts
@export var using_states: PackedStringArray = []

## A map of titles and the lines they point to.
@export var titles: Dictionary = {}

## A list of character names.
@export var character_names: PackedStringArray = []

## The first title in the file.
@export var first_title: String = ""

## A map of the encoded lines of dialogue.
@export var lines: Dictionary = {}

## raw version of the text
@export var raw_text: String


## Get the next printable line of dialogue, starting from a referenced line ([code]title[/code] can
## be a title string or a stringified line number). Runs any mutations along the way and then returns
## the first dialogue line encountered.
func get_next_dialogue_line(title: String = "", extra_game_states: Array = [], mutation_behaviour: DMConstants.MutationBehaviour = DMConstants.MutationBehaviour.Wait) -> DialogueLine:
	return await Engine.get_singleton("DialogueManager").get_next_dialogue_line(self, title, extra_game_states, mutation_behaviour)


## Get the list of any titles found in the file.
func get_titles() -> PackedStringArray:
	return titles.keys()


func _to_string() -> String:
	return "<DialogueResource titles=\"%s\">" % [",".join(titles.keys())]
</file>

<file path="addons/dialogue_manager/dialogue_response.gd">
## A response to a line of dialogue, usualy attached to a [code]DialogueLine[/code].
class_name DialogueResponse extends RefCounted


## The ID of this response
var id: String

## The internal type of this dialogue object, always set to [code]TYPE_RESPONSE[/code].
var type: String = DMConstants.TYPE_RESPONSE

## The next line ID to use if this response is selected by the player.
var next_id: String = ""

## [code]true[/code] if the condition of this line was met.
var is_allowed: bool = true

## The original condition text.
var condition_as_text: String = ""

## A character (depending on the "characters in responses" behaviour setting).
var character: String = ""

## A dictionary of varialbe replaces for the character name. Generally for internal use only.
var character_replacements: Array[Dictionary] = []

## The prompt for this response.
var text: String = ""

## A dictionary of variable replaces for the text. Generally for internal use only.
var text_replacements: Array[Dictionary] = []

## Any #tags
var tags: PackedStringArray = []

## The key to use for translating the text.
var translation_key: String = ""


func _init(data: Dictionary = {}) -> void:
	if data.size() > 0:
		id = data.id
		type = data.type
		next_id = data.next_id
		is_allowed = data.is_allowed
		character = data.character
		character_replacements = data.character_replacements
		text = data.text
		text_replacements = data.text_replacements
		tags = data.tags
		translation_key = data.translation_key
		condition_as_text = data.condition_as_text


func _to_string() -> String:
	return "<DialogueResponse text=\"%s\">" % text


func get_tag_value(tag_name: String) -> String:
	var wrapped := "%s=" % tag_name
	for t in tags:
		if t.begins_with(wrapped):
			return t.replace(wrapped, "").strip_edges()
	return ""
</file>

<file path="addons/dialogue_manager/dialogue_responses_menu.gd">
@icon("./assets/responses_menu.svg")

## A [Container] for dialogue responses provided by [b]Dialogue Manager[/b].
class_name DialogueResponsesMenu extends Container


## Emitted when a response is selected.
signal response_selected(response)


## Optionally specify a control to duplicate for each response
@export var response_template: Control

## The action for accepting a response (is possibly overridden by parent dialogue balloon).
@export var next_action: StringName = &""

## Hide any responses where [code]is_allowed[/code] is false
@export var hide_failed_responses: bool = false

## The list of dialogue responses.
var responses: Array = []:
	get:
		return responses
	set(value):
		responses = value

		# Remove any current items
		for item in get_children():
			if item == response_template: continue

			remove_child(item)
			item.queue_free()

		# Add new items
		if responses.size() > 0:
			for response in responses:
				if hide_failed_responses and not response.is_allowed: continue

				var item: Control
				if is_instance_valid(response_template):
					item = response_template.duplicate(DUPLICATE_GROUPS | DUPLICATE_SCRIPTS | DUPLICATE_SIGNALS)
					item.show()
				else:
					item = Button.new()
				item.name = "Response%d" % get_child_count()
				if not response.is_allowed:
					item.name = item.name + &"Disallowed"
					item.disabled = true

				# If the item has a response property then use that
				if "response" in item:
					item.response = response
				# Otherwise assume we can just set the text
				else:
					item.text = response.text

				item.set_meta("response", response)

				add_child(item)

			_configure_focus()


func _ready() -> void:
	visibility_changed.connect(func():
		if visible and get_menu_items().size() > 0:
			var first_item: Control = get_menu_items()[0]
			if first_item.is_inside_tree():
				first_item.grab_focus()
	)

	if is_instance_valid(response_template):
		response_template.hide()


## Get the selectable items in the menu.
func get_menu_items() -> Array:
	var items: Array = []
	for child in get_children():
		if not child.visible: continue
		if "Disallowed" in child.name: continue
		items.append(child)

	return items


#region Internal


# Prepare the menu for keyboard and mouse navigation.
func _configure_focus() -> void:
	var items = get_menu_items()
	for i in items.size():
		var item: Control = items[i]

		item.focus_mode = Control.FOCUS_ALL

		item.focus_neighbor_left = item.get_path()
		item.focus_neighbor_right = item.get_path()

		if i == 0:
			item.focus_neighbor_top = item.get_path()
			item.focus_neighbor_left = item.get_path()
			item.focus_previous = item.get_path()
		else:
			item.focus_neighbor_top = items[i - 1].get_path()
			item.focus_neighbor_left = items[i - 1].get_path()
			item.focus_previous = items[i - 1].get_path()

		if i == items.size() - 1:
			item.focus_neighbor_bottom = item.get_path()
			item.focus_neighbor_right = item.get_path()
			item.focus_next = item.get_path()
		else:
			item.focus_neighbor_bottom = items[i + 1].get_path()
			item.focus_neighbor_right = items[i + 1].get_path()
			item.focus_next = items[i + 1].get_path()

		item.mouse_entered.connect(_on_response_mouse_entered.bind(item))
		item.gui_input.connect(_on_response_gui_input.bind(item, item.get_meta("response")))

	items[0].grab_focus()


#endregion

#region Signals


func _on_response_mouse_entered(item: Control) -> void:
	if "Disallowed" in item.name: return

	item.grab_focus()


func _on_response_gui_input(event: InputEvent, item: Control, response) -> void:
	if "Disallowed" in item.name: return

	if event is InputEventMouseButton and event.is_pressed() and event.button_index == MOUSE_BUTTON_LEFT:
		get_viewport().set_input_as_handled()
		response_selected.emit(response)
	elif event.is_action_pressed(&"ui_accept" if next_action.is_empty() else next_action) and item in get_menu_items():
		get_viewport().set_input_as_handled()
		response_selected.emit(response)


#endregion
</file>

<file path="addons/dialogue_manager/editor_translation_parser_plugin.gd">
class_name DMTranslationParserPlugin extends EditorTranslationParserPlugin


## Cached result of parsing a dialogue file.
var data: DMCompilerResult
## List of characters that were added.
var translated_character_names: PackedStringArray = []
var translated_lines: Array[Dictionary] = []


func _parse_file(path: String) -> Array[PackedStringArray]:
	var msgs: Array[PackedStringArray] = []
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	var text: String = file.get_as_text()

	data = DMCompiler.compile_string(text, path)

	var known_keys: PackedStringArray = PackedStringArray([])

	# Add all character names if settings ask for it
	if DMSettings.get_setting(DMSettings.INCLUDE_CHARACTERS_IN_TRANSLATABLE_STRINGS_LIST, true):
		translated_character_names = [] as Array[DialogueLine]
		for character_name: String in data.character_names:
			if character_name in known_keys: continue

			known_keys.append(character_name)

			translated_character_names.append(character_name)
			msgs.append(PackedStringArray([character_name.replace('"', '\"'), "dialogue", "", DMConstants.translate("translation_plugin.character_name")]))

	# Add all dialogue lines and responses
	var dialogue: Dictionary = data.lines
	for key: String in dialogue.keys():
		var line: Dictionary = dialogue.get(key)

		if not line.type in [DMConstants.TYPE_DIALOGUE, DMConstants.TYPE_RESPONSE]: continue

		var translation_key: String = line.get(&"translation_key", line.text)

		if translation_key in known_keys: continue

		known_keys.append(translation_key)
		translated_lines.append(line)
		if translation_key == line.text:
			msgs.append(PackedStringArray([line.text.replace('"', '\"'), "", "", line.get("notes", "")]))
		else:
			msgs.append(PackedStringArray([line.text.replace('"', '\"'), line.translation_key.replace('"', '\"'), "", line.get("notes", "")]))

	return msgs


func _get_recognized_extensions() -> PackedStringArray:
	return ["dialogue"]
</file>

<file path="addons/dialogue_manager/example_balloon/example_balloon.gd">
class_name DialogueManagerExampleBalloon extends CanvasLayer
## A basic dialogue balloon for use with Dialogue Manager.

## The action to use for advancing the dialogue
@export var next_action: StringName = &"ui_accept"

## The action to use to skip typing the dialogue
@export var skip_action: StringName = &"ui_cancel"

## The dialogue resource
var resource: DialogueResource

## Temporary game states
var temporary_game_states: Array = []

## See if we are waiting for the player
var is_waiting_for_input: bool = false

## See if we are running a long mutation and should hide the balloon
var will_hide_balloon: bool = false

## A dictionary to store any ephemeral variables
var locals: Dictionary = {}

var _locale: String = TranslationServer.get_locale()

## The current line
var dialogue_line: DialogueLine:
	set(value):
		if value:
			dialogue_line = value
			apply_dialogue_line()
		else:
			# The dialogue has finished so close the balloon
			queue_free()
	get:
		return dialogue_line

## A cooldown timer for delaying the balloon hide when encountering a mutation.
var mutation_cooldown: Timer = Timer.new()

## The base balloon anchor
@onready var balloon: Control = %Balloon

## The label showing the name of the currently speaking character
@onready var character_label: RichTextLabel = %CharacterLabel

## The label showing the currently spoken dialogue
@onready var dialogue_label: DialogueLabel = %DialogueLabel

## The menu of responses
@onready var responses_menu: DialogueResponsesMenu = %ResponsesMenu


func _ready() -> void:
	balloon.hide()
	Engine.get_singleton("DialogueManager").mutated.connect(_on_mutated)

	# If the responses menu doesn't have a next action set, use this one
	if responses_menu.next_action.is_empty():
		responses_menu.next_action = next_action

	mutation_cooldown.timeout.connect(_on_mutation_cooldown_timeout)
	add_child(mutation_cooldown)


func _unhandled_input(_event: InputEvent) -> void:
	# Only the balloon is allowed to handle input while it's showing
	get_viewport().set_input_as_handled()


func _notification(what: int) -> void:
	## Detect a change of locale and update the current dialogue line to show the new language
	if what == NOTIFICATION_TRANSLATION_CHANGED and _locale != TranslationServer.get_locale() and is_instance_valid(dialogue_label):
		_locale = TranslationServer.get_locale()
		var visible_ratio = dialogue_label.visible_ratio
		self.dialogue_line = await resource.get_next_dialogue_line(dialogue_line.id)
		if visible_ratio < 1:
			dialogue_label.skip_typing()


## Start some dialogue
func start(dialogue_resource: DialogueResource, title: String, extra_game_states: Array = []) -> void:
	temporary_game_states = [self] + extra_game_states
	is_waiting_for_input = false
	resource = dialogue_resource
	self.dialogue_line = await resource.get_next_dialogue_line(title, temporary_game_states)


## Apply any changes to the balloon given a new [DialogueLine].
func apply_dialogue_line() -> void:
	mutation_cooldown.stop()

	is_waiting_for_input = false
	balloon.focus_mode = Control.FOCUS_ALL
	balloon.grab_focus()

	character_label.visible = not dialogue_line.character.is_empty()
	character_label.text = tr(dialogue_line.character, "dialogue")

	dialogue_label.hide()
	dialogue_label.dialogue_line = dialogue_line

	responses_menu.hide()
	responses_menu.responses = dialogue_line.responses

	# Show our balloon
	balloon.show()
	will_hide_balloon = false

	dialogue_label.show()
	if not dialogue_line.text.is_empty():
		dialogue_label.type_out()
		await dialogue_label.finished_typing

	# Wait for input
	if dialogue_line.responses.size() > 0:
		balloon.focus_mode = Control.FOCUS_NONE
		responses_menu.show()
	elif dialogue_line.time != "":
		var time = dialogue_line.text.length() * 0.02 if dialogue_line.time == "auto" else dialogue_line.time.to_float()
		await get_tree().create_timer(time).timeout
		next(dialogue_line.next_id)
	else:
		is_waiting_for_input = true
		balloon.focus_mode = Control.FOCUS_ALL
		balloon.grab_focus()


## Go to the next line
func next(next_id: String) -> void:
	self.dialogue_line = await resource.get_next_dialogue_line(next_id, temporary_game_states)


#region Signals


func _on_mutation_cooldown_timeout() -> void:
	if will_hide_balloon:
		will_hide_balloon = false
		balloon.hide()


func _on_mutated(_mutation: Dictionary) -> void:
	is_waiting_for_input = false
	will_hide_balloon = true
	mutation_cooldown.start(0.1)


func _on_balloon_gui_input(event: InputEvent) -> void:
	# See if we need to skip typing of the dialogue
	if dialogue_label.is_typing:
		var mouse_was_clicked: bool = event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed()
		var skip_button_was_pressed: bool = event.is_action_pressed(skip_action)
		if mouse_was_clicked or skip_button_was_pressed:
			get_viewport().set_input_as_handled()
			dialogue_label.skip_typing()
			return

	if not is_waiting_for_input: return
	if dialogue_line.responses.size() > 0: return

	# When there are no response options the balloon itself is the clickable thing
	get_viewport().set_input_as_handled()

	if event is InputEventMouseButton and event.is_pressed() and event.button_index == MOUSE_BUTTON_LEFT:
		next(dialogue_line.next_id)
	elif event.is_action_pressed(next_action) and get_viewport().gui_get_focus_owner() == balloon:
		next(dialogue_line.next_id)


func _on_responses_menu_response_selected(response: DialogueResponse) -> void:
	next(response.next_id)


#endregion
</file>

<file path="addons/dialogue_manager/example_balloon/example_balloon.tscn">
[gd_scene load_steps=9 format=3 uid="uid://73jm5qjy52vq"]

[ext_resource type="Script" uid="uid://d1wt4ma6055l8" path="res://addons/dialogue_manager/example_balloon/example_balloon.gd" id="1_36de5"]
[ext_resource type="PackedScene" uid="uid://ckvgyvclnwggo" path="res://addons/dialogue_manager/dialogue_label.tscn" id="2_a8ve6"]
[ext_resource type="Script" uid="uid://bb52rsfwhkxbn" path="res://addons/dialogue_manager/dialogue_responses_menu.gd" id="3_72ixx"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_spyqn"]
bg_color = Color(0, 0, 0, 1)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.329412, 0.329412, 0.329412, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ri4m3"]
bg_color = Color(0.121569, 0.121569, 0.121569, 1)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(1, 1, 1, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_e0njw"]
bg_color = Color(0, 0, 0, 1)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.6, 0.6, 0.6, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_uy0d5"]
bg_color = Color(0, 0, 0, 1)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="Theme" id="Theme_qq3yp"]
default_font_size = 20
Button/styles/disabled = SubResource("StyleBoxFlat_spyqn")
Button/styles/focus = SubResource("StyleBoxFlat_ri4m3")
Button/styles/hover = SubResource("StyleBoxFlat_e0njw")
Button/styles/normal = SubResource("StyleBoxFlat_e0njw")
MarginContainer/constants/margin_bottom = 15
MarginContainer/constants/margin_left = 30
MarginContainer/constants/margin_right = 30
MarginContainer/constants/margin_top = 15
Panel/styles/panel = SubResource("StyleBoxFlat_uy0d5")

[node name="ExampleBalloon" type="CanvasLayer"]
layer = 100
script = ExtResource("1_36de5")

[node name="Balloon" type="Control" parent="."]
unique_name_in_owner = true
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = SubResource("Theme_qq3yp")

[node name="Panel" type="Panel" parent="Balloon"]
clip_children = 2
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 21.0
offset_top = -183.0
offset_right = -19.0
offset_bottom = -19.0
grow_horizontal = 2
grow_vertical = 0
mouse_filter = 1

[node name="Dialogue" type="MarginContainer" parent="Balloon/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="Balloon/Panel/Dialogue"]
layout_mode = 2

[node name="CharacterLabel" type="RichTextLabel" parent="Balloon/Panel/Dialogue/VBoxContainer"]
unique_name_in_owner = true
modulate = Color(1, 1, 1, 0.501961)
layout_mode = 2
mouse_filter = 1
bbcode_enabled = true
text = "Character"
fit_content = true
scroll_active = false

[node name="DialogueLabel" parent="Balloon/Panel/Dialogue/VBoxContainer" instance=ExtResource("2_a8ve6")]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
text = "Dialogue..."

[node name="Responses" type="MarginContainer" parent="Balloon"]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -147.0
offset_top = -558.0
offset_right = 494.0
offset_bottom = -154.0
grow_horizontal = 2
grow_vertical = 0

[node name="ResponsesMenu" type="VBoxContainer" parent="Balloon/Responses" node_paths=PackedStringArray("response_template")]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 8
theme_override_constants/separation = 2
script = ExtResource("3_72ixx")
response_template = NodePath("ResponseExample")

[node name="ResponseExample" type="Button" parent="Balloon/Responses/ResponsesMenu"]
layout_mode = 2
text = "Response example"

[connection signal="gui_input" from="Balloon" to="." method="_on_balloon_gui_input"]
[connection signal="response_selected" from="Balloon/Responses/ResponsesMenu" to="." method="_on_responses_menu_response_selected"]
</file>

<file path="addons/dialogue_manager/example_balloon/small_example_balloon.tscn">
[gd_scene load_steps=10 format=3 uid="uid://13s5spsk34qu"]

[ext_resource type="Script" uid="uid://d1wt4ma6055l8" path="res://addons/dialogue_manager/example_balloon/example_balloon.gd" id="1_s2gbs"]
[ext_resource type="PackedScene" uid="uid://ckvgyvclnwggo" path="res://addons/dialogue_manager/dialogue_label.tscn" id="2_hfvdi"]
[ext_resource type="Script" uid="uid://bb52rsfwhkxbn" path="res://addons/dialogue_manager/dialogue_responses_menu.gd" id="3_1j1j0"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_235ry"]
content_margin_left = 6.0
content_margin_top = 3.0
content_margin_right = 6.0
content_margin_bottom = 3.0
bg_color = Color(0.0666667, 0.0666667, 0.0666667, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.345098, 0.345098, 0.345098, 1)
corner_radius_top_left = 3
corner_radius_top_right = 3
corner_radius_bottom_right = 3
corner_radius_bottom_left = 3

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ufjut"]
content_margin_left = 6.0
content_margin_top = 3.0
content_margin_right = 6.0
content_margin_bottom = 3.0
bg_color = Color(0.227451, 0.227451, 0.227451, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 1, 1, 1)
corner_radius_top_left = 3
corner_radius_top_right = 3
corner_radius_bottom_right = 3
corner_radius_bottom_left = 3

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_fcbqo"]
content_margin_left = 6.0
content_margin_top = 3.0
content_margin_right = 6.0
content_margin_bottom = 3.0
bg_color = Color(0.0666667, 0.0666667, 0.0666667, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
corner_radius_top_left = 3
corner_radius_top_right = 3
corner_radius_bottom_right = 3
corner_radius_bottom_left = 3

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_t6i7a"]
content_margin_left = 6.0
content_margin_top = 3.0
content_margin_right = 6.0
content_margin_bottom = 3.0
bg_color = Color(0.0666667, 0.0666667, 0.0666667, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
corner_radius_top_left = 3
corner_radius_top_right = 3
corner_radius_bottom_right = 3
corner_radius_bottom_left = 3

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_uy0d5"]
bg_color = Color(0, 0, 0, 1)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
corner_radius_top_left = 3
corner_radius_top_right = 3
corner_radius_bottom_right = 3
corner_radius_bottom_left = 3

[sub_resource type="Theme" id="Theme_qq3yp"]
default_font_size = 8
Button/styles/disabled = SubResource("StyleBoxFlat_235ry")
Button/styles/focus = SubResource("StyleBoxFlat_ufjut")
Button/styles/hover = SubResource("StyleBoxFlat_fcbqo")
Button/styles/normal = SubResource("StyleBoxFlat_t6i7a")
MarginContainer/constants/margin_bottom = 4
MarginContainer/constants/margin_left = 8
MarginContainer/constants/margin_right = 8
MarginContainer/constants/margin_top = 4
Panel/styles/panel = SubResource("StyleBoxFlat_uy0d5")

[node name="ExampleBalloon" type="CanvasLayer"]
layer = 100
script = ExtResource("1_s2gbs")

[node name="Balloon" type="Control" parent="."]
unique_name_in_owner = true
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = SubResource("Theme_qq3yp")

[node name="Panel" type="Panel" parent="Balloon"]
clip_children = 2
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 3.0
offset_top = -62.0
offset_right = -4.0
offset_bottom = -4.0
grow_horizontal = 2
grow_vertical = 0
mouse_filter = 1

[node name="Dialogue" type="MarginContainer" parent="Balloon/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="Balloon/Panel/Dialogue"]
layout_mode = 2

[node name="CharacterLabel" type="RichTextLabel" parent="Balloon/Panel/Dialogue/VBoxContainer"]
unique_name_in_owner = true
modulate = Color(1, 1, 1, 0.501961)
layout_mode = 2
mouse_filter = 1
bbcode_enabled = true
text = "Character"
fit_content = true
scroll_active = false

[node name="DialogueLabel" parent="Balloon/Panel/Dialogue/VBoxContainer" instance=ExtResource("2_hfvdi")]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
text = "Dialogue..."

[node name="Responses" type="MarginContainer" parent="Balloon"]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -124.0
offset_top = -218.0
offset_right = 125.0
offset_bottom = -50.0
grow_horizontal = 2
grow_vertical = 0

[node name="ResponsesMenu" type="VBoxContainer" parent="Balloon/Responses"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 8
theme_override_constants/separation = 2
script = ExtResource("3_1j1j0")

[node name="ResponseExample" type="Button" parent="Balloon/Responses/ResponsesMenu"]
layout_mode = 2
text = "Response Example"

[connection signal="gui_input" from="Balloon" to="." method="_on_balloon_gui_input"]
[connection signal="response_selected" from="Balloon/Responses/ResponsesMenu" to="." method="_on_responses_menu_response_selected"]
</file>

<file path="addons/dialogue_manager/export_plugin.gd">
class_name DMExportPlugin extends EditorExportPlugin

const IGNORED_PATHS = [
	"/assets",
	"/components",
	"/views",
	"inspector_plugin",
	"test_scene"
]


func _get_name() -> String:
	return "Dialogue Manager Export Plugin"


func _export_file(path: String, type: String, features: PackedStringArray) -> void:
	var plugin_path: String = Engine.get_meta("DialogueManagerPlugin").get_plugin_path()

	# Ignore any editor stuff
	for ignored_path: String in IGNORED_PATHS:
		if path.begins_with(plugin_path + ignored_path):
			skip()

	# Ignore C# stuff it not using dotnet
	if path.begins_with(plugin_path) and not DMSettings.check_for_dotnet_solution() and path.ends_with(".cs"):
		skip()
</file>

<file path="addons/dialogue_manager/import_plugin.gd">
@tool
class_name DMImportPlugin extends EditorImportPlugin


signal compiled_resource(resource: Resource)


const COMPILER_VERSION = 15


func _get_importer_name() -> String:
	return "dialogue_manager"


func _get_format_version() -> int:
	return COMPILER_VERSION


func _get_visible_name() -> String:
	return "Dialogue"


func _get_import_order() -> int:
	return -1000


func _get_priority() -> float:
	return 1000.0


func _get_resource_type():
	return "Resource"


func _get_recognized_extensions() -> PackedStringArray:
	return PackedStringArray(["dialogue"])


func _get_save_extension():
	return "tres"


func _get_preset_count() -> int:
	return 0


func _get_preset_name(preset_index: int) -> String:
	return "Unknown"


func _get_import_options(path: String, preset_index: int) -> Array:
	# When the options array is empty there is a misleading error on export
	# that actually means nothing so let's just have an invisible option.
	return [{
		name = "defaults",
		default_value = true
	}]


func _get_option_visibility(path: String, option_name: StringName, options: Dictionary) -> bool:
	return false


func _import(source_file: String, save_path: String, options: Dictionary, platform_variants: Array[String], gen_files: Array[String]) -> Error:
	var cache = Engine.get_meta("DMCache")

	# Get the raw file contents
	if not FileAccess.file_exists(source_file): return ERR_FILE_NOT_FOUND

	var file: FileAccess = FileAccess.open(source_file, FileAccess.READ)
	var raw_text: String = file.get_as_text()

	cache.file_content_changed.emit(source_file, raw_text)

	# Compile the text
	var result: DMCompilerResult = DMCompiler.compile_string(raw_text, source_file)
	if result.errors.size() > 0:
		printerr("%d errors found in %s" % [result.errors.size(), source_file])
		cache.add_errors_to_file(source_file, result.errors)
		return OK

	# Get the current addon version
	var config: ConfigFile = ConfigFile.new()
	config.load("res://addons/dialogue_manager/plugin.cfg")
	var version: String = config.get_value("plugin", "version")

	# Save the results to a resource
	var resource: DialogueResource = DialogueResource.new()
	resource.set_meta("dialogue_manager_version", version)

	resource.using_states = result.using_states
	resource.titles = result.titles
	resource.first_title = result.first_title
	resource.character_names = result.character_names
	resource.lines = result.lines
	resource.raw_text = result.raw_text

	# Clear errors and possibly trigger any cascade recompiles
	cache.add_file(source_file, result)

	var err: Error = ResourceSaver.save(resource, "%s.%s" % [save_path, _get_save_extension()])

	compiled_resource.emit(resource)

	# Recompile any dependencies
	var dependent_paths: PackedStringArray = cache.get_dependent_paths_for_reimport(source_file)
	for path in dependent_paths:
		append_import_external_resource(path)

	return err
</file>

<file path="addons/dialogue_manager/inspector_plugin.gd">
@tool
class_name DMInspectorPlugin extends EditorInspectorPlugin


const DialogueEditorProperty = preload("./components/editor_property/editor_property.gd")


func _can_handle(object) -> bool:
	if object is GDScript: return false
	if not object is Node: return false
	if "name" in object and object.name == "Dialogue Manager": return false
	return true


func _parse_property(object: Object, type, name: String, hint_type, hint_string: String, usage_flags: int, wide: bool) -> bool:
	if hint_string == "DialogueResource" or ("dialogue" in name.to_lower() and hint_string == "Resource"):
		var property_editor = DialogueEditorProperty.new()
		add_property_editor(name, property_editor)
		return true

	return false
</file>

<file path="addons/dialogue_manager/plugin.gd">
@tool
extends EditorPlugin


const MainView = preload("./views/main_view.tscn")


var import_plugin: DMImportPlugin
var export_plugin: DMExportPlugin
var inspector_plugin: DMInspectorPlugin
var translation_parser_plugin: DMTranslationParserPlugin
var main_view
var dialogue_cache: DMCache


func _enable_plugin() -> void:
	add_autoload_singleton("DialogueManager", get_plugin_path() + "/dialogue_manager.gd")


func _disable_plugin() -> void:
	remove_autoload_singleton("DialogueManager")


func _enter_tree() -> void:
	if Engine.is_editor_hint():
		Engine.set_meta("DialogueManagerPlugin", self)

		DMSettings.prepare()

		dialogue_cache = DMCache.new()
		Engine.set_meta("DMCache", dialogue_cache)

		import_plugin = DMImportPlugin.new()
		add_import_plugin(import_plugin)

		export_plugin = DMExportPlugin.new()
		add_export_plugin(export_plugin)

		inspector_plugin = DMInspectorPlugin.new()
		add_inspector_plugin(inspector_plugin)

		translation_parser_plugin = DMTranslationParserPlugin.new()
		add_translation_parser_plugin(translation_parser_plugin)

		main_view = MainView.instantiate()
		EditorInterface.get_editor_main_screen().add_child(main_view)
		_make_visible(false)
		main_view.add_child(dialogue_cache)

		_update_localization()

		EditorInterface.get_file_system_dock().files_moved.connect(_on_files_moved)
		EditorInterface.get_file_system_dock().file_removed.connect(_on_file_removed)

		add_tool_menu_item("Create copy of dialogue example balloon...", _copy_dialogue_balloon)

		# Automatically swap the script on the example balloon depending on if dotnet is being used.
		if not FileAccess.file_exists("res://tests/test_basic_dialogue.gd"):
			var plugin_path: String = get_plugin_path()
			var balloon_file_names: PackedStringArray = ["example_balloon.tscn", "small_example_balloon.tscn"]
			for balloon_file_name: String in balloon_file_names:
				var balloon_path: String = plugin_path + "/example_balloon/" + balloon_file_name
				var balloon_content: String = FileAccess.get_file_as_string(balloon_path)
				if "example_balloon.gd" in balloon_content and DMSettings.check_for_dotnet_solution():
					balloon_content = balloon_content \
						# Replace script path with the C# one
						.replace("example_balloon.gd", "ExampleBalloon.cs") \
						# Replace script UID with the C# one
						.replace(ResourceUID.id_to_text(ResourceLoader.get_resource_uid(plugin_path + "/example_balloon/example_balloon.gd")), ResourceUID.id_to_text(ResourceLoader.get_resource_uid(plugin_path + "/example_balloon/ExampleBalloon.cs")))
					var balloon_file: FileAccess = FileAccess.open(balloon_path, FileAccess.WRITE)
					balloon_file.store_string(balloon_content)
					balloon_file.close()
				elif "ExampleBalloon.cs" in balloon_content and not DMSettings.check_for_dotnet_solution():
					balloon_content = balloon_content \
						# Replace script path with the GDScript one
						.replace("ExampleBalloon.cs", "example_balloon.gd") \
						# Replace script UID with the GDScript one
						.replace(ResourceUID.id_to_text(ResourceLoader.get_resource_uid(plugin_path + "/example_balloon/ExampleBalloon.cs")), ResourceUID.id_to_text(ResourceLoader.get_resource_uid(plugin_path + "/example_balloon/example_balloon.gd")))
					var balloon_file: FileAccess = FileAccess.open(balloon_path, FileAccess.WRITE)
					balloon_file.store_string(balloon_content)
					balloon_file.close()

		# Automatically make any changes to the known custom balloon if there is one.
		var balloon_path: String = DMSettings.get_setting(DMSettings.BALLOON_PATH, "")
		if balloon_path != "" and FileAccess.file_exists(balloon_path):
			var is_small_window: bool = ProjectSettings.get_setting("display/window/size/viewport_width") < 400
			var example_balloon_file_name: String = "small_example_balloon.tscn" if is_small_window else "example_balloon.tscn"
			var example_balloon_path: String = get_plugin_path() + "/example_balloon/" + example_balloon_file_name

			var contents: String = FileAccess.get_file_as_string(balloon_path)
			var has_changed: bool = false

			# Make sure the current balloon has a UID unique from the example balloon's
			var example_balloon_uid: String = ResourceUID.id_to_text(ResourceLoader.get_resource_uid(example_balloon_path))
			var balloon_uid: String = ResourceUID.id_to_text(ResourceLoader.get_resource_uid(balloon_path))
			if example_balloon_uid == balloon_uid:
				var new_balloon_uid: String = ResourceUID.id_to_text(ResourceUID.create_id())
				contents = contents.replace(example_balloon_uid, new_balloon_uid)
				has_changed = true

			# Make sure the example balloon copy has the correct renaming of the responses menu
			if "reponses" in contents:
				contents = contents.replace("reponses", "responses")
				has_changed = true

			# Save any changes
			if has_changed:
				var balloon_file: FileAccess = FileAccess.open(balloon_path, FileAccess.WRITE)
				balloon_file.store_string(contents)
				balloon_file.close()


func _exit_tree() -> void:
	remove_import_plugin(import_plugin)
	import_plugin = null

	remove_export_plugin(export_plugin)
	export_plugin = null

	remove_inspector_plugin(inspector_plugin)
	inspector_plugin = null

	remove_translation_parser_plugin(translation_parser_plugin)
	translation_parser_plugin = null

	if is_instance_valid(main_view):
		main_view.queue_free()

	Engine.remove_meta("DialogueManagerPlugin")
	Engine.remove_meta("DMCache")

	EditorInterface.get_file_system_dock().files_moved.disconnect(_on_files_moved)
	EditorInterface.get_file_system_dock().file_removed.disconnect(_on_file_removed)

	remove_tool_menu_item("Create copy of dialogue example balloon...")


func _has_main_screen() -> bool:
	return true


func _make_visible(next_visible: bool) -> void:
	if is_instance_valid(main_view):
		main_view.visible = next_visible


func _get_plugin_name() -> String:
	return "Dialogue"


func _get_plugin_icon() -> Texture2D:
	return load(get_plugin_path() + "/assets/icon.svg")


func _handles(object) -> bool:
	var editor_settings: EditorSettings = EditorInterface.get_editor_settings()
	var external_editor: String = editor_settings.get_setting("text_editor/external/exec_path")
	var use_external_editor: bool = editor_settings.get_setting("text_editor/external/use_external_editor") and external_editor != ""
	if object is DialogueResource and use_external_editor and DMSettings.get_user_value("open_in_external_editor", false):
		var project_path: String = ProjectSettings.globalize_path("res://")
		var file_path: String = ProjectSettings.globalize_path(object.resource_path)
		OS.create_process(external_editor, [project_path, file_path])
		return false

	return object is DialogueResource


func _edit(object) -> void:
	if is_instance_valid(main_view) and is_instance_valid(object):
		main_view.open_resource(object)


func _apply_changes() -> void:
	if is_instance_valid(main_view):
		main_view.apply_changes()
		_update_localization()


func _save_external_data() -> void:
	if dialogue_cache != null:
		dialogue_cache.reimport_files()


func _build() -> bool:
	# If this is the dotnet Godot then we need to check if the solution file exists
	DMSettings.check_for_dotnet_solution()

	# Ignore errors in other files if we are just running the test scene
	if DMSettings.get_user_value("is_running_test_scene", true): return true

	if dialogue_cache != null:
		dialogue_cache.reimport_files()

		var files_with_errors = dialogue_cache.get_files_with_errors()
		if files_with_errors.size() > 0:
			for dialogue_file in files_with_errors:
				push_error("You have %d error(s) in %s" % [dialogue_file.errors.size(), dialogue_file.path])
			EditorInterface.edit_resource(load(files_with_errors[0].path))
			main_view.show_build_error_dialog()
			return false

	return true


## Get the shortcuts used by the plugin
func get_editor_shortcuts() -> Dictionary:
	var shortcuts: Dictionary = {
		toggle_comment = [
			_create_event("Ctrl+K"),
			_create_event("Ctrl+Slash")
		],
		delete_line = [
			_create_event("Ctrl+Shift+K")
		],
		move_up = [
			_create_event("Alt+Up")
		],
		move_down = [
			_create_event("Alt+Down")
		],
		save = [
			_create_event("Ctrl+Alt+S")
		],
		close_file = [
			_create_event("Ctrl+W")
		],
		find_in_files = [
			_create_event("Ctrl+Shift+F")
		],

		run_test_scene = [
			_create_event("Ctrl+F5")
		],
		text_size_increase = [
			_create_event("Ctrl+Equal")
		],
		text_size_decrease = [
			_create_event("Ctrl+Minus")
		],
		text_size_reset = [
			_create_event("Ctrl+0")
		]
	}

	var paths = EditorInterface.get_editor_paths()
	var settings
	if FileAccess.file_exists(paths.get_config_dir() + "/editor_settings-4.3.tres"):
		settings = load(paths.get_config_dir() + "/editor_settings-4.3.tres")
	elif FileAccess.file_exists(paths.get_config_dir() + "/editor_settings-4.tres"):
		settings = load(paths.get_config_dir() + "/editor_settings-4.tres")
	else:
		return shortcuts

	for s in settings.get("shortcuts"):
		for key in shortcuts:
			if s.name == "script_text_editor/%s" % key or s.name == "script_editor/%s" % key:
				shortcuts[key] = []
				for event in s.shortcuts:
					if event is InputEventKey:
						shortcuts[key].append(event)

	return shortcuts


func _create_event(string: String) -> InputEventKey:
	var event: InputEventKey = InputEventKey.new()
	var bits = string.split("+")
	event.keycode = OS.find_keycode_from_string(bits[bits.size() - 1])
	event.shift_pressed = bits.has("Shift")
	event.alt_pressed = bits.has("Alt")
	if bits.has("Ctrl") or bits.has("Command"):
		event.command_or_control_autoremap = true
	return event


## Get the editor shortcut that matches an event
func get_editor_shortcut(event: InputEventKey) -> String:
	var shortcuts: Dictionary = get_editor_shortcuts()
	for key in shortcuts:
		for shortcut in shortcuts.get(key, []):
			if event.as_text().split(" ")[0] == shortcut.as_text().split(" ")[0]:
				return key
	return ""


## Get the current version
func get_version() -> String:
	var config: ConfigFile = ConfigFile.new()
	config.load(get_plugin_path() + "/plugin.cfg")
	return config.get_value("plugin", "version")


## Get the current path of the plugin
func get_plugin_path() -> String:
	return get_script().resource_path.get_base_dir()


## Update references to a moved file
func update_import_paths(from_path: String, to_path: String) -> void:
	dialogue_cache.move_file_path(from_path, to_path)

	# Reopen the file if it's already open
	if main_view.current_file_path == from_path:
		if to_path == "":
			main_view.close_file(from_path)
		else:
			main_view.current_file_path = ""
			main_view.open_file(to_path)

	# Update any other files that import the moved file
	var dependents = dialogue_cache.get_files_with_dependency(from_path)
	for dependent in dependents:
		dependent.dependencies.remove_at(dependent.dependencies.find(from_path))
		dependent.dependencies.append(to_path)

		# Update the live buffer
		if main_view.current_file_path == dependent.path:
			main_view.code_edit.text = main_view.code_edit.text.replace(from_path, to_path)
			main_view.open_buffers[main_view.current_file_path].pristine_text = main_view.code_edit.text

		# Open the file and update the path
		var file: FileAccess = FileAccess.open(dependent.path, FileAccess.READ)
		var text = file.get_as_text().replace(from_path, to_path)
		file.close()

		file = FileAccess.open(dependent.path, FileAccess.WRITE)
		file.store_string(text)
		file.close()


func _update_localization() -> void:
	if not DMSettings.get_setting(DMSettings.UPDATE_POT_FILES_AUTOMATICALLY, true):
		return

	var dialogue_files = dialogue_cache.get_files()

	# Add any new files to POT generation
	var files_for_pot: PackedStringArray = ProjectSettings.get_setting("internationalization/locale/translations_pot_files", [])
	var files_for_pot_changed: bool = false
	for path in dialogue_files:
		if not files_for_pot.has(path):
			files_for_pot.append(path)
			files_for_pot_changed = true

	# Remove any POT references that don't exist any more
	for i in range(files_for_pot.size() - 1, -1, -1):
		var file_for_pot: String = files_for_pot[i]
		if file_for_pot.get_extension() == "dialogue" and not dialogue_files.has(file_for_pot):
			files_for_pot.remove_at(i)
			files_for_pot_changed = true

	# Update project settings if POT changed
	if files_for_pot_changed:
		ProjectSettings.set_setting("internationalization/locale/translations_pot_files", files_for_pot)
		ProjectSettings.save()


### Callbacks


func _copy_dialogue_balloon() -> void:
	var scale: float = EditorInterface.get_editor_scale()
	var directory_dialog: FileDialog = FileDialog.new()
	var label: Label = Label.new()
	label.text = "Dialogue balloon files will be copied into chosen directory."
	directory_dialog.get_vbox().add_child(label)
	directory_dialog.file_mode = FileDialog.FILE_MODE_OPEN_DIR
	directory_dialog.min_size = Vector2(600, 500) * scale
	directory_dialog.dir_selected.connect(func(path):
		var plugin_path: String = get_plugin_path()
		var is_dotnet: bool = DMSettings.check_for_dotnet_solution()

		var balloon_path: String = path + ("/Balloon.tscn" if is_dotnet else "/balloon.tscn")
		var balloon_script_path: String = path + ("/DialogueBalloon.cs" if is_dotnet else "/balloon.gd")

		# Copy the balloon scene file and change the script reference
		var is_small_window: bool = ProjectSettings.get_setting("display/window/size/viewport_width") < 400
		var example_balloon_file_name: String = "small_example_balloon.tscn" if is_small_window else "example_balloon.tscn"
		var example_balloon_path: String = plugin_path + "/example_balloon/" + example_balloon_file_name
		var example_balloon_script_file_name: String = "ExampleBalloon.cs" if is_dotnet else "example_balloon.gd"
		var example_balloon_script_uid: String = ResourceUID.id_to_text(ResourceLoader.get_resource_uid(plugin_path + "/example_balloon/example_balloon.gd"))
		var example_balloon_uid: String = ResourceUID.id_to_text(ResourceLoader.get_resource_uid(example_balloon_path))

		# Copy the script file
		var file: FileAccess = FileAccess.open(plugin_path + "/example_balloon/" + example_balloon_script_file_name, FileAccess.READ)
		var file_contents: String = file.get_as_text()
		if is_dotnet:
			file_contents = file_contents.replace("class ExampleBalloon", "class DialogueBalloon")
		else:
			file_contents = file_contents.replace("class_name DialogueManagerExampleBalloon ", "")
		file = FileAccess.open(balloon_script_path, FileAccess.WRITE)
		file.store_string(file_contents)
		file.close()
		var new_balloon_script_uid_raw: int = ResourceUID.create_id()
		ResourceUID.add_id(new_balloon_script_uid_raw, balloon_script_path)
		var new_balloon_script_uid: String = ResourceUID.id_to_text(new_balloon_script_uid_raw)

		# Save the new balloon
		file_contents = FileAccess.get_file_as_string(example_balloon_path)
		if "example_balloon.gd" in file_contents:
			file_contents = file_contents.replace(plugin_path + "/example_balloon/example_balloon.gd", balloon_script_path)
		else:
			file_contents = file_contents.replace(plugin_path + "/example_balloon/ExampleBalloon.cs", balloon_script_path)
		var new_balloon_uid: String = ResourceUID.id_to_text(ResourceUID.create_id())
		file_contents = file_contents.replace(example_balloon_uid, new_balloon_uid).replace(example_balloon_script_uid, new_balloon_script_uid)
		file = FileAccess.open(balloon_path, FileAccess.WRITE)
		file.store_string(file_contents)
		file.close()

		EditorInterface.get_resource_filesystem().scan()
		EditorInterface.get_file_system_dock().call_deferred("navigate_to_path", balloon_path)

		DMSettings.set_setting(DMSettings.BALLOON_PATH, balloon_path)

		directory_dialog.queue_free()
	)
	EditorInterface.get_base_control().add_child(directory_dialog)
	directory_dialog.popup_centered()


### Signals


func _on_files_moved(old_file: String, new_file: String) -> void:
	update_import_paths(old_file, new_file)
	DMSettings.move_recent_file(old_file, new_file)


func _on_file_removed(file: String) -> void:
	update_import_paths(file, "")
	if is_instance_valid(main_view):
		main_view.close_file(file)
	_update_localization()
</file>

<file path="addons/dialogue_manager/settings.gd">
@tool
class_name DMSettings extends Node


#region Editor



## Wrap lines in the dialogue editor.
const WRAP_LONG_LINES = "editor/wrap_long_lines"
## The template to start new dialogue files with.
const NEW_FILE_TEMPLATE = "editor/new_file_template"

## Show lines without statis IDs as errors.
const MISSING_TRANSLATIONS_ARE_ERRORS = "editor/translations/missing_translations_are_errors"
## Include character names in the list of translatable strings.
const INCLUDE_CHARACTERS_IN_TRANSLATABLE_STRINGS_LIST = "editor/translations/include_characters_in_translatable_strings_list"
## The default locale to use when exporting CSVs
const DEFAULT_CSV_LOCALE = "editor/translations/default_csv_locale"
## Any extra CSV locales to append to the exported translation CSV
const EXTRA_CSV_LOCALES = "editor/translations/extra_csv_locales"
## Includes a "_character" column in CSV exports.
const INCLUDE_CHARACTER_IN_TRANSLATION_EXPORTS = "editor/translations/include_character_in_translation_exports"
## Includes a "_notes" column in CSV exports
const INCLUDE_NOTES_IN_TRANSLATION_EXPORTS = "editor/translations/include_notes_in_translation_exports"
## Automatically update the project's list of translatable files when dialogue files are added or removed
const UPDATE_POT_FILES_AUTOMATICALLY = "editor/translations/update_pot_files_automatically"

## A custom test scene to use when testing dialogue.
const CUSTOM_TEST_SCENE_PATH = "editor/advanced/custom_test_scene_path"
## Extra script files to include in the auto-complete-able list
const EXTRA_AUTO_COMPLETE_SCRIPT_SOURCES = "editor/advanced/extra_auto_complete_script_sources"

## The custom balloon for this game.
const BALLOON_PATH = "runtime/balloon_path"
## The names of any autoloads to shortcut into all dialogue files (so you don't have to write `using SomeGlobal` in each file).
const STATE_AUTOLOAD_SHORTCUTS = "runtime/state_autoload_shortcuts"
## Check for possible naming conflicts in state shortcuts.
const WARN_ABOUT_METHOD_PROPERTY_OR_SIGNAL_NAME_CONFLICTS = "runtime/warn_about_method_property_or_signal_name_conflicts"

## Bypass any missing state when running dialogue.
const IGNORE_MISSING_STATE_VALUES = "runtime/advanced/ignore_missing_state_values"
## Whether or not the project is utilising dotnet.
const USES_DOTNET = "runtime/advanced/uses_dotnet"


static var SETTINGS_CONFIGURATION = {
	WRAP_LONG_LINES: {
		value = false,
		type = TYPE_BOOL,
	},
	NEW_FILE_TEMPLATE: {
		value = "~ start\nNathan: [[Hi|Hello|Howdy]], this is some dialogue.\nNathan: Here are some choices.\n- First one\n\tNathan: You picked the first one.\n- Second one\n\tNathan: You picked the second one.\n- Start again => start\n- End the conversation => END\nNathan: For more information see the online documentation.\n=> END",
		type = TYPE_STRING,
		hint = PROPERTY_HINT_MULTILINE_TEXT,
	},

	MISSING_TRANSLATIONS_ARE_ERRORS: {
		value = false,
		type = TYPE_BOOL,
		is_advanced = true
	},
	INCLUDE_CHARACTERS_IN_TRANSLATABLE_STRINGS_LIST: {
		value = true,
		type = TYPE_BOOL,
	},
	DEFAULT_CSV_LOCALE: {
		value = "en",
		type = TYPE_STRING,
		hint = PROPERTY_HINT_LOCALE_ID,
	},
	EXTRA_CSV_LOCALES: {
		value = [],
		type = TYPE_PACKED_STRING_ARRAY,
		hint = PROPERTY_HINT_TYPE_STRING,
		hint_string = "%d:" % [TYPE_STRING],
		is_advanced = true
	},
	INCLUDE_CHARACTER_IN_TRANSLATION_EXPORTS: {
		value = false,
		type = TYPE_BOOL,
		is_advanced = true
	},
	INCLUDE_NOTES_IN_TRANSLATION_EXPORTS: {
		value = false,
		type = TYPE_BOOL,
		is_advanced = true
	},
	UPDATE_POT_FILES_AUTOMATICALLY: {
		value = true,
		type = TYPE_BOOL,
		is_advanced = true
	},

	CUSTOM_TEST_SCENE_PATH: {
		value = preload("./test_scene.tscn").resource_path,
		type = TYPE_STRING,
		hint = PROPERTY_HINT_FILE,
		is_advanced = true
	},
	EXTRA_AUTO_COMPLETE_SCRIPT_SOURCES: {
		value = [],
		type = TYPE_PACKED_STRING_ARRAY,
		hint = PROPERTY_HINT_TYPE_STRING,
		hint_string = "%d/%d:*.*" % [TYPE_STRING, PROPERTY_HINT_FILE],
		is_advanced = true
	},

	BALLOON_PATH: {
		value = "",
		type = TYPE_STRING,
		hint = PROPERTY_HINT_FILE,
	},
	STATE_AUTOLOAD_SHORTCUTS: {
		value = [],
		type = TYPE_PACKED_STRING_ARRAY,
		hint = PROPERTY_HINT_TYPE_STRING,
		hint_string = "%d:" % [TYPE_STRING],
	},
	WARN_ABOUT_METHOD_PROPERTY_OR_SIGNAL_NAME_CONFLICTS: {
		value = false,
		type = TYPE_BOOL,
		is_advanced = true
	},

	IGNORE_MISSING_STATE_VALUES: {
		value = false,
		type = TYPE_BOOL,
		is_advanced = true
	},
	USES_DOTNET: {
		value = false,
		type = TYPE_BOOL,
		is_hidden = true
	}
}


static func prepare() -> void:
	var should_save_settings: bool = false

	# Remap any old settings into their new keys
	var legacy_map: Dictionary = {
		states = STATE_AUTOLOAD_SHORTCUTS,
		missing_translations_are_errors = MISSING_TRANSLATIONS_ARE_ERRORS,
		export_characters_in_translation = INCLUDE_CHARACTERS_IN_TRANSLATABLE_STRINGS_LIST,
		wrap_lines = WRAP_LONG_LINES,
		new_with_template = null,
		new_template = NEW_FILE_TEMPLATE,
		include_all_responses = null,
		ignore_missing_state_values = IGNORE_MISSING_STATE_VALUES,
		custom_test_scene_path = CUSTOM_TEST_SCENE_PATH,
		default_csv_locale = DEFAULT_CSV_LOCALE,
		balloon_path = BALLOON_PATH,
		create_lines_for_responses_with_characters = null,
		include_character_in_translation_exports = INCLUDE_CHARACTER_IN_TRANSLATION_EXPORTS,
		include_notes_in_translation_exports = INCLUDE_NOTES_IN_TRANSLATION_EXPORTS,
		uses_dotnet = USES_DOTNET,
		try_suppressing_startup_unsaved_indicator = null
	}

	for legacy_key: String in legacy_map:
		if ProjectSettings.has_setting("dialogue_manager/general/%s" % legacy_key):
			should_save_settings = true
			# Remove the old setting
			var value = ProjectSettings.get_setting("dialogue_manager/general/%s" % legacy_key)
			ProjectSettings.set_setting("dialogue_manager/general/%s" % legacy_key, null)
			if legacy_map.get(legacy_key) != null:
				prints("Migrating Dialogue Manager setting %s to %s with value %s" % [legacy_key, legacy_map.get(legacy_key), str(value)])
				ProjectSettings.set_setting("dialogue_manager/%s" % [legacy_map.get(legacy_key)], value)

	# Set up initial settings
	for key: String in SETTINGS_CONFIGURATION:
		var setting_config: Dictionary = SETTINGS_CONFIGURATION[key]
		var setting_name: String = "dialogue_manager/%s" % key
		if not ProjectSettings.has_setting(setting_name):
			ProjectSettings.set_setting(setting_name, setting_config.value)
		ProjectSettings.set_initial_value(setting_name, setting_config.value)
		ProjectSettings.add_property_info({
			"name" = setting_name,
			"type" = setting_config.type,
			"hint" = setting_config.get("hint", PROPERTY_HINT_NONE),
			"hint_string" = setting_config.get("hint_string", "")
		})
		ProjectSettings.set_as_basic(setting_name, not setting_config.has("is_advanced"))
		ProjectSettings.set_as_internal(setting_name, setting_config.has("is_hidden"))

	if should_save_settings:
		ProjectSettings.save()


static func set_setting(key: String, value) -> void:
	if get_setting(key, value) != value:
		ProjectSettings.set_setting("dialogue_manager/%s" % key, value)
		ProjectSettings.set_initial_value("dialogue_manager/%s" % key, SETTINGS_CONFIGURATION[key].value)
		ProjectSettings.save()


static func get_setting(key: String, default):
	if ProjectSettings.has_setting("dialogue_manager/%s" % key):
		return ProjectSettings.get_setting("dialogue_manager/%s" % key)
	else:
		return default


static func get_settings(only_keys: PackedStringArray = []) -> Dictionary:
	var settings: Dictionary = {}
	for key in SETTINGS_CONFIGURATION.keys():
		if only_keys.is_empty() or key in only_keys:
			settings[key] = get_setting(key, SETTINGS_CONFIGURATION[key].value)
	return settings


#endregion

#region User


static func get_user_config() -> Dictionary:
	var user_config: Dictionary = {
		check_for_updates = true,
		just_refreshed = null,
		recent_files = [],
		reopen_files = [],
		most_recent_reopen_file = "",
		file_meta = {},
		run_title = "",
		run_resource_path = "",
		is_running_test_scene = false,
		has_dotnet_solution = false,
		open_in_external_editor = false
	}

	if FileAccess.file_exists(DMConstants.USER_CONFIG_PATH):
		var file: FileAccess = FileAccess.open(DMConstants.USER_CONFIG_PATH, FileAccess.READ)
		user_config.merge(JSON.parse_string(file.get_as_text()), true)

	return user_config


static func save_user_config(user_config: Dictionary) -> void:
	var file: FileAccess = FileAccess.open(DMConstants.USER_CONFIG_PATH, FileAccess.WRITE)
	file.store_string(JSON.stringify(user_config))


static func set_user_value(key: String, value) -> void:
	var user_config: Dictionary = get_user_config()
	user_config[key] = value
	save_user_config(user_config)


static func get_user_value(key: String, default = null) -> Variant:
	return get_user_config().get(key, default)


static func forget_path(path: String) -> void:
	remove_recent_file(path)
	var file_meta: Dictionary = get_user_value("file_meta", {})
	file_meta.erase(path)
	set_user_value("file_meta", file_meta)


static func add_recent_file(path: String) -> void:
	var recent_files: Array = get_user_value("recent_files", [])
	if path in recent_files:
		recent_files.erase(path)
	recent_files.insert(0, path)
	set_user_value("recent_files", recent_files)


static func move_recent_file(from_path: String, to_path: String) -> void:
	var recent_files: Array = get_user_value("recent_files", [])
	for i in range(0, recent_files.size()):
		if recent_files[i] == from_path:
			recent_files[i] = to_path
	set_user_value("recent_files", recent_files)


static func remove_recent_file(path: String) -> void:
	var recent_files: Array = get_user_value("recent_files", [])
	if path in recent_files:
		recent_files.erase(path)
	set_user_value("recent_files", recent_files)


static func get_recent_files() -> Array:
	return get_user_value("recent_files", [])


static func clear_recent_files() -> void:
	set_user_value("recent_files", [])
	set_user_value("carets", {})


static func set_caret(path: String, cursor: Vector2) -> void:
	var file_meta: Dictionary = get_user_value("file_meta", {})
	file_meta[path] = file_meta.get(path, {}).merged({ cursor = "%d,%d" % [cursor.x, cursor.y] }, true)
	set_user_value("file_meta", file_meta)


static func get_caret(path: String) -> Vector2:
	var file_meta: Dictionary = get_user_value("file_meta", {})
	if file_meta.has(path):
		var cursor: PackedStringArray = file_meta.get(path).get("cursor", "0,0").split(",")
		return Vector2(cursor[0].to_int(), cursor[1].to_int())
	else:
		return Vector2.ZERO


static func set_scroll(path: String, scroll_vertical: int) -> void:
	var file_meta: Dictionary = get_user_value("file_meta", {})
	file_meta[path] = file_meta.get(path, {}).merged({ scroll_vertical = scroll_vertical }, true)
	set_user_value("file_meta", file_meta)


static func get_scroll(path: String) -> int:
	var file_meta: Dictionary = get_user_value("file_meta", {})
	if file_meta.has(path):
		return file_meta.get(path).get("scroll_vertical", 0)
	else:
		return 0


static func check_for_dotnet_solution() -> bool:
	if Engine.is_editor_hint():
		var has_dotnet_solution: bool = false
		if ProjectSettings.has_setting("dotnet/project/solution_directory"):
			var directory: String = ProjectSettings.get("dotnet/project/solution_directory")
			var file_name: String = ProjectSettings.get("dotnet/project/assembly_name")
			has_dotnet_solution = FileAccess.file_exists("res://%s/%s.sln" % [directory, file_name])
		set_setting(DMSettings.USES_DOTNET, has_dotnet_solution)
		return has_dotnet_solution

	return get_setting(DMSettings.USES_DOTNET, false)


#endregion
</file>

<file path="addons/dialogue_manager/test_scene.gd">
class_name BaseDialogueTestScene extends Node2D


const DialogueSettings = preload("./settings.gd")
const DialogueResource = preload("./dialogue_resource.gd")


@onready var title: String = DialogueSettings.get_user_value("run_title")
@onready var resource: DialogueResource = load(DialogueSettings.get_user_value("run_resource_path"))


func _ready():
	if not Engine.is_embedded_in_editor:
		var window: Window = get_viewport()
		var screen_index: int = DisplayServer.get_primary_screen()
		window.position = Vector2(DisplayServer.screen_get_position(screen_index)) + (DisplayServer.screen_get_size(screen_index) - window.size) * 0.5
		window.mode = Window.MODE_WINDOWED

	# Normally you can just call DialogueManager directly but doing so before the plugin has been
	# enabled in settings will throw a compiler error here so I'm using `get_singleton` instead.
	var dialogue_manager = Engine.get_singleton("DialogueManager")
	dialogue_manager.dialogue_ended.connect(_on_dialogue_ended)
	dialogue_manager.show_dialogue_balloon(resource, title if not title.is_empty() else resource.first_title)


func _enter_tree() -> void:
	DialogueSettings.set_user_value("is_running_test_scene", false)


#region Signals


func _on_dialogue_ended(_resource: DialogueResource):
	get_tree().quit()


#endregion
</file>

<file path="addons/dialogue_manager/test_scene.tscn">
[gd_scene load_steps=2 format=3 uid="uid://ugd552efvil0"]

[ext_resource type="Script" uid="uid://c8e16qdgu40wo" path="res://addons/dialogue_manager/test_scene.gd" id="1_yupoh"]

[node name="TestScene" type="Node2D"]
script = ExtResource("1_yupoh")
</file>

<file path="addons/dialogue_manager/utilities/builtins.gd">
extends Object


const DialogueConstants = preload("../constants.gd")

const SUPPORTED_BUILTIN_TYPES = [
	TYPE_STRING,
	TYPE_STRING_NAME,
	TYPE_ARRAY,
	TYPE_PACKED_STRING_ARRAY,
	TYPE_VECTOR2,
	TYPE_VECTOR3,
	TYPE_VECTOR4,
	TYPE_DICTIONARY,
	TYPE_QUATERNION,
	TYPE_COLOR,
	TYPE_SIGNAL,
	TYPE_CALLABLE
]


static var resolve_method_error: Error = OK


static func is_supported(thing, with_method: String = "") -> bool:
	if not typeof(thing) in SUPPORTED_BUILTIN_TYPES: return false

	# If given a Dictionary and a method then make sure it's a known Dictionary method.
	if typeof(thing) == TYPE_DICTIONARY and with_method != "":
		return with_method in [
			&"clear",
			&"duplicate",
			&"erase",
			&"find_key",
			&"get",
			&"get_or_add",
			&"has",
			&"has_all",
			&"hash",
			&"is_empty",
			&"is_read_only",
			&"keys",
			&"make_read_only",
			&"merge",
			&"merged",
			&"recursive_equal",
			&"size",
			&"values"]

	return true


static func resolve_property(builtin, property: String):
	match typeof(builtin):
		TYPE_ARRAY, TYPE_PACKED_STRING_ARRAY, TYPE_DICTIONARY, TYPE_QUATERNION, TYPE_STRING, TYPE_STRING_NAME:
			return builtin[property]

		# Some types have constants that we need to manually resolve

		TYPE_VECTOR2:
			return resolve_vector2_property(builtin, property)
		TYPE_VECTOR3:
			return resolve_vector3_property(builtin, property)
		TYPE_VECTOR4:
			return resolve_vector4_property(builtin, property)
		TYPE_COLOR:
			return resolve_color_property(builtin, property)


static func resolve_method(thing, method_name: String, args: Array):
	resolve_method_error = OK

	# Resolve static methods manually
	match typeof(thing):
		TYPE_VECTOR2:
			match method_name:
				"from_angle":
					return Vector2.from_angle(args[0])

		TYPE_COLOR:
			match method_name:
				"from_hsv":
					return Color.from_hsv(args[0], args[1], args[2]) if args.size() == 3 else Color.from_hsv(args[0], args[1], args[2], args[3])
				"from_ok_hsl":
					return Color.from_ok_hsl(args[0], args[1], args[2]) if args.size() == 3 else Color.from_ok_hsl(args[0], args[1], args[2], args[3])
				"from_rgbe9995":
					return Color.from_rgbe9995(args[0])
				"from_string":
					return Color.from_string(args[0], args[1])

		TYPE_QUATERNION:
			match method_name:
				"from_euler":
					return Quaternion.from_euler(args[0])

	# Anything else can be evaulatated automatically
	var references: Array = ["thing"]
	for i in range(0, args.size()):
		references.append("arg%d" % i)
	var expression = Expression.new()
	if expression.parse("thing.%s(%s)" % [method_name, ",".join(references.slice(1))], references) != OK:
		assert(false, expression.get_error_text())
	var result = expression.execute([thing] + args, null, false)
	if expression.has_execute_failed():
		resolve_method_error = ERR_CANT_RESOLVE
		return null

	return result


static func has_resolve_method_failed() -> bool:
	return resolve_method_error != OK


static func resolve_color_property(color: Color, property: String):
	match property:
		"ALICE_BLUE":
			return Color.ALICE_BLUE
		"ANTIQUE_WHITE":
			return Color.ANTIQUE_WHITE
		"AQUA":
			return Color.AQUA
		"AQUAMARINE":
			return Color.AQUAMARINE
		"AZURE":
			return Color.AZURE
		"BEIGE":
			return Color.BEIGE
		"BISQUE":
			return Color.BISQUE
		"BLACK":
			return Color.BLACK
		"BLANCHED_ALMOND":
			return Color.BLANCHED_ALMOND
		"BLUE":
			return Color.BLUE
		"BLUE_VIOLET":
			return Color.BLUE_VIOLET
		"BROWN":
			return Color.BROWN
		"BURLYWOOD":
			return Color.BURLYWOOD
		"CADET_BLUE":
			return Color.CADET_BLUE
		"CHARTREUSE":
			return Color.CHARTREUSE
		"CHOCOLATE":
			return Color.CHOCOLATE
		"CORAL":
			return Color.CORAL
		"CORNFLOWER_BLUE":
			return Color.CORNFLOWER_BLUE
		"CORNSILK":
			return Color.CORNSILK
		"CRIMSON":
			return Color.CRIMSON
		"CYAN":
			return Color.CYAN
		"DARK_BLUE":
			return Color.DARK_BLUE
		"DARK_CYAN":
			return Color.DARK_CYAN
		"DARK_GOLDENROD":
			return Color.DARK_GOLDENROD
		"DARK_GRAY":
			return Color.DARK_GRAY
		"DARK_GREEN":
			return Color.DARK_GREEN
		"DARK_KHAKI":
			return Color.DARK_KHAKI
		"DARK_MAGENTA":
			return Color.DARK_MAGENTA
		"DARK_OLIVE_GREEN":
			return Color.DARK_OLIVE_GREEN
		"DARK_ORANGE":
			return Color.DARK_ORANGE
		"DARK_ORCHID":
			return Color.DARK_ORCHID
		"DARK_RED":
			return Color.DARK_RED
		"DARK_SALMON":
			return Color.DARK_SALMON
		"DARK_SEA_GREEN":
			return Color.DARK_SEA_GREEN
		"DARK_SLATE_BLUE":
			return Color.DARK_SLATE_BLUE
		"DARK_SLATE_GRAY":
			return Color.DARK_SLATE_GRAY
		"DARK_TURQUOISE":
			return Color.DARK_TURQUOISE
		"DARK_VIOLET":
			return Color.DARK_VIOLET
		"DEEP_PINK":
			return Color.DEEP_PINK
		"DEEP_SKY_BLUE":
			return Color.DEEP_SKY_BLUE
		"DIM_GRAY":
			return Color.DIM_GRAY
		"DODGER_BLUE":
			return Color.DODGER_BLUE
		"FIREBRICK":
			return Color.FIREBRICK
		"FLORAL_WHITE":
			return Color.FLORAL_WHITE
		"FOREST_GREEN":
			return Color.FOREST_GREEN
		"FUCHSIA":
			return Color.FUCHSIA
		"GAINSBORO":
			return Color.GAINSBORO
		"GHOST_WHITE":
			return Color.GHOST_WHITE
		"GOLD":
			return Color.GOLD
		"GOLDENROD":
			return Color.GOLDENROD
		"GRAY":
			return Color.GRAY
		"GREEN":
			return Color.GREEN
		"GREEN_YELLOW":
			return Color.GREEN_YELLOW
		"HONEYDEW":
			return Color.HONEYDEW
		"HOT_PINK":
			return Color.HOT_PINK
		"INDIAN_RED":
			return Color.INDIAN_RED
		"INDIGO":
			return Color.INDIGO
		"IVORY":
			return Color.IVORY
		"KHAKI":
			return Color.KHAKI
		"LAVENDER":
			return Color.LAVENDER
		"LAVENDER_BLUSH":
			return Color.LAVENDER_BLUSH
		"LAWN_GREEN":
			return Color.LAWN_GREEN
		"LEMON_CHIFFON":
			return Color.LEMON_CHIFFON
		"LIGHT_BLUE":
			return Color.LIGHT_BLUE
		"LIGHT_CORAL":
			return Color.LIGHT_CORAL
		"LIGHT_CYAN":
			return Color.LIGHT_CYAN
		"LIGHT_GOLDENROD":
			return Color.LIGHT_GOLDENROD
		"LIGHT_GRAY":
			return Color.LIGHT_GRAY
		"LIGHT_GREEN":
			return Color.LIGHT_GREEN
		"LIGHT_PINK":
			return Color.LIGHT_PINK
		"LIGHT_SALMON":
			return Color.LIGHT_SALMON
		"LIGHT_SEA_GREEN":
			return Color.LIGHT_SEA_GREEN
		"LIGHT_SKY_BLUE":
			return Color.LIGHT_SKY_BLUE
		"LIGHT_SLATE_GRAY":
			return Color.LIGHT_SLATE_GRAY
		"LIGHT_STEEL_BLUE":
			return Color.LIGHT_STEEL_BLUE
		"LIGHT_YELLOW":
			return Color.LIGHT_YELLOW
		"LIME":
			return Color.LIME
		"LIME_GREEN":
			return Color.LIME_GREEN
		"LINEN":
			return Color.LINEN
		"MAGENTA":
			return Color.MAGENTA
		"MAROON":
			return Color.MAROON
		"MEDIUM_AQUAMARINE":
			return Color.MEDIUM_AQUAMARINE
		"MEDIUM_BLUE":
			return Color.MEDIUM_BLUE
		"MEDIUM_ORCHID":
			return Color.MEDIUM_ORCHID
		"MEDIUM_PURPLE":
			return Color.MEDIUM_PURPLE
		"MEDIUM_SEA_GREEN":
			return Color.MEDIUM_SEA_GREEN
		"MEDIUM_SLATE_BLUE":
			return Color.MEDIUM_SLATE_BLUE
		"MEDIUM_SPRING_GREEN":
			return Color.MEDIUM_SPRING_GREEN
		"MEDIUM_TURQUOISE":
			return Color.MEDIUM_TURQUOISE
		"MEDIUM_VIOLET_RED":
			return Color.MEDIUM_VIOLET_RED
		"MIDNIGHT_BLUE":
			return Color.MIDNIGHT_BLUE
		"MINT_CREAM":
			return Color.MINT_CREAM
		"MISTY_ROSE":
			return Color.MISTY_ROSE
		"MOCCASIN":
			return Color.MOCCASIN
		"NAVAJO_WHITE":
			return Color.NAVAJO_WHITE
		"NAVY_BLUE":
			return Color.NAVY_BLUE
		"OLD_LACE":
			return Color.OLD_LACE
		"OLIVE":
			return Color.OLIVE
		"OLIVE_DRAB":
			return Color.OLIVE_DRAB
		"ORANGE":
			return Color.ORANGE
		"ORANGE_RED":
			return Color.ORANGE_RED
		"ORCHID":
			return Color.ORCHID
		"PALE_GOLDENROD":
			return Color.PALE_GOLDENROD
		"PALE_GREEN":
			return Color.PALE_GREEN
		"PALE_TURQUOISE":
			return Color.PALE_TURQUOISE
		"PALE_VIOLET_RED":
			return Color.PALE_VIOLET_RED
		"PAPAYA_WHIP":
			return Color.PAPAYA_WHIP
		"PEACH_PUFF":
			return Color.PEACH_PUFF
		"PERU":
			return Color.PERU
		"PINK":
			return Color.PINK
		"PLUM":
			return Color.PLUM
		"POWDER_BLUE":
			return Color.POWDER_BLUE
		"PURPLE":
			return Color.PURPLE
		"REBECCA_PURPLE":
			return Color.REBECCA_PURPLE
		"RED":
			return Color.RED
		"ROSY_BROWN":
			return Color.ROSY_BROWN
		"ROYAL_BLUE":
			return Color.ROYAL_BLUE
		"SADDLE_BROWN":
			return Color.SADDLE_BROWN
		"SALMON":
			return Color.SALMON
		"SANDY_BROWN":
			return Color.SANDY_BROWN
		"SEA_GREEN":
			return Color.SEA_GREEN
		"SEASHELL":
			return Color.SEASHELL
		"SIENNA":
			return Color.SIENNA
		"SILVER":
			return Color.SILVER
		"SKY_BLUE":
			return Color.SKY_BLUE
		"SLATE_BLUE":
			return Color.SLATE_BLUE
		"SLATE_GRAY":
			return Color.SLATE_GRAY
		"SNOW":
			return Color.SNOW
		"SPRING_GREEN":
			return Color.SPRING_GREEN
		"STEEL_BLUE":
			return Color.STEEL_BLUE
		"TAN":
			return Color.TAN
		"TEAL":
			return Color.TEAL
		"THISTLE":
			return Color.THISTLE
		"TOMATO":
			return Color.TOMATO
		"TRANSPARENT":
			return Color.TRANSPARENT
		"TURQUOISE":
			return Color.TURQUOISE
		"VIOLET":
			return Color.VIOLET
		"WEB_GRAY":
			return Color.WEB_GRAY
		"WEB_GREEN":
			return Color.WEB_GREEN
		"WEB_MAROON":
			return Color.WEB_MAROON
		"WEB_PURPLE":
			return Color.WEB_PURPLE
		"WHEAT":
			return Color.WHEAT
		"WHITE":
			return Color.WHITE
		"WHITE_SMOKE":
			return Color.WHITE_SMOKE
		"YELLOW":
			return Color.YELLOW
		"YELLOW_GREEN":
			return Color.YELLOW_GREEN

	return color[property]


static func resolve_vector2_property(vector: Vector2, property: String):
	match property:
		"AXIS_X":
			return Vector2.AXIS_X
		"AXIS_Y":
			return Vector2.AXIS_Y
		"ZERO":
			return Vector2.ZERO
		"ONE":
			return Vector2.ONE
		"INF":
			return Vector2.INF
		"LEFT":
			return Vector2.LEFT
		"RIGHT":
			return Vector2.RIGHT
		"UP":
			return Vector2.UP
		"DOWN":
			return Vector2.DOWN

		"DOWN_LEFT":
			return Vector2(-1, 1)
		"DOWN_RIGHT":
			return Vector2(1, 1)
		"UP_LEFT":
			return Vector2(-1, -1)
		"UP_RIGHT":
			return Vector2(1, -1)

	return vector[property]


static func resolve_vector3_property(vector: Vector3, property: String):
	match property:
		"AXIS_X":
			return Vector3.AXIS_X
		"AXIS_Y":
			return Vector3.AXIS_Y
		"AXIS_Z":
			return Vector3.AXIS_Z
		"ZERO":
			return Vector3.ZERO
		"ONE":
			return Vector3.ONE
		"INF":
			return Vector3.INF
		"LEFT":
			return Vector3.LEFT
		"RIGHT":
			return Vector3.RIGHT
		"UP":
			return Vector3.UP
		"DOWN":
			return Vector3.DOWN
		"FORWARD":
			return Vector3.FORWARD
		"BACK":
			return Vector3.BACK
		"MODEL_LEFT":
			return Vector3(1, 0, 0)
		"MODEL_RIGHT":
			return Vector3(-1, 0, 0)
		"MODEL_TOP":
			return Vector3(0, 1, 0)
		"MODEL_BOTTOM":
			return Vector3(0, -1, 0)
		"MODEL_FRONT":
			return Vector3(0, 0, 1)
		"MODEL_REAR":
			return Vector3(0, 0, -1)

	return vector[property]


static func resolve_vector4_property(vector: Vector4, property: String):
	match property:
		"AXIS_X":
			return Vector4.AXIS_X
		"AXIS_Y":
			return Vector4.AXIS_Y
		"AXIS_Z":
			return Vector4.AXIS_Z
		"AXIS_W":
			return Vector4.AXIS_W
		"ZERO":
			return Vector4.ZERO
		"ONE":
			return Vector4.ONE
		"INF":
			return Vector4.INF

	return vector[property]
</file>

<file path="addons/dialogue_manager/utilities/dialogue_cache.gd">
class_name DMCache extends Node


signal file_content_changed(path: String, new_content: String)


# Keep track of errors and dependencies
# {
# 	<dialogue file path> = {
# 		path = <dialogue file path>,
# 		dependencies = [<dialogue file path>, <dialogue file path>],
# 		errors = [<error>, <error>]
# 	}
# }
var _cache: Dictionary = {}

var _update_dependency_timer: Timer = Timer.new()
var _update_dependency_paths: PackedStringArray = []

var _files_marked_for_reimport: PackedStringArray = []


func _ready() -> void:
	add_child(_update_dependency_timer)
	_update_dependency_timer.timeout.connect(_on_update_dependency_timeout)

	_build_cache()


func mark_files_for_reimport(files: PackedStringArray) -> void:
	for file in files:
		if not _files_marked_for_reimport.has(file):
			_files_marked_for_reimport.append(file)


func reimport_files(and_files: PackedStringArray = []) -> void:
	for file in and_files:
		if not _files_marked_for_reimport.has(file):
			_files_marked_for_reimport.append(file)

	if _files_marked_for_reimport.is_empty(): return

	EditorInterface.get_resource_filesystem().reimport_files(_files_marked_for_reimport)
	_files_marked_for_reimport.clear()


## Add a dialogue file to the cache.
func add_file(path: String, compile_result: DMCompilerResult = null) -> void:
	_cache[path] = {
		path = path,
		dependencies = [],
		errors = []
	}

	if compile_result != null:
		_cache[path].dependencies = Array(compile_result.imported_paths).filter(func(d): return d != path)
		_cache[path].compiled_at = Time.get_ticks_msec()

	# If this is a fresh cache entry, check for dependencies
	if compile_result == null and not _update_dependency_paths.has(path):
		queue_updating_dependencies(path)


## Get the file paths in the cache
func get_files() -> PackedStringArray:
	return _cache.keys()


## Check if a file is known to the cache
func has_file(path: String) -> bool:
	return _cache.has(path)


## Remember any errors in a dialogue file
func add_errors_to_file(path: String, errors: Array[Dictionary]) -> void:
	if _cache.has(path):
		_cache[path].errors = errors
	else:
		_cache[path] = {
			path = path,
			resource_path = "",
			dependencies = [],
			errors = errors
		}


## Get a list of files that have errors
func get_files_with_errors() -> Array[Dictionary]:
	var files_with_errors: Array[Dictionary] = []
	for dialogue_file in _cache.values():
		if dialogue_file and dialogue_file.errors.size() > 0:
			files_with_errors.append(dialogue_file)
	return files_with_errors


## Queue a file to have its dependencies checked
func queue_updating_dependencies(of_path: String) -> void:
	_update_dependency_timer.stop()
	if not _update_dependency_paths.has(of_path):
		_update_dependency_paths.append(of_path)
	_update_dependency_timer.start(0.5)


## Update any references to a file path that has moved
func move_file_path(from_path: String, to_path: String) -> void:
	if not _cache.has(from_path): return

	if to_path != "":
		_cache[to_path] = _cache[from_path].duplicate()
	_cache.erase(from_path)


## Get every dialogue file that imports on a file of a given path
func get_files_with_dependency(imported_path: String) -> Array:
	return _cache.values().filter(func(d): return d.dependencies.has(imported_path))


## Get any paths that are dependent on a given path
func get_dependent_paths_for_reimport(on_path: String) -> PackedStringArray:
	return get_files_with_dependency(on_path) \
		.filter(func(d): return Time.get_ticks_msec() - d.get("compiled_at", 0) > 3000) \
		.map(func(d): return d.path)


# Build the initial cache for dialogue files
func _build_cache() -> void:
	var current_files: PackedStringArray = _get_dialogue_files_in_filesystem()
	for file in current_files:
		add_file(file)


# Recursively find any dialogue files in a directory
func _get_dialogue_files_in_filesystem(path: String = "res://") -> PackedStringArray:
	var files: PackedStringArray = []

	if DirAccess.dir_exists_absolute(path):
		var dir = DirAccess.open(path)
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			var file_path: String = (path + "/" + file_name).simplify_path()
			if dir.current_is_dir():
				if not file_name in [".godot", ".tmp"]:
					files.append_array(_get_dialogue_files_in_filesystem(file_path))
			elif file_name.get_extension() == "dialogue":
				files.append(file_path)
			file_name = dir.get_next()

	return files


#region Signals


func _on_update_dependency_timeout() -> void:
	_update_dependency_timer.stop()
	var import_regex: RegEx = RegEx.create_from_string("import \"(?<path>.*?)\"")
	var file: FileAccess
	var found_imports: Array[RegExMatch]
	for path in _update_dependency_paths:
		# Open the file and check for any "import" lines
		file = FileAccess.open(path, FileAccess.READ)
		found_imports = import_regex.search_all(file.get_as_text())
		var dependencies: PackedStringArray = []
		for found in found_imports:
			dependencies.append(found.strings[found.names.path])
		_cache[path].dependencies = dependencies
	_update_dependency_paths.clear()


#endregion
</file>

<file path="addons/dialogue_manager/views/main_view.gd">
@tool
extends Control


const OPEN_OPEN = 100
const OPEN_QUICK = 101
const OPEN_CLEAR = 102

const TRANSLATIONS_GENERATE_LINE_IDS = 100
const TRANSLATIONS_SAVE_CHARACTERS_TO_CSV = 201
const TRANSLATIONS_SAVE_TO_CSV = 202
const TRANSLATIONS_IMPORT_FROM_CSV = 203

const ITEM_SAVE = 100
const ITEM_SAVE_AS = 101
const ITEM_CLOSE = 102
const ITEM_CLOSE_ALL = 103
const ITEM_CLOSE_OTHERS = 104
const ITEM_COPY_PATH = 200
const ITEM_SHOW_IN_FILESYSTEM = 201

enum TranslationSource {
	CharacterNames,
	Lines
}


signal confirmation_closed()


@onready var parse_timer: Timer = $ParseTimer

# Dialogs
@onready var new_dialog: FileDialog = $NewDialog
@onready var save_dialog: FileDialog = $SaveDialog
@onready var open_dialog: FileDialog = $OpenDialog
@onready var quick_open_dialog: ConfirmationDialog = $QuickOpenDialog
@onready var quick_open_files_list: VBoxContainer = $QuickOpenDialog/QuickOpenFilesList
@onready var export_dialog: FileDialog = $ExportDialog
@onready var import_dialog: FileDialog = $ImportDialog
@onready var errors_dialog: AcceptDialog = $ErrorsDialog
@onready var build_error_dialog: AcceptDialog = $BuildErrorDialog
@onready var close_confirmation_dialog: ConfirmationDialog = $CloseConfirmationDialog
@onready var updated_dialog: AcceptDialog = $UpdatedDialog
@onready var find_in_files_dialog: AcceptDialog = $FindInFilesDialog
@onready var find_in_files: Control = $FindInFilesDialog/FindInFiles

# Toolbar
@onready var new_button: Button = %NewButton
@onready var open_button: MenuButton = %OpenButton
@onready var save_all_button: Button = %SaveAllButton
@onready var find_in_files_button: Button = %FindInFilesButton
@onready var test_button: Button = %TestButton
@onready var test_line_button: Button = %TestLineButton
@onready var search_button: Button = %SearchButton
@onready var insert_button: MenuButton = %InsertButton
@onready var translations_button: MenuButton = %TranslationsButton
@onready var support_button: Button = %SupportButton
@onready var docs_button: Button = %DocsButton
@onready var version_label: Label = %VersionLabel
@onready var update_button: Button = %UpdateButton

@onready var search_and_replace := %SearchAndReplace

# Code editor
@onready var content: HSplitContainer = %Content
@onready var files_list := %FilesList
@onready var files_popup_menu: PopupMenu = %FilesPopupMenu
@onready var title_list := %TitleList
@onready var code_edit: DMCodeEdit = %CodeEdit
@onready var errors_panel := %ErrorsPanel

# The currently open file
var current_file_path: String = "":
	set(next_current_file_path):
		current_file_path = next_current_file_path
		files_list.current_file_path = current_file_path
		if current_file_path == "" or not open_buffers.has(current_file_path):
			save_all_button.disabled = true
			test_button.disabled = true
			test_line_button.disabled = true
			search_button.disabled = true
			insert_button.disabled = true
			translations_button.disabled = true
			content.dragger_visibility = SplitContainer.DRAGGER_HIDDEN
			files_list.hide()
			title_list.hide()
			code_edit.hide()
			errors_panel.hide()
		else:
			test_button.disabled = false
			test_line_button.disabled = false
			search_button.disabled = false
			insert_button.disabled = false
			translations_button.disabled = false
			content.dragger_visibility = SplitContainer.DRAGGER_VISIBLE
			files_list.show()
			title_list.show()
			code_edit.show()

			var cursor: Vector2 = DMSettings.get_caret(current_file_path)
			var scroll_vertical: int = DMSettings.get_scroll(current_file_path)

			code_edit.text = open_buffers[current_file_path].text
			code_edit.errors = []
			code_edit.clear_undo_history()
			code_edit.set_cursor(cursor)
			code_edit.scroll_vertical = scroll_vertical
			code_edit.grab_focus()

			_on_code_edit_text_changed()

			errors_panel.errors = []
			code_edit.errors = []

			if search_and_replace.visible:
				search_and_replace.search()
	get:
		return current_file_path

# A reference to the currently open files and their last saved text
var open_buffers: Dictionary = {}

# Which thing are we exporting translations for?
var translation_source: TranslationSource = TranslationSource.Lines

var plugin: EditorPlugin


func _ready() -> void:
	plugin = Engine.get_meta("DialogueManagerPlugin")

	apply_theme()

	# Start with nothing open
	self.current_file_path = ""

	# Set up the update checker
	version_label.text = "v%s" % plugin.get_version()
	update_button.on_before_refresh = func on_before_refresh():
		# Save everything
		DMSettings.set_user_value("just_refreshed", {
			current_file_path = current_file_path,
			open_buffers = open_buffers
		})
		return true

	# Did we just load from an addon version refresh?
	var just_refreshed = DMSettings.get_user_value("just_refreshed", null)
	if just_refreshed != null:
		DMSettings.set_user_value("just_refreshed", null)
		call_deferred("load_from_version_refresh", just_refreshed)

	# Hook up the search toolbar
	search_and_replace.code_edit = code_edit

	# Connect menu buttons
	insert_button.get_popup().id_pressed.connect(_on_insert_button_menu_id_pressed)
	translations_button.get_popup().id_pressed.connect(_on_translations_button_menu_id_pressed)

	code_edit.main_view = self
	code_edit.wrap_mode = TextEdit.LINE_WRAPPING_BOUNDARY if DMSettings.get_setting(DMSettings.WRAP_LONG_LINES, false) else TextEdit.LINE_WRAPPING_NONE
	var editor_settings: EditorSettings = EditorInterface.get_editor_settings()
	editor_settings.settings_changed.connect(_on_editor_settings_changed)
	_on_editor_settings_changed()

	# Reopen any files that were open when Godot was closed
	if editor_settings.get_setting("text_editor/behavior/files/restore_scripts_on_load"):
		var reopen_files: Array = DMSettings.get_user_value("reopen_files", [])
		for reopen_file in reopen_files:
			open_file(reopen_file)

		self.current_file_path = DMSettings.get_user_value("most_recent_reopen_file", "")

	save_all_button.disabled = true

	close_confirmation_dialog.ok_button_text = DMConstants.translate(&"confirm_close.save")
	close_confirmation_dialog.add_button(DMConstants.translate(&"confirm_close.discard"), true, "discard")

	errors_dialog.dialog_text = DMConstants.translate(&"errors_in_script")

	# Update the buffer if a file was modified externally (retains undo step)
	Engine.get_meta("DMCache").file_content_changed.connect(_on_cache_file_content_changed)

	EditorInterface.get_file_system_dock().files_moved.connect(_on_files_moved)

	code_edit.get_v_scroll_bar().value_changed.connect(_on_code_edit_scroll_changed)


func _exit_tree() -> void:
	DMSettings.set_user_value("reopen_files", open_buffers.keys())
	DMSettings.set_user_value("most_recent_reopen_file", self.current_file_path)


func _unhandled_input(event: InputEvent) -> void:
	if not visible: return

	if event is InputEventKey and event.is_pressed():
		var shortcut: String = plugin.get_editor_shortcut(event)
		match shortcut:
			"close_file":
				get_viewport().set_input_as_handled()
				close_file(current_file_path)
			"save":
				get_viewport().set_input_as_handled()
				save_file(current_file_path)
			"find_in_files":
				get_viewport().set_input_as_handled()
				_on_find_in_files_button_pressed()
			"run_test_scene":
				get_viewport().set_input_as_handled()
				_on_test_button_pressed()


func apply_changes() -> void:
	save_files()


# Load back to the previous buffer regardless of if it was actually saved
func load_from_version_refresh(just_refreshed: Dictionary) -> void:
	if just_refreshed.has("current_file_content"):
		# We just loaded from a version before multiple buffers
		var file: FileAccess = FileAccess.open(just_refreshed.current_file_path, FileAccess.READ)
		var file_text: String = file.get_as_text()
		open_buffers[just_refreshed.current_file_path] = {
			pristine_text = file_text,
			text = just_refreshed.current_file_content
		}
	else:
		open_buffers = just_refreshed.open_buffers

	if just_refreshed.current_file_path != "":
		EditorInterface.edit_resource(load(just_refreshed.current_file_path))
	else:
		EditorInterface.set_main_screen_editor("Dialogue")

	updated_dialog.dialog_text = DMConstants.translate(&"update.success").format({ version = update_button.get_version() })
	updated_dialog.popup_centered()


func new_file(path: String, content: String = "") -> void:
	if open_buffers.has(path):
		remove_file_from_open_buffers(path)

	var file: FileAccess = FileAccess.open(path, FileAccess.WRITE)
	if content == "":
		file.store_string(DMSettings.get_setting(DMSettings.NEW_FILE_TEMPLATE, ""))
	else:
		file.store_string(content)

	EditorInterface.get_resource_filesystem().scan()


# Open a dialogue resource for editing
func open_resource(resource: DialogueResource) -> void:
	open_file(resource.resource_path)


func open_file(path: String) -> void:
	if not FileAccess.file_exists(path): return

	if not open_buffers.has(path):
		var file: FileAccess = FileAccess.open(path, FileAccess.READ)
		var text = file.get_as_text()

		open_buffers[path] = {
			cursor = Vector2.ZERO,
			text = text,
			pristine_text = text
		}

	DMSettings.add_recent_file(path)
	build_open_menu()

	files_list.files = open_buffers.keys()
	files_list.select_file(path)

	self.current_file_path = path


func show_file_in_filesystem(path: String) -> void:
	EditorInterface.get_file_system_dock().navigate_to_path(path)


# Save any open files
func save_files() -> void:
	save_all_button.disabled = true

	var saved_files: PackedStringArray = []
	for path in open_buffers:
		if open_buffers[path].text != open_buffers[path].pristine_text:
			saved_files.append(path)
		save_file(path, false)

	if saved_files.size() > 0:
		Engine.get_meta("DMCache").mark_files_for_reimport(saved_files)


# Save a file
func save_file(path: String, rescan_file_system: bool = true) -> void:
	var buffer = open_buffers[path]

	files_list.mark_file_as_unsaved(path, false)
	save_all_button.disabled = files_list.unsaved_files.size() == 0

	# Don't bother saving if there is nothing to save
	if buffer.text == buffer.pristine_text:
		return

	buffer.pristine_text = buffer.text

	# Save the current text
	var file: FileAccess = FileAccess.open(path, FileAccess.WRITE)
	file.store_string(buffer.text)
	file.close()

	if rescan_file_system:
		EditorInterface.get_resource_filesystem().scan()


func close_file(path: String) -> void:
	if not path in open_buffers.keys(): return

	var buffer = open_buffers[path]

	if buffer.text == buffer.pristine_text:
		remove_file_from_open_buffers(path)
		await get_tree().process_frame
	else:
		close_confirmation_dialog.dialog_text = DMConstants.translate(&"confirm_close").format({ path = path.get_file() })
		close_confirmation_dialog.popup_centered()
		await confirmation_closed


func remove_file_from_open_buffers(path: String) -> void:
	if not path in open_buffers.keys(): return

	var current_index = open_buffers.keys().find(current_file_path)

	open_buffers.erase(path)
	if open_buffers.size() == 0:
		self.current_file_path = ""
	else:
		current_index = clamp(current_index, 0, open_buffers.size() - 1)
		self.current_file_path = open_buffers.keys()[current_index]

	files_list.files = open_buffers.keys()


# Apply theme colors and icons to the UI
func apply_theme() -> void:
	if is_instance_valid(plugin) and is_instance_valid(code_edit):
		var scale: float = EditorInterface.get_editor_scale()
		var editor_settings = EditorInterface.get_editor_settings()
		code_edit.theme_overrides = {
			scale = scale,

			background_color = editor_settings.get_setting("text_editor/theme/highlighting/background_color"),
			current_line_color = editor_settings.get_setting("text_editor/theme/highlighting/current_line_color"),
			error_line_color = editor_settings.get_setting("text_editor/theme/highlighting/mark_color"),

			critical_color = editor_settings.get_setting("text_editor/theme/highlighting/comment_markers/critical_color"),
			notice_color = editor_settings.get_setting("text_editor/theme/highlighting/comment_markers/notice_color"),

			titles_color = editor_settings.get_setting("text_editor/theme/highlighting/control_flow_keyword_color"),
			text_color = editor_settings.get_setting("text_editor/theme/highlighting/text_color"),
			conditions_color = editor_settings.get_setting("text_editor/theme/highlighting/keyword_color"),
			mutations_color = editor_settings.get_setting("text_editor/theme/highlighting/function_color"),
			members_color = editor_settings.get_setting("text_editor/theme/highlighting/member_variable_color"),
			strings_color = editor_settings.get_setting("text_editor/theme/highlighting/string_color"),
			numbers_color = editor_settings.get_setting("text_editor/theme/highlighting/number_color"),
			symbols_color = editor_settings.get_setting("text_editor/theme/highlighting/symbol_color"),
			comments_color = editor_settings.get_setting("text_editor/theme/highlighting/comment_color"),
			jumps_color = Color(editor_settings.get_setting("text_editor/theme/highlighting/control_flow_keyword_color"), 0.7),

			font_size = editor_settings.get_setting("interface/editor/code_font_size")
		}

		new_button.icon = get_theme_icon("New", "EditorIcons")
		new_button.tooltip_text = DMConstants.translate(&"start_a_new_file")

		open_button.icon = get_theme_icon("Load", "EditorIcons")
		open_button.tooltip_text = DMConstants.translate(&"open_a_file")

		save_all_button.icon = get_theme_icon("Save", "EditorIcons")
		save_all_button.text = DMConstants.translate(&"all")
		save_all_button.tooltip_text = DMConstants.translate(&"start_all_files")

		find_in_files_button.icon = get_theme_icon("ViewportZoom", "EditorIcons")
		find_in_files_button.tooltip_text = DMConstants.translate(&"find_in_files")

		test_button.icon = get_theme_icon("DebugNext", "EditorIcons")
		test_button.tooltip_text = DMConstants.translate(&"test_dialogue")

		test_line_button.icon = get_theme_icon("DebugStep", "EditorIcons")
		test_line_button.tooltip_text = DMConstants.translate(&"test_dialogue_from_line")

		search_button.icon = get_theme_icon("Search", "EditorIcons")
		search_button.tooltip_text = DMConstants.translate(&"search_for_text")

		insert_button.icon = get_theme_icon("RichTextEffect", "EditorIcons")
		insert_button.text = DMConstants.translate(&"insert")

		translations_button.icon = get_theme_icon("Translation", "EditorIcons")
		translations_button.text = DMConstants.translate(&"translations")

		support_button.icon = get_theme_icon("Heart", "EditorIcons")
		support_button.text = DMConstants.translate(&"sponsor")
		support_button.tooltip_text = DMConstants.translate(&"show_support")

		docs_button.icon = get_theme_icon("Help", "EditorIcons")
		docs_button.text = DMConstants.translate(&"docs")

		update_button.apply_theme()

		# Set up the effect menu
		var popup: PopupMenu = insert_button.get_popup()
		popup.clear()
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.wave_bbcode"), 0)
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.shake_bbcode"), 1)
		popup.add_separator()
		popup.add_icon_item(get_theme_icon("Time", "EditorIcons"), DMConstants.translate(&"insert.typing_pause"), 3)
		popup.add_icon_item(get_theme_icon("ViewportSpeed", "EditorIcons"), DMConstants.translate(&"insert.typing_speed_change"), 4)
		popup.add_icon_item(get_theme_icon("DebugNext", "EditorIcons"), DMConstants.translate(&"insert.auto_advance"), 5)
		popup.add_separator(DMConstants.translate(&"insert.templates"))
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.title"), 6)
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.dialogue"), 7)
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.response"), 8)
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.random_lines"), 9)
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.random_text"), 10)
		popup.add_separator(DMConstants.translate(&"insert.actions"))
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.jump"), 11)
		popup.add_icon_item(get_theme_icon("RichTextEffect", "EditorIcons"), DMConstants.translate(&"insert.end_dialogue"), 12)

		# Set up the translations menu
		popup = translations_button.get_popup()
		popup.clear()
		popup.add_icon_item(get_theme_icon("Translation", "EditorIcons"), DMConstants.translate(&"generate_line_ids"), TRANSLATIONS_GENERATE_LINE_IDS)
		popup.add_separator()
		popup.add_icon_item(get_theme_icon("FileList", "EditorIcons"), DMConstants.translate(&"save_characters_to_csv"), TRANSLATIONS_SAVE_CHARACTERS_TO_CSV)
		popup.add_icon_item(get_theme_icon("FileList", "EditorIcons"), DMConstants.translate(&"save_to_csv"), TRANSLATIONS_SAVE_TO_CSV)
		popup.add_icon_item(get_theme_icon("AssetLib", "EditorIcons"), DMConstants.translate(&"import_from_csv"), TRANSLATIONS_IMPORT_FROM_CSV)

		# Dialog sizes
		new_dialog.min_size = Vector2(600, 500) * scale
		save_dialog.min_size = Vector2(600, 500) * scale
		open_dialog.min_size = Vector2(600, 500) * scale
		quick_open_dialog.min_size = Vector2(400, 600) * scale
		export_dialog.min_size = Vector2(600, 500) * scale
		import_dialog.min_size = Vector2(600, 500) * scale
		find_in_files_dialog.min_size = Vector2(800, 600) * scale


### Helpers


# Refresh the open menu with the latest files
func build_open_menu() -> void:
	var menu = open_button.get_popup()
	menu.clear()
	menu.add_icon_item(get_theme_icon("Load", "EditorIcons"), DMConstants.translate(&"open.open"), OPEN_OPEN)
	menu.add_icon_item(get_theme_icon("Load", "EditorIcons"), DMConstants.translate(&"open.quick_open"), OPEN_QUICK)
	menu.add_separator()

	var recent_files = DMSettings.get_recent_files()
	if recent_files.size() == 0:
		menu.add_item(DMConstants.translate(&"open.no_recent_files"))
		menu.set_item_disabled(2, true)
	else:
		for path in recent_files:
			if FileAccess.file_exists(path):
				menu.add_icon_item(get_theme_icon("File", "EditorIcons"), path)

	menu.add_separator()
	menu.add_item(DMConstants.translate(&"open.clear_recent_files"), OPEN_CLEAR)
	if menu.id_pressed.is_connected(_on_open_menu_id_pressed):
		menu.id_pressed.disconnect(_on_open_menu_id_pressed)
	menu.id_pressed.connect(_on_open_menu_id_pressed)


# Get the last place a CSV, etc was exported
func get_last_export_path(extension: String) -> String:
	var filename = current_file_path.get_file().replace(".dialogue", "." + extension)
	return DMSettings.get_user_value("last_export_path", current_file_path.get_base_dir()) + "/" + filename


# Check the current text for errors
func compile() -> void:
	# Skip if nothing to parse
	if current_file_path == "": return

	var result: DMCompilerResult = DMCompiler.compile_string(code_edit.text, current_file_path)
	code_edit.errors = result.errors
	errors_panel.errors = result.errors
	title_list.titles = code_edit.get_titles()


func show_build_error_dialog() -> void:
	build_error_dialog.dialog_text = DMConstants.translate(&"errors_with_build")
	build_error_dialog.popup_centered()


# Generate translation line IDs for any line that doesn't already have one
func generate_translations_keys() -> void:
	randomize()
	seed(Time.get_unix_time_from_system())

	var cursor: Vector2 = code_edit.get_cursor()
	var lines: PackedStringArray = code_edit.text.split("\n")

	var key_regex = RegEx.new()
	key_regex.compile("\\[ID:(?<key>.*?)\\]")

	var compiled_lines: Dictionary = DMCompiler.compile_string(code_edit.text, "").lines

	# Make list of known keys
	var known_keys = {}
	for i in range(0, lines.size()):
		var line = lines[i]
		var found = key_regex.search(line)
		if found:
			var text = ""
			var l = line.replace(found.strings[0], "").strip_edges().strip_edges()
			if l.begins_with("- "):
				text = DMCompiler.extract_translatable_string(l)
			elif ":" in l:
				text = l.split(":")[1]
			else:
				text = l
			known_keys[found.strings[found.names.get("key")]] = text

	# Add in any that are missing
	for i in lines.size():
		var line = lines[i]
		var l = line.strip_edges()

		if not [DMConstants.TYPE_DIALOGUE, DMConstants.TYPE_RESPONSE].has(DMCompiler.get_line_type(l)): continue
		if not compiled_lines.has(str(i)): continue

		if "[ID:" in line: continue

		var text = ""
		if l.begins_with("- "):
			text = DMCompiler.extract_translatable_string(l)
		else:
			text = l.substr(l.find(":") + 1)

		var key: String = ""
		if known_keys.values().has(text):
			key = known_keys.find_key(text)
		else:
			var regex: DMCompilerRegEx = DMCompilerRegEx.new()
			key = regex.ALPHA_NUMERIC.sub(text.strip_edges(), "_", true).substr(0, 30)
			if key.begins_with("_"):
				key = key.substr(1)
			if key.ends_with("_"):
				key = key.substr(0, key.length() - 1)

			# Make sure key is unique
			var hashed_key: String = key + "_" + str(randi() % 1000000).sha1_text().substr(0, 6)
			while hashed_key in known_keys and text != known_keys.get(hashed_key):
				hashed_key = key + "_" + str(randi() % 1000000).sha1_text().substr(0, 6)
			key = hashed_key.to_upper()

		line = line.replace("\\n", "!NEWLINE!")
		text = text.replace("\n", "!NEWLINE!")
		lines[i] = line.replace(text, text + " [ID:%s]" % [key]).replace("!NEWLINE!", "\\n")

		known_keys[key] = text

	code_edit.text = "\n".join(lines)
	code_edit.set_cursor(cursor)
	_on_code_edit_text_changed()


# Add a translation file to the project settings
func add_path_to_project_translations(path: String) -> void:
	var translations: PackedStringArray = ProjectSettings.get_setting("internationalization/locale/translations")
	if not path in translations:
		translations.append(path)
		ProjectSettings.save()


# Export dialogue and responses to CSV
func export_translations_to_csv(path: String) -> void:
	var default_locale: String = DMSettings.get_setting(DMSettings.DEFAULT_CSV_LOCALE, "en")

	var file: FileAccess

	# If the file exists, open it first and work out which keys are already in it
	var existing_csv: Dictionary = {}
	var column_count: int = 2
	var default_locale_column: int = 1
	var character_column: int = -1
	var notes_column: int = -1
	if FileAccess.file_exists(path):
		file = FileAccess.open(path, FileAccess.READ)
		var is_first_line = true
		var line: Array
		while !file.eof_reached():
			line = file.get_csv_line()
			if is_first_line:
				is_first_line = false
				column_count = line.size()
				for i in range(1, line.size()):
					if line[i] == default_locale:
						default_locale_column = i
					elif line[i] == "_character":
						character_column = i
					elif line[i] == "_notes":
						notes_column = i

			# Make sure the line isn't empty before adding it
			if line.size() > 0 and line[0].strip_edges() != "":
				existing_csv[line[0]] = line

		# The character column wasn't found in the existing file but the setting is turned on
		if character_column == -1 and DMSettings.get_setting(DMSettings.INCLUDE_CHARACTER_IN_TRANSLATION_EXPORTS, false):
			character_column = column_count
			column_count += 1
			existing_csv["keys"].append("_character")

		# The notes column wasn't found in the existing file but the setting is turned on
		if notes_column == -1 and DMSettings.get_setting(DMSettings.INCLUDE_NOTES_IN_TRANSLATION_EXPORTS, false):
			notes_column = column_count
			column_count += 1
			existing_csv["keys"].append("_notes")

	# Start a new file
	file = FileAccess.open(path, FileAccess.WRITE)

	if not FileAccess.file_exists(path):
		var headings: PackedStringArray = ["keys", default_locale] + DMSettings.get_setting(DMSettings.EXTRA_CSV_LOCALES, [])
		if DMSettings.get_setting(DMSettings.INCLUDE_CHARACTER_IN_TRANSLATION_EXPORTS, false):
			character_column = headings.size()
			headings.append("_character")
		if DMSettings.get_setting(DMSettings.INCLUDE_NOTES_IN_TRANSLATION_EXPORTS, false):
			notes_column = headings.size()
			headings.append("_notes")
		file.store_csv_line(headings)
		column_count = headings.size()

	# Write our translations to file
	var known_keys: PackedStringArray = []

	var dialogue = DMCompiler.compile_string(code_edit.text, current_file_path).lines

	# Make a list of stuff that needs to go into the file
	var lines_to_save = []
	for key in dialogue.keys():
		var line: Dictionary = dialogue.get(key)

		if not line.type in [DMConstants.TYPE_DIALOGUE, DMConstants.TYPE_RESPONSE]: continue

		var translation_key: String = line.get(&"translation_key", line.text)

		if translation_key in known_keys: continue

		known_keys.append(translation_key)

		var line_to_save: PackedStringArray = []
		if existing_csv.has(translation_key):
			line_to_save = existing_csv.get(translation_key)
			line_to_save.resize(column_count)
			existing_csv.erase(translation_key)
		else:
			line_to_save.resize(column_count)
			line_to_save[0] = translation_key

		line_to_save[default_locale_column] = line.text
		if character_column > -1:
			line_to_save[character_column] = "(response)" if line.type == DMConstants.TYPE_RESPONSE else line.character
		if notes_column > -1:
			line_to_save[notes_column] = line.notes

		lines_to_save.append(line_to_save)

	# Store lines in the file, starting with anything that already exists that hasn't been touched
	for line in existing_csv.values():
		file.store_csv_line(line)
	for line in lines_to_save:
		file.store_csv_line(line)

	file.close()

	EditorInterface.get_resource_filesystem().scan()
	EditorInterface.get_file_system_dock().call_deferred("navigate_to_path", path)

	# Add it to the project l10n settings if it's not already there
	var language_code: RegExMatch = RegEx.create_from_string("^[a-z]{2,3}").search(default_locale)
	var translation_path: String = path.replace(".csv", ".%s.translation" % language_code.get_string())
	call_deferred("add_path_to_project_translations", translation_path)


func export_character_names_to_csv(path: String) -> void:
	var file: FileAccess

	# If the file exists, open it first and work out which keys are already in it
	var existing_csv = {}
	var commas = []
	if FileAccess.file_exists(path):
		file = FileAccess.open(path, FileAccess.READ)
		var is_first_line = true
		var line: Array
		while !file.eof_reached():
			line = file.get_csv_line()
			if is_first_line:
				is_first_line = false
				for i in range(2, line.size()):
					commas.append("")
			# Make sure the line isn't empty before adding it
			if line.size() > 0 and line[0].strip_edges() != "":
				existing_csv[line[0]] = line

	# Start a new file
	file = FileAccess.open(path, FileAccess.WRITE)

	if not file.file_exists(path):
		file.store_csv_line(["keys", DMSettings.get_setting(DMSettings.DEFAULT_CSV_LOCALE, "en")])

	# Write our translations to file
	var known_keys: PackedStringArray = []

	var character_names: PackedStringArray = DMCompiler.compile_string(code_edit.text, current_file_path).character_names

	# Make a list of stuff that needs to go into the file
	var lines_to_save = []
	for character_name in character_names:
		if character_name in known_keys: continue

		known_keys.append(character_name)

		if existing_csv.has(character_name):
			var existing_line = existing_csv.get(character_name)
			existing_line[1] = character_name
			lines_to_save.append(existing_line)
			existing_csv.erase(character_name)
		else:
			lines_to_save.append(PackedStringArray([character_name, character_name] + commas))

	# Store lines in the file, starting with anything that already exists that hasn't been touched
	for line in existing_csv.values():
		file.store_csv_line(line)
	for line in lines_to_save:
		file.store_csv_line(line)

	file.close()

	EditorInterface.get_resource_filesystem().scan()
	EditorInterface.get_file_system_dock().call_deferred("navigate_to_path", path)

	# Add it to the project l10n settings if it's not already there
	var translation_path: String = path.replace(".csv", ".en.translation")
	call_deferred("add_path_to_project_translations", translation_path)


# Import changes back from an exported CSV by matching translation keys
func import_translations_from_csv(path: String) -> void:
	var cursor: Vector2 = code_edit.get_cursor()

	if not FileAccess.file_exists(path): return

	# Open the CSV file and build a dictionary of the known keys
	var keys: Dictionary = {}
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	var csv_line: Array
	while !file.eof_reached():
		csv_line = file.get_csv_line()
		if csv_line.size() > 1:
			keys[csv_line[0]] = csv_line[1]

	# Now look over each line in the dialogue and replace the content for matched keys
	var lines: PackedStringArray = code_edit.text.split("\n")
	var start_index: int = 0
	var end_index: int = 0
	for i in range(0, lines.size()):
		var line: String = lines[i]
		var translation_key: String = DMCompiler.get_static_line_id(line)
		if keys.has(translation_key):
			if DMCompiler.get_line_type(line) == DMConstants.TYPE_DIALOGUE:
				start_index = 0
				# See if we need to skip over a character name
				line = line.replace("\\:", "!ESCAPED_COLON!")
				if ": " in line:
					start_index = line.find(": ") + 2
				lines[i] = (line.substr(0, start_index) + keys.get(translation_key) + " [ID:" + translation_key + "]").replace("!ESCAPED_COLON!", ":")

			elif DMCompiler.get_line_type(line) == DMConstants.TYPE_RESPONSE:
				start_index = line.find("- ") + 2
				# See if we need to skip over a character name
				line = line.replace("\\:", "!ESCAPED_COLON!")
				if ": " in line:
					start_index = line.find(": ") + 2
				end_index = line.length()
				if " =>" in line:
					end_index = line.find(" =>")
				if " [if " in line:
					end_index = line.find(" [if ")
				lines[i] = (line.substr(0, start_index) + keys.get(translation_key) + " [ID:" + translation_key + "]" + line.substr(end_index)).replace("!ESCAPED_COLON!", ":")

	code_edit.text = "\n".join(lines)
	code_edit.set_cursor(cursor)


func show_search_form(is_enabled: bool) -> void:
	if code_edit.last_selected_text:
		search_and_replace.input.text = code_edit.last_selected_text

	search_and_replace.visible = is_enabled
	search_button.set_pressed_no_signal(is_enabled)
	search_and_replace.focus_line_edit()


func run_test_scene(from_key: String) -> void:
	DMSettings.set_user_value("run_title", from_key)
	DMSettings.set_user_value("is_running_test_scene", true)
	DMSettings.set_user_value("run_resource_path", current_file_path)
	var test_scene_path: String = DMSettings.get_setting(DMSettings.CUSTOM_TEST_SCENE_PATH, "res://addons/dialogue_manager/test_scene.tscn")
	if ResourceUID.has_id(ResourceUID.text_to_id(test_scene_path)):
		test_scene_path = ResourceUID.get_id_path(ResourceUID.text_to_id(test_scene_path))
	EditorInterface.play_custom_scene(test_scene_path)


### Signals


func _on_files_moved(old_file: String, new_file: String) -> void:
	if open_buffers.has(old_file):
		open_buffers[new_file] = open_buffers[old_file]
		open_buffers.erase(old_file)
		open_buffers[new_file]


func _on_cache_file_content_changed(path: String, new_content: String) -> void:
	if open_buffers.has(path):
		var buffer = open_buffers[path]
		if buffer.text == buffer.pristine_text and buffer.text != new_content:
			buffer.text = new_content
			code_edit.text = new_content
			title_list.titles = code_edit.get_titles()
		buffer.pristine_text = new_content


func _on_editor_settings_changed() -> void:
	var editor_settings: EditorSettings = EditorInterface.get_editor_settings()
	code_edit.minimap_draw = editor_settings.get_setting("text_editor/appearance/minimap/show_minimap")
	code_edit.minimap_width = editor_settings.get_setting("text_editor/appearance/minimap/minimap_width")
	code_edit.scroll_smooth = editor_settings.get_setting("text_editor/behavior/navigation/smooth_scrolling")


func _on_open_menu_id_pressed(id: int) -> void:
	match id:
		OPEN_OPEN:
			open_dialog.popup_centered()
		OPEN_QUICK:
			quick_open_files_list.files = Engine.get_meta("DMCache").get_files()
			quick_open_dialog.popup_centered()
			quick_open_files_list.focus_filter()
		OPEN_CLEAR:
			DMSettings.clear_recent_files()
			build_open_menu()
		_:
			var menu = open_button.get_popup()
			var item = menu.get_item_text(menu.get_item_index(id))
			open_file(item)


func _on_files_list_file_selected(file_path: String) -> void:
	self.current_file_path = file_path


func _on_insert_button_menu_id_pressed(id: int) -> void:
	match id:
		0:
			code_edit.insert_bbcode("[wave amp=25 freq=5]", "[/wave]")
		1:
			code_edit.insert_bbcode("[shake rate=20 level=10]", "[/shake]")
		3:
			code_edit.insert_bbcode("[wait=1]")
		4:
			code_edit.insert_bbcode("[speed=0.2]")
		5:
			code_edit.insert_bbcode("[next=auto]")
		6:
			code_edit.insert_text_at_cursor("~ title")
		7:
			code_edit.insert_text_at_cursor("Nathan: This is Some Dialogue")
		8:
			code_edit.insert_text_at_cursor("Nathan: Choose a Response...\n- Option 1\n\tNathan: You chose option 1\n- Option 2\n\tNathan: You chose option 2")
		9:
			code_edit.insert_text_at_cursor("% Nathan: This is random line 1.\n% Nathan: This is random line 2.\n%1 Nathan: This is weighted random line 3.")
		10:
			code_edit.insert_text_at_cursor("Nathan: [[Hi|Hello|Howdy]]")
		11:
			code_edit.insert_text_at_cursor("=> title")
		12:
			code_edit.insert_text_at_cursor("=> END")


func _on_translations_button_menu_id_pressed(id: int) -> void:
	match id:
		TRANSLATIONS_GENERATE_LINE_IDS:
			generate_translations_keys()

		TRANSLATIONS_SAVE_CHARACTERS_TO_CSV:
			translation_source = TranslationSource.CharacterNames
			export_dialog.filters = PackedStringArray(["*.csv ; Translation CSV"])
			export_dialog.current_path = get_last_export_path("csv")
			export_dialog.popup_centered()

		TRANSLATIONS_SAVE_TO_CSV:
			translation_source = TranslationSource.Lines
			export_dialog.filters = PackedStringArray(["*.csv ; Translation CSV"])
			export_dialog.current_path = get_last_export_path("csv")
			export_dialog.popup_centered()

		TRANSLATIONS_IMPORT_FROM_CSV:
			import_dialog.current_path = get_last_export_path("csv")
			import_dialog.popup_centered()


func _on_export_dialog_file_selected(path: String) -> void:
	DMSettings.set_user_value("last_export_path", path.get_base_dir())
	match path.get_extension():
		"csv":
			match translation_source:
				TranslationSource.CharacterNames:
					export_character_names_to_csv(path)
				TranslationSource.Lines:
					export_translations_to_csv(path)


func _on_import_dialog_file_selected(path: String) -> void:
	DMSettings.set_user_value("last_export_path", path.get_base_dir())
	import_translations_from_csv(path)


func _on_main_view_theme_changed():
	apply_theme()


func _on_main_view_visibility_changed() -> void:
	if visible and is_instance_valid(code_edit):
		code_edit.grab_focus()


func _on_new_button_pressed() -> void:
	new_dialog.current_file = "dialogue"
	new_dialog.popup_centered()


func _on_new_dialog_confirmed() -> void:
	if new_dialog.current_file.get_basename() == "":
		var path = "res://untitled.dialogue"
		new_file(path)
		open_file(path)


func _on_new_dialog_file_selected(path: String) -> void:
	new_file(path)
	open_file(path)


func _on_save_dialog_file_selected(path: String) -> void:
	if path == "": path = "res://untitled.dialogue"

	new_file(path, code_edit.text)
	open_file(path)


func _on_open_button_about_to_popup() -> void:
	build_open_menu()


func _on_open_dialog_file_selected(path: String) -> void:
	open_file(path)


func _on_quick_open_files_list_file_double_clicked(file_path: String) -> void:
	quick_open_dialog.hide()
	open_file(file_path)


func _on_quick_open_dialog_confirmed() -> void:
	if quick_open_files_list.current_file_path:
		open_file(quick_open_files_list.current_file_path)


func _on_save_all_button_pressed() -> void:
	save_files()


func _on_find_in_files_button_pressed() -> void:
	find_in_files_dialog.popup_centered()
	find_in_files.prepare()


func _on_code_edit_text_changed() -> void:
	var buffer = open_buffers[current_file_path]
	buffer.text = code_edit.text

	files_list.mark_file_as_unsaved(current_file_path, buffer.text != buffer.pristine_text)
	save_all_button.disabled = open_buffers.values().filter(func(d): return d.text != d.pristine_text).size() == 0

	parse_timer.start(1)


func _on_code_edit_scroll_changed(value: int) -> void:
	DMSettings.set_scroll(current_file_path, code_edit.scroll_vertical)


func _on_code_edit_active_title_change(title: String) -> void:
	title_list.select_title(title)


func _on_code_edit_caret_changed() -> void:
	DMSettings.set_caret(current_file_path, code_edit.get_cursor())


func _on_code_edit_error_clicked(line_number: int) -> void:
	errors_panel.show_error_for_line_number(line_number)


func _on_title_list_title_selected(title: String) -> void:
	code_edit.go_to_title(title)
	code_edit.grab_focus()


func _on_parse_timer_timeout() -> void:
	parse_timer.stop()
	compile()


func _on_errors_panel_error_pressed(line_number: int, column_number: int) -> void:
	code_edit.set_caret_line(line_number - 1)
	code_edit.set_caret_column(column_number)
	code_edit.grab_focus()


func _on_search_button_toggled(button_pressed: bool) -> void:
	show_search_form(button_pressed)


func _on_search_and_replace_open_requested() -> void:
	show_search_form(true)


func _on_search_and_replace_close_requested() -> void:
	search_button.set_pressed_no_signal(false)
	search_and_replace.visible = false
	code_edit.grab_focus()


func _on_test_button_pressed() -> void:
	save_file(current_file_path, false)
	Engine.get_meta("DMCache").reimport_files([current_file_path])

	if errors_panel.errors.size() > 0:
		errors_dialog.popup_centered()
		return

	run_test_scene("")


func _on_test_line_button_pressed() -> void:
	save_file(current_file_path)

	if errors_panel.errors.size() > 0:
		errors_dialog.popup_centered()
		return

	# Find next non-empty line
	var line_to_run: int = 0
	for i in range(code_edit.get_cursor().y, code_edit.get_line_count()):
		if not code_edit.get_line(i).is_empty():
			line_to_run = i
			break

	run_test_scene(str(line_to_run))


func _on_support_button_pressed() -> void:
	OS.shell_open("https://patreon.com/nathanhoad")


func _on_docs_button_pressed() -> void:
	OS.shell_open("https://github.com/nathanhoad/godot_dialogue_manager")


func _on_files_list_file_popup_menu_requested(at_position: Vector2) -> void:
	files_popup_menu.position = Vector2(get_viewport().position) + files_list.global_position + at_position
	files_popup_menu.popup()


func _on_files_list_file_middle_clicked(path: String):
	close_file(path)


func _on_files_popup_menu_about_to_popup() -> void:
	files_popup_menu.clear()

	var shortcuts: Dictionary = plugin.get_editor_shortcuts()

	files_popup_menu.add_item(DMConstants.translate(&"buffer.save"), ITEM_SAVE, OS.find_keycode_from_string(shortcuts.get("save")[0].as_text_keycode()))
	files_popup_menu.add_item(DMConstants.translate(&"buffer.save_as"), ITEM_SAVE_AS)
	files_popup_menu.add_item(DMConstants.translate(&"buffer.close"), ITEM_CLOSE, OS.find_keycode_from_string(shortcuts.get("close_file")[0].as_text_keycode()))
	files_popup_menu.add_item(DMConstants.translate(&"buffer.close_all"), ITEM_CLOSE_ALL)
	files_popup_menu.add_item(DMConstants.translate(&"buffer.close_other_files"), ITEM_CLOSE_OTHERS)
	files_popup_menu.add_separator()
	files_popup_menu.add_item(DMConstants.translate(&"buffer.copy_file_path"), ITEM_COPY_PATH)
	files_popup_menu.add_item(DMConstants.translate(&"buffer.show_in_filesystem"), ITEM_SHOW_IN_FILESYSTEM)


func _on_files_popup_menu_id_pressed(id: int) -> void:
	match id:
		ITEM_SAVE:
			save_file(current_file_path)
		ITEM_SAVE_AS:
			save_dialog.popup_centered()
		ITEM_CLOSE:
			close_file(current_file_path)
		ITEM_CLOSE_ALL:
			for path in open_buffers.keys():
				close_file(path)
		ITEM_CLOSE_OTHERS:
			var current_current_file_path: String = current_file_path
			for path in open_buffers.keys():
				if path != current_current_file_path:
					await close_file(path)

		ITEM_COPY_PATH:
			DisplayServer.clipboard_set(current_file_path)
		ITEM_SHOW_IN_FILESYSTEM:
			show_file_in_filesystem(current_file_path)


func _on_code_edit_external_file_requested(path: String, title: String) -> void:
	open_file(path)
	if title != "":
		code_edit.go_to_title(title)
	else:
		code_edit.set_caret_line(0)


func _on_close_confirmation_dialog_confirmed() -> void:
	save_file(current_file_path)
	remove_file_from_open_buffers(current_file_path)
	confirmation_closed.emit()


func _on_close_confirmation_dialog_custom_action(action: StringName) -> void:
	if action == "discard":
		remove_file_from_open_buffers(current_file_path)
	close_confirmation_dialog.hide()
	confirmation_closed.emit()


func _on_find_in_files_result_selected(path: String, cursor: Vector2, length: int) -> void:
	open_file(path)
	code_edit.select(cursor.y, cursor.x, cursor.y, cursor.x + length)
	code_edit.set_line_as_center_visible(cursor.y)
</file>

<file path="addons/dialogue_manager/views/main_view.tscn">
[gd_scene load_steps=15 format=3 uid="uid://cbuf1q3xsse3q"]

[ext_resource type="Script" uid="uid://cipjcc7bkh1pc" path="res://addons/dialogue_manager/views/main_view.gd" id="1_h6qfq"]
[ext_resource type="PackedScene" uid="uid://civ6shmka5e8u" path="res://addons/dialogue_manager/components/code_edit.tscn" id="2_f73fm"]
[ext_resource type="PackedScene" uid="uid://dnufpcdrreva3" path="res://addons/dialogue_manager/components/files_list.tscn" id="2_npj2k"]
[ext_resource type="PackedScene" uid="uid://ctns6ouwwd68i" path="res://addons/dialogue_manager/components/title_list.tscn" id="2_onb4i"]
[ext_resource type="PackedScene" uid="uid://co8yl23idiwbi" path="res://addons/dialogue_manager/components/update_button.tscn" id="2_ph3vs"]
[ext_resource type="PackedScene" uid="uid://gr8nakpbrhby" path="res://addons/dialogue_manager/components/search_and_replace.tscn" id="6_ylh0t"]
[ext_resource type="PackedScene" uid="uid://cs8pwrxr5vxix" path="res://addons/dialogue_manager/components/errors_panel.tscn" id="7_5cvl4"]
[ext_resource type="Script" uid="uid://klpiq4tk3t7a" path="res://addons/dialogue_manager/components/code_edit_syntax_highlighter.gd" id="7_necsa"]
[ext_resource type="PackedScene" uid="uid://0n7hwviyyly4" path="res://addons/dialogue_manager/components/find_in_files.tscn" id="10_yold3"]

[sub_resource type="Image" id="Image_faxki"]
data = {
"data": PackedByteArray(255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 93, 93, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0),
"format": "RGBA8",
"height": 16,
"mipmaps": false,
"width": 16
}

[sub_resource type="ImageTexture" id="ImageTexture_ka3gk"]
image = SubResource("Image_faxki")

[sub_resource type="Image" id="Image_y6rqu"]
data = {
"data": PackedByteArray(255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 93, 93, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0),
"format": "RGBA8",
"height": 16,
"mipmaps": false,
"width": 16
}

[sub_resource type="ImageTexture" id="ImageTexture_57eek"]
image = SubResource("Image_y6rqu")

[sub_resource type="SyntaxHighlighter" id="SyntaxHighlighter_kb7f8"]
script = ExtResource("7_necsa")

[node name="MainView" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1_h6qfq")

[node name="ParseTimer" type="Timer" parent="."]

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_vertical = 3
theme_override_constants/margin_left = 5
theme_override_constants/margin_right = 5
theme_override_constants/margin_bottom = 5
metadata/_edit_layout_mode = 1

[node name="Content" type="HSplitContainer" parent="Margin"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
dragger_visibility = 1

[node name="SidePanel" type="VBoxContainer" parent="Margin/Content"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
size_flags_horizontal = 3

[node name="Toolbar" type="HBoxContainer" parent="Margin/Content/SidePanel"]
layout_mode = 2

[node name="NewButton" type="Button" parent="Margin/Content/SidePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Start a new file"
flat = true

[node name="OpenButton" type="MenuButton" parent="Margin/Content/SidePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Open a file"
item_count = 9
popup/item_0/text = "Open..."
popup/item_0/icon = SubResource("ImageTexture_ka3gk")
popup/item_0/id = 100
popup/item_1/icon = SubResource("ImageTexture_ka3gk")
popup/item_1/id = 101
popup/item_2/id = -1
popup/item_2/separator = true
popup/item_3/text = "res://examples/dialogue.dialogue"
popup/item_3/icon = SubResource("ImageTexture_ka3gk")
popup/item_3/id = 3
popup/item_4/text = "res://examples/dialogue_with_input.dialogue"
popup/item_4/icon = SubResource("ImageTexture_ka3gk")
popup/item_4/id = 4
popup/item_5/text = "res://examples/dialogue_for_point_n_click.dialogue"
popup/item_5/icon = SubResource("ImageTexture_ka3gk")
popup/item_5/id = 5
popup/item_6/text = "res://examples/dialogue_for_visual_novel.dialogue"
popup/item_6/icon = SubResource("ImageTexture_ka3gk")
popup/item_6/id = 6
popup/item_7/id = -1
popup/item_7/separator = true
popup/item_8/text = "Clear recent files"
popup/item_8/id = 102

[node name="SaveAllButton" type="Button" parent="Margin/Content/SidePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
disabled = true
flat = true

[node name="FindInFilesButton" type="Button" parent="Margin/Content/SidePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Find in files..."
flat = true

[node name="Bookmarks" type="VSplitContainer" parent="Margin/Content/SidePanel"]
layout_mode = 2
size_flags_vertical = 3

[node name="FilesList" parent="Margin/Content/SidePanel/Bookmarks" instance=ExtResource("2_npj2k")]
unique_name_in_owner = true
visible = false
layout_mode = 2
size_flags_vertical = 3

[node name="FilesPopupMenu" type="PopupMenu" parent="Margin/Content/SidePanel/Bookmarks/FilesList"]
unique_name_in_owner = true

[node name="TitleList" parent="Margin/Content/SidePanel/Bookmarks" instance=ExtResource("2_onb4i")]
unique_name_in_owner = true
visible = false
layout_mode = 2

[node name="CodePanel" type="VBoxContainer" parent="Margin/Content"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 4.0

[node name="Toolbar" type="HBoxContainer" parent="Margin/Content/CodePanel"]
layout_mode = 2

[node name="InsertButton" type="MenuButton" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
disabled = true
text = "Insert"
item_count = 15
popup/item_0/text = "Wave BBCode"
popup/item_0/icon = SubResource("ImageTexture_57eek")
popup/item_1/text = "Shake BBCode"
popup/item_1/icon = SubResource("ImageTexture_57eek")
popup/item_1/id = 1
popup/item_2/id = -1
popup/item_2/separator = true
popup/item_3/text = "Typing pause"
popup/item_3/icon = SubResource("ImageTexture_57eek")
popup/item_3/id = 3
popup/item_4/text = "Typing speed change"
popup/item_4/icon = SubResource("ImageTexture_57eek")
popup/item_4/id = 4
popup/item_5/text = "Auto advance"
popup/item_5/icon = SubResource("ImageTexture_57eek")
popup/item_5/id = 5
popup/item_6/text = "Templates"
popup/item_6/id = -1
popup/item_6/separator = true
popup/item_7/text = "Title"
popup/item_7/icon = SubResource("ImageTexture_57eek")
popup/item_7/id = 6
popup/item_8/text = "Dialogue"
popup/item_8/icon = SubResource("ImageTexture_57eek")
popup/item_8/id = 7
popup/item_9/text = "Response"
popup/item_9/icon = SubResource("ImageTexture_57eek")
popup/item_9/id = 8
popup/item_10/text = "Random lines"
popup/item_10/icon = SubResource("ImageTexture_57eek")
popup/item_10/id = 9
popup/item_11/text = "Random text"
popup/item_11/icon = SubResource("ImageTexture_57eek")
popup/item_11/id = 10
popup/item_12/text = "Actions"
popup/item_12/id = -1
popup/item_12/separator = true
popup/item_13/text = "Jump to title"
popup/item_13/icon = SubResource("ImageTexture_57eek")
popup/item_13/id = 11
popup/item_14/text = "End dialogue"
popup/item_14/icon = SubResource("ImageTexture_57eek")
popup/item_14/id = 12

[node name="TranslationsButton" type="MenuButton" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
disabled = true
text = "Translations"
item_count = 5
popup/item_0/text = "Generate line IDs"
popup/item_0/icon = SubResource("ImageTexture_57eek")
popup/item_0/id = 100
popup/item_1/id = -1
popup/item_1/separator = true
popup/item_2/text = "Save character names to CSV..."
popup/item_2/icon = SubResource("ImageTexture_57eek")
popup/item_2/id = 201
popup/item_3/text = "Save lines to CSV..."
popup/item_3/icon = SubResource("ImageTexture_57eek")
popup/item_3/id = 202
popup/item_4/text = "Import line changes from CSV..."
popup/item_4/icon = SubResource("ImageTexture_57eek")
popup/item_4/id = 203

[node name="Separator" type="VSeparator" parent="Margin/Content/CodePanel/Toolbar"]
layout_mode = 2

[node name="SearchButton" type="Button" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Search for text"
disabled = true
toggle_mode = true
flat = true

[node name="Separator2" type="VSeparator" parent="Margin/Content/CodePanel/Toolbar"]
layout_mode = 2

[node name="TestButton" type="Button" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Test dialogue"
disabled = true
flat = true

[node name="TestLineButton" type="Button" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Test dialogue"
disabled = true
flat = true

[node name="Spacer2" type="Control" parent="Margin/Content/CodePanel/Toolbar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="SupportButton" type="Button" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Support Dialogue Manager"
text = "Sponsor"
flat = true

[node name="Separator4" type="VSeparator" parent="Margin/Content/CodePanel/Toolbar"]
layout_mode = 2

[node name="DocsButton" type="Button" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
layout_mode = 2
text = "Docs"
flat = true

[node name="VersionLabel" type="Label" parent="Margin/Content/CodePanel/Toolbar"]
unique_name_in_owner = true
modulate = Color(1, 1, 1, 0.490196)
layout_mode = 2
text = "v2.42.2"
vertical_alignment = 1

[node name="UpdateButton" parent="Margin/Content/CodePanel/Toolbar" instance=ExtResource("2_ph3vs")]
unique_name_in_owner = true
layout_mode = 2
text = "v2.44.1 available"

[node name="SearchAndReplace" parent="Margin/Content/CodePanel" instance=ExtResource("6_ylh0t")]
unique_name_in_owner = true
layout_mode = 2

[node name="CodeEdit" parent="Margin/Content/CodePanel" instance=ExtResource("2_f73fm")]
unique_name_in_owner = true
visible = false
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_colors/current_line_color = Color(0.266667, 0.278431, 0.352941, 0.243137)
theme_override_colors/background_color = Color(0.156863, 0.164706, 0.211765, 1)
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.94902, 1)
theme_override_font_sizes/font_size = 14
theme_override_colors/bookmark_color = Color(1, 0.333333, 0.333333, 1)
text = "~ start

Nathan: Hi, I'm Nathan and this is Coco.
Coco: Meow.
Nathan: Here are some response options.
- First one
	Nathan: You picked the first one.
- Second one
	Nathan: You picked the second one.
- Start again => start
- End the conversation => END
Nathan: I hope this example is helpful.
Coco: Meow.

=> END"
scroll_smooth = true
syntax_highlighter = SubResource("SyntaxHighlighter_kb7f8")

[node name="ErrorsPanel" parent="Margin/Content/CodePanel" instance=ExtResource("7_5cvl4")]
unique_name_in_owner = true
layout_mode = 2

[node name="NewDialog" type="FileDialog" parent="."]
size = Vector2i(900, 750)
min_size = Vector2i(600, 500)
dialog_hide_on_ok = true
filters = PackedStringArray("*.dialogue ; Dialogue")

[node name="SaveDialog" type="FileDialog" parent="."]
size = Vector2i(900, 750)
min_size = Vector2i(600, 500)
dialog_hide_on_ok = true
filters = PackedStringArray("*.dialogue ; Dialogue")

[node name="OpenDialog" type="FileDialog" parent="."]
title = "Open a File"
size = Vector2i(900, 750)
min_size = Vector2i(600, 500)
ok_button_text = "Open"
dialog_hide_on_ok = true
file_mode = 0
filters = PackedStringArray("*.dialogue ; Dialogue")

[node name="QuickOpenDialog" type="ConfirmationDialog" parent="."]
title = "Quick open"
size = Vector2i(600, 900)
min_size = Vector2i(400, 600)
ok_button_text = "Open"

[node name="QuickOpenFilesList" parent="QuickOpenDialog" instance=ExtResource("2_npj2k")]

[node name="ExportDialog" type="FileDialog" parent="."]
size = Vector2i(900, 750)
min_size = Vector2i(600, 500)

[node name="ImportDialog" type="FileDialog" parent="."]
title = "Open a File"
size = Vector2i(900, 750)
min_size = Vector2i(600, 500)
ok_button_text = "Open"
file_mode = 0
filters = PackedStringArray("*.csv ; Translation CSV")

[node name="ErrorsDialog" type="AcceptDialog" parent="."]
title = "Error"
dialog_text = "You have errors in your script. Fix them and then try again."

[node name="BuildErrorDialog" type="AcceptDialog" parent="."]
title = "Errors"
dialog_text = "You need to fix dialogue errors before you can run your game."

[node name="CloseConfirmationDialog" type="ConfirmationDialog" parent="."]
title = "Unsaved changes"
ok_button_text = "Save changes"

[node name="UpdatedDialog" type="AcceptDialog" parent="."]
title = "Updated"
size = Vector2i(191, 100)
dialog_text = "You're now up to date!"

[node name="FindInFilesDialog" type="AcceptDialog" parent="."]
title = "Find in files"
size = Vector2i(1200, 900)
min_size = Vector2i(800, 600)
ok_button_text = "Done"

[node name="FindInFiles" parent="FindInFilesDialog" node_paths=PackedStringArray("main_view", "code_edit") instance=ExtResource("10_yold3")]
custom_minimum_size = Vector2(400, 400)
offset_left = 8.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = -49.0
main_view = NodePath("../..")
code_edit = NodePath("../../Margin/Content/CodePanel/CodeEdit")

[connection signal="theme_changed" from="." to="." method="_on_main_view_theme_changed"]
[connection signal="visibility_changed" from="." to="." method="_on_main_view_visibility_changed"]
[connection signal="timeout" from="ParseTimer" to="." method="_on_parse_timer_timeout"]
[connection signal="pressed" from="Margin/Content/SidePanel/Toolbar/NewButton" to="." method="_on_new_button_pressed"]
[connection signal="about_to_popup" from="Margin/Content/SidePanel/Toolbar/OpenButton" to="." method="_on_open_button_about_to_popup"]
[connection signal="pressed" from="Margin/Content/SidePanel/Toolbar/SaveAllButton" to="." method="_on_save_all_button_pressed"]
[connection signal="pressed" from="Margin/Content/SidePanel/Toolbar/FindInFilesButton" to="." method="_on_find_in_files_button_pressed"]
[connection signal="file_middle_clicked" from="Margin/Content/SidePanel/Bookmarks/FilesList" to="." method="_on_files_list_file_middle_clicked"]
[connection signal="file_popup_menu_requested" from="Margin/Content/SidePanel/Bookmarks/FilesList" to="." method="_on_files_list_file_popup_menu_requested"]
[connection signal="file_selected" from="Margin/Content/SidePanel/Bookmarks/FilesList" to="." method="_on_files_list_file_selected"]
[connection signal="about_to_popup" from="Margin/Content/SidePanel/Bookmarks/FilesList/FilesPopupMenu" to="." method="_on_files_popup_menu_about_to_popup"]
[connection signal="id_pressed" from="Margin/Content/SidePanel/Bookmarks/FilesList/FilesPopupMenu" to="." method="_on_files_popup_menu_id_pressed"]
[connection signal="title_selected" from="Margin/Content/SidePanel/Bookmarks/TitleList" to="." method="_on_title_list_title_selected"]
[connection signal="toggled" from="Margin/Content/CodePanel/Toolbar/SearchButton" to="." method="_on_search_button_toggled"]
[connection signal="pressed" from="Margin/Content/CodePanel/Toolbar/TestButton" to="." method="_on_test_button_pressed"]
[connection signal="pressed" from="Margin/Content/CodePanel/Toolbar/TestLineButton" to="." method="_on_test_line_button_pressed"]
[connection signal="pressed" from="Margin/Content/CodePanel/Toolbar/SupportButton" to="." method="_on_support_button_pressed"]
[connection signal="pressed" from="Margin/Content/CodePanel/Toolbar/DocsButton" to="." method="_on_docs_button_pressed"]
[connection signal="close_requested" from="Margin/Content/CodePanel/SearchAndReplace" to="." method="_on_search_and_replace_close_requested"]
[connection signal="open_requested" from="Margin/Content/CodePanel/SearchAndReplace" to="." method="_on_search_and_replace_open_requested"]
[connection signal="active_title_change" from="Margin/Content/CodePanel/CodeEdit" to="." method="_on_code_edit_active_title_change"]
[connection signal="caret_changed" from="Margin/Content/CodePanel/CodeEdit" to="." method="_on_code_edit_caret_changed"]
[connection signal="error_clicked" from="Margin/Content/CodePanel/CodeEdit" to="." method="_on_code_edit_error_clicked"]
[connection signal="external_file_requested" from="Margin/Content/CodePanel/CodeEdit" to="." method="_on_code_edit_external_file_requested"]
[connection signal="text_changed" from="Margin/Content/CodePanel/CodeEdit" to="." method="_on_code_edit_text_changed"]
[connection signal="error_pressed" from="Margin/Content/CodePanel/ErrorsPanel" to="." method="_on_errors_panel_error_pressed"]
[connection signal="confirmed" from="NewDialog" to="." method="_on_new_dialog_confirmed"]
[connection signal="file_selected" from="NewDialog" to="." method="_on_new_dialog_file_selected"]
[connection signal="file_selected" from="SaveDialog" to="." method="_on_save_dialog_file_selected"]
[connection signal="file_selected" from="OpenDialog" to="." method="_on_open_dialog_file_selected"]
[connection signal="confirmed" from="QuickOpenDialog" to="." method="_on_quick_open_dialog_confirmed"]
[connection signal="file_double_clicked" from="QuickOpenDialog/QuickOpenFilesList" to="." method="_on_quick_open_files_list_file_double_clicked"]
[connection signal="file_selected" from="ExportDialog" to="." method="_on_export_dialog_file_selected"]
[connection signal="file_selected" from="ImportDialog" to="." method="_on_import_dialog_file_selected"]
[connection signal="confirmed" from="CloseConfirmationDialog" to="." method="_on_close_confirmation_dialog_confirmed"]
[connection signal="custom_action" from="CloseConfirmationDialog" to="." method="_on_close_confirmation_dialog_custom_action"]
[connection signal="result_selected" from="FindInFilesDialog/FindInFiles" to="." method="_on_find_in_files_result_selected"]
</file>

<file path="black_screen_overlay.gd">
# black_screen_overlay.gd
extends CanvasLayer
class_name BlackScreenOverlay

# This script is intentionally minimal for a simple overlay.
# You might add methods here later if the overlay needs to animate in/out.extends CanvasLayer
</file>

<file path="black_screen_overlay.tscn">
[gd_scene load_steps=2 format=3 uid="uid://c68edds3tbcw1"]

[ext_resource type="Script" uid="uid://iab82ux8w1b" path="res://black_screen_overlay.gd" id="1_pvaaq"]

[node name="BlackScreenOverlay" type="CanvasLayer"]
script = ExtResource("1_pvaaq")

[node name="ColorRect" type="ColorRect" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
</file>

<file path="Cannathink.tscn">
[gd_scene load_steps=4 format=3 uid="uid://p5o3770cpyst"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_eu5w5"]
[ext_resource type="Texture2D" uid="uid://dk1p47yk7kbuu" path="res://cannathink.png" id="2_eu5w5"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(613, 728)

[node name="CannaThink" type="Area2D"]
script = ExtResource("1_eu5w5")
object_display_name = "CannaThink"
object_id = "cannathink"

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_eu5w5")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-3.5, -1)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)
</file>

<file path="character_conversation_scene.tscn">
[gd_scene load_steps=4 format=3 uid="uid://bi8kmgyj7i5jv"]

[ext_resource type="Script" uid="uid://cmd0717xa6kc3" path="res://character_conversation_scene.gd" id="1_skmet"]
[ext_resource type="Texture2D" uid="uid://dh30l02tu32mv" path="res://png-clipart-hamburger-cheeseburger-fast-food-pixel-art-burger-king-food-cheese.png" id="2_76yhx"]
[ext_resource type="Resource" uid="uid://b7jdbk4b0natj" path="res://dialogue/npcs/faye.dialogue" id="2_jk88t"]

[node name="CharacterConversationScene" type="Node2D"]
script = ExtResource("1_skmet")
conversation_dialogue_file = ExtResource("2_jk88t")
scene_character_sprite_texture = ExtResource("2_76yhx")

[node name="Background" type="TextureRect" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="CharacterMainSprite" type="Sprite2D" parent="."]
position = Vector2(1011, 527)
</file>

<file path="conversationballoon.gd">
extends CanvasLayer
## A basic dialogue balloon for use with Dialogue Manager.

## The action to use for advancing the dialogue
@export var next_action: StringName = &"ui_accept"

## The action to use to skip typing the dialogue
@export var skip_action: StringName = &"ui_cancel"

## The dialogue resource
var resource: DialogueResource

## Temporary game states
var temporary_game_states: Array = []

## See if we are waiting for the player
var is_waiting_for_input: bool = false

## See if we are running a long mutation and should hide the balloon
var will_hide_balloon: bool = false

## A dictionary to store any ephemeral variables
var locals: Dictionary = {}

var _locale: String = TranslationServer.get_locale()

# --- ADDED: Character Color Lookup Table ---
# Alda: Cyan (Hair)
# Sergey: Gold/Cream (HSV 43, 44, 100 -> #FFDF8F)
var character_colors: Dictionary = {
	"AIda": Color("#42f5e0"),
	"Sergey": Color("#FFDF8F")
}
# -------------------------------------------

## The current line
var dialogue_line: DialogueLine:
	set(value):
		if value:
			dialogue_line = value
			apply_dialogue_line()
		else:
			# The dialogue has finished so close the balloon
			queue_free()
	get:
		return dialogue_line

## A cooldown timer for delaying the balloon hide when encountering a mutation.
var mutation_cooldown: Timer = Timer.new()

## The base balloon anchor
@onready var balloon: Control = %Balloon

## The label showing the name of the currently speaking character
@onready var character_label: RichTextLabel = %CharacterLabel

## The label showing the currently spoken dialogue
@onready var dialogue_label: DialogueLabel = %DialogueLabel

## The menu of responses
@onready var responses_menu: DialogueResponsesMenu = %ResponsesMenu


func _ready() -> void:
	balloon.hide()
	Engine.get_singleton("DialogueManager").mutated.connect(_on_mutated)

	# If the responses menu doesn't have a next action set, use this one
	if responses_menu.next_action.is_empty():
		responses_menu.next_action = next_action

	mutation_cooldown.timeout.connect(_on_mutation_cooldown_timeout)
	add_child(mutation_cooldown)


func _unhandled_input(_event: InputEvent) -> void:
	# Only the balloon is allowed to handle input while it's showing
	get_viewport().set_input_as_handled()


func _notification(what: int) -> void:
	## Detect a change of locale and update the current dialogue line to show the new language
	if what == NOTIFICATION_TRANSLATION_CHANGED and _locale != TranslationServer.get_locale() and is_instance_valid(dialogue_label):
		_locale = TranslationServer.get_locale()
		var visible_ratio = dialogue_label.visible_ratio
		self.dialogue_line = await resource.get_next_dialogue_line(dialogue_line.id)
		if visible_ratio < 1:
			dialogue_label.skip_typing()


## Start some dialogue
func start(dialogue_resource: DialogueResource, title: String, extra_game_states: Array = []) -> void:
	temporary_game_states = [self] + extra_game_states
	is_waiting_for_input = false
	resource = dialogue_resource
	self.dialogue_line = await resource.get_next_dialogue_line(title, temporary_game_states)


## Apply any changes to the balloon given a new [DialogueLine].
func apply_dialogue_line() -> void:
	mutation_cooldown.stop()

	is_waiting_for_input = false
	balloon.focus_mode = Control.FOCUS_ALL
	balloon.grab_focus()

	character_label.visible = not dialogue_line.character.is_empty()
	character_label.text = tr(dialogue_line.character, "dialogue")

	# --- MODIFIED: Character Color Logic ---
	var char_name = dialogue_line.character
	if character_colors.has(char_name):
		character_label.add_theme_color_override("default_color", character_colors[char_name])
	else:
		# Default to White (or whatever standard color you prefer) if not in the list
		character_label.add_theme_color_override("default_color", Color.WHITE)
	# ---------------------------------------

	dialogue_label.hide()
	dialogue_label.dialogue_line = dialogue_line

	responses_menu.hide()
	responses_menu.responses = dialogue_line.responses

	# Show our balloon
	balloon.show()
	will_hide_balloon = false

	dialogue_label.show()
	if not dialogue_line.text.is_empty():
		dialogue_label.type_out()
		await dialogue_label.finished_typing

	# Wait for input
	if dialogue_line.responses.size() > 0:
		balloon.focus_mode = Control.FOCUS_NONE
		responses_menu.show()
	elif dialogue_line.time != "":
		var time = dialogue_line.text.length() * 0.02 if dialogue_line.time == "auto" else dialogue_line.time.to_float()
		await get_tree().create_timer(time).timeout
		next(dialogue_line.next_id)
	else:
		is_waiting_for_input = true
		balloon.focus_mode = Control.FOCUS_ALL
		balloon.grab_focus()


## Go to the next line
func next(next_id: String) -> void:
	self.dialogue_line = await resource.get_next_dialogue_line(next_id, temporary_game_states)


#region Signals


func _on_mutation_cooldown_timeout() -> void:
	if will_hide_balloon:
		will_hide_balloon = false
		balloon.hide()


func _on_mutated(_mutation: Dictionary) -> void:
	is_waiting_for_input = false
	will_hide_balloon = true
	mutation_cooldown.start(0.1)


func _on_balloon_gui_input(event: InputEvent) -> void:
	# See if we need to skip typing of the dialogue
	if dialogue_label.is_typing:
		var mouse_was_clicked: bool = event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed()
		var skip_button_was_pressed: bool = event.is_action_pressed(skip_action)
		if mouse_was_clicked or skip_button_was_pressed:
			get_viewport().set_input_as_handled()
			dialogue_label.skip_typing()
			return

	if not is_waiting_for_input: return
	if dialogue_line.responses.size() > 0: return

	# When there are no response options the balloon itself is the clickable thing
	get_viewport().set_input_as_handled()

	if event is InputEventMouseButton and event.is_pressed() and event.button_index == MOUSE_BUTTON_LEFT:
		# Play the advance sound
		SoundManager.play_sfx("dialogue_advance")
		next(dialogue_line.next_id)
	elif event.is_action_pressed(next_action) and get_viewport().gui_get_focus_owner() == balloon:
		# Play the advance sound
		SoundManager.play_sfx("dialogue_advance")
		next(dialogue_line.next_id)


func _on_responses_menu_response_selected(response: DialogueResponse) -> void:
	# Play the advance sound
	SoundManager.play_sfx("dialogue_advance")
	next(response.next_id)


#endregion
</file>

<file path="hospital_bathroom_door.tscn">
[gd_scene load_steps=4 format=3 uid="uid://ctrgw5138xyjg"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_sd22h"]
[ext_resource type="Texture2D" uid="uid://v1wq5s3rq7nw" path="res://Sprites/Hospital Bathroom/hospital_bathroom_door.PNG" id="2_sd22h"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(697, 1259)

[node name="ExitDoor" type="Area2D"]
script = ExtResource("1_sd22h")
object_display_name = "Exit Door"
object_id = "exit_door"

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_sd22h")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-2.5, 1.5)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)
</file>

<file path="hospital_scrolling_wall_background.tscn">
[gd_scene load_steps=2 format=3 uid="uid://b4cos75vkxhkv"]

[ext_resource type="Texture2D" uid="uid://bd4myudxd6nqe" path="res://Hospital wall bg.PNG" id="1_cfd1v"]

[node name="ParallaxBackground" type="ParallaxBackground"]

[node name="ParallaxLayer" type="ParallaxLayer" parent="."]
motion_scale = Vector2(0.8, 0.8)
motion_mirroring = Vector2(1920, 0)

[node name="WallTile" type="Sprite2D" parent="ParallaxLayer"]
texture = ExtResource("1_cfd1v")
centered = false
</file>

<file path="input_blocker.gd">
# Attach this script to your InputBlocker ColorRect node temporarily
extends ColorRect

func _ready():
	print_rich("[color=cyan]InputBlocker ready: MouseFilter=%s, Size=%s[/color]" % [mouse_filter, size])

func _gui_input(event):
	if event is InputEventMouseButton:
		print_rich("[color=red]InputBlocker caught mouse click! This should block world input.[/color]")
		# Accept the event to consume it
		accept_event()
</file>

<file path="interactable.tscn">
[gd_scene load_steps=4 format=3 uid="uid://c3shvlwnp4663"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_wh154"]

[sub_resource type="ImageTexture" id="ImageTexture_wh154"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_x3v40"]

[node name="Interactable" type="Area2D"]
script = ExtResource("1_wh154")

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = SubResource("ImageTexture_wh154")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_x3v40")

[node name="WalkToPoint" type="Marker2D" parent="."]
</file>

<file path="Interactables/Game World/Hospital Bathroom/hospital_bathroom_mirror.tscn">
[gd_scene load_steps=8 format=3 uid="uid://bkjbta25aa1fj"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_ovcbv"]
[ext_resource type="Texture2D" uid="uid://c87trugw56gd4" path="res://Sprites/Hospital Bathroom/hospital_bathroom_mirror.png" id="2_mjm7d"]
[ext_resource type="FontFile" uid="uid://6fxwb86ujy6q" path="res://Fonts/IBMPlexSans-SemiBold.ttf" id="3_5u6mx"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_5u6mx"]
size = Vector2(1049, 529)

[sub_resource type="Animation" id="Animation_5u6mx"]
resource_name = "idle"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Control/Label:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 1, 2),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Color(1.0271568, 1.0271568, 1.0271568, 1), Color(1.0271568, 1.0271568, 1.0271568, 0.54901963), Color(1.0271568, 1.0271568, 1.0271568, 1)]
}

[sub_resource type="Animation" id="Animation_ybetr"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Control/Label:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1.0271568, 1.0271568, 1.0271568, 1)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_ue00j"]
_data = {
&"RESET": SubResource("Animation_ybetr"),
&"idle": SubResource("Animation_5u6mx")
}

[node name="HospitalBathroomMirror" type="Area2D"]
script = ExtResource("1_ovcbv")
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_mjm7d")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
visible = false
shape = SubResource("RectangleShape2D_5u6mx")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 254)

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_ue00j")
}
autoplay = "idle"

[node name="Control" type="Control" parent="."]
layout_mode = 3
anchors_preset = 0
offset_right = 40.0
offset_bottom = 40.0

[node name="Label" type="Label" parent="Control"]
modulate = Color(1.0271568, 1.0271568, 1.0271568, 1)
layout_mode = 1
anchors_preset = -1
anchor_left = 4.275
anchor_top = -6.275
anchor_right = 12.575001
anchor_bottom = -2.6000001
offset_right = -3.0517578e-05
theme_override_colors/font_color = Color(0.39999998, 1, 1, 1)
theme_override_colors/font_outline_color = Color(0.12012003, 0.09239999, 0.33, 1)
theme_override_constants/shadow_offset_x = 0
theme_override_constants/shadow_offset_y = 0
theme_override_constants/outline_size = 4
theme_override_constants/shadow_outline_size = 2
theme_override_fonts/font = ExtResource("3_5u6mx")
theme_override_font_sizes/font_size = 36
text = "17 Septmeber 2094
7:00 PM
98.6"
</file>

<file path="Interactables/Game World/Hospital Bathroom/hospital_bathroom_toilet_flush.tscn">
[gd_scene load_steps=4 format=3 uid="uid://dwqwwrmp7uisr"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_leo2j"]
[ext_resource type="Texture2D" uid="uid://b6l5j3t3qweui" path="res://Sprites/Hospital Bathroom/hospital_bathroom_toilet_flush.png" id="2_leo2j"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_5u6mx"]
size = Vector2(334, 105.5)

[node name="HospitalBathroomToiletPaper" type="Area2D"]
script = ExtResource("1_leo2j")
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="ContactShadow" type="Sprite2D" parent="."]
modulate = Color(0.33, 0.132, 0.19800003, 0.18039216)
z_index = -1
texture = ExtResource("2_leo2j")
offset = Vector2(2.845, 2.5)

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_leo2j")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(1, 0.25)
shape = SubResource("RectangleShape2D_5u6mx")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(3, -4)
</file>

<file path="Interactables/Game World/Hospital Bathroom/hospital_bathroom_toilet_paper.tscn">
[gd_scene load_steps=4 format=3 uid="uid://cj8nc55uc3in"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_8n14r"]
[ext_resource type="Texture2D" uid="uid://bh7iuihr2gl5i" path="res://Sprites/Hospital Bathroom/hospital_bathroom_toilet_paper.PNG" id="2_e1ojk"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_5u6mx"]
size = Vector2(151, 73)

[node name="HospitalBathroomToiletPaper" type="Area2D"]
script = ExtResource("1_8n14r")
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="ContactShadow" type="Sprite2D" parent="."]
modulate = Color(0.33, 0.132, 0.19800003, 0.18039216)
z_index = -1
texture = ExtResource("2_e1ojk")
offset = Vector2(2.845, 2.5)

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_e1ojk")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(2.5, -3.5)
shape = SubResource("RectangleShape2D_5u6mx")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(3, -4)
</file>

<file path="Interactables/Game World/Hospital Bathroom/hospital_toilet.gd">
extends Node2D

enum ToiletState { NORMAL, HAS_PAPER, CLOGGED }

@onready var animation_player: AnimationPlayer = $AnimationPlayer
@onready var interactable_component: Interactable = $InteractionArea 

func _ready():
	await get_tree().process_frame
	if not GameManager: return
	_restore_state()

func _restore_state():
	if GameManager.get_current_level_flag("toilet_clogged"):
		change_state(ToiletState.CLOGGED)
	elif GameManager.get_current_level_flag("toilet_has_paper"):
		change_state(ToiletState.HAS_PAPER)
	else:
		change_state(ToiletState.NORMAL)

func change_state(new_state_int: int):
	var new_state = new_state_int as ToiletState
	
	if GameManager:
		# --- UPDATED LOGIC: Explicitly handle ALL flags ---
		match new_state:
			ToiletState.NORMAL:
				# Clear ALL flags when normal
				GameManager.set_current_level_flag("toilet_has_paper", false)
				GameManager.set_current_level_flag("toilet_clogged", false)
			ToiletState.HAS_PAPER:
				GameManager.set_current_level_flag("toilet_has_paper", true)
				# Ensure clogged is false
				GameManager.set_current_level_flag("toilet_clogged", false)
			ToiletState.CLOGGED:
				GameManager.set_current_level_flag("toilet_clogged", true)
				# (Optional: keep has_paper true if you want, or clear it. Usually clogged implies paper is stuck)
				# GameManager.set_current_level_flag("toilet_has_paper", true) 

	match new_state:
		ToiletState.NORMAL:
			if animation_player: 
				if animation_player.has_animation("idle"):
					animation_player.play("idle")
				else:
					animation_player.stop()
			print_rich("[color=cyan]Toilet State: NORMAL[/color]")
			
		ToiletState.HAS_PAPER:
			print_rich("[color=cyan]Toilet State: HAS_PAPER (Pending Flush)[/color]")
			
		ToiletState.CLOGGED:
			if animation_player: 
				if animation_player.has_animation("error"):
					animation_player.play("error")
				else:
					push_warning("HospitalToilet: 'error' animation not found.")
			print_rich("[color=red]Toilet State: CLOGGED[/color]")
</file>

<file path="Interactables/Game World/Hospital Bathroom/hospital_toilet.tscn">
[gd_scene load_steps=12 format=3 uid="uid://dq1e26q2d8nix"]

[ext_resource type="Script" uid="uid://dnvm6gaiggom5" path="res://Interactables/Game World/Hospital Bathroom/hospital_toilet.gd" id="1_1kp37"]
[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_br1pn"]
[ext_resource type="Texture2D" uid="uid://bl6sy4jw0eepu" path="res://Sprites/Hospital Bathroom/hospital_bathroom_commode.PNG" id="2_sqtfq"]
[ext_resource type="Texture2D" uid="uid://ccwgyb5recki5" path="res://Sprites/Hospital Bathroom/hospital_bathroom_commode_glow.PNG" id="3_1kp37"]
[ext_resource type="Texture2D" uid="uid://bfuowd216d3ww" path="res://Sprites/Hospital Bathroom/hospital_bathroom_commode_error.png" id="5_hkb1v"]
[ext_resource type="Texture2D" uid="uid://bt5bjupru8val" path="res://Sprites/Hospital Bathroom/hospital_bathroom_commode_error_glow.png" id="6_4dkf8"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_o6q4n"]
size = Vector2(188, 333)

[sub_resource type="Animation" id="Animation_4dkf8"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("ObjectSprite:texture")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("2_sqtfq")]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Glow:texture")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("3_1kp37")]
}

[sub_resource type="Animation" id="Animation_8uv34"]
resource_name = "error"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 1, 2),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Color(1, 1, 1, 1), Color(1, 1, 1, 0.44705883), Color(1, 1, 1, 1)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("ObjectSprite:texture")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0.033333335),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("5_hkb1v")]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Glow:texture")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("6_4dkf8")]
}

[sub_resource type="Animation" id="Animation_hkb1v"]
resource_name = "idle"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 1, 2),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Color(1, 1, 1, 1), Color(1, 1, 1, 0.44705883), Color(1, 1, 1, 1)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("ObjectSprite:texture")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("2_sqtfq")]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("Glow:texture")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("3_1kp37")]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_8uv34"]
_data = {
&"RESET": SubResource("Animation_4dkf8"),
&"error": SubResource("Animation_8uv34"),
&"idle": SubResource("Animation_hkb1v")
}

[node name="HospitalToilet" type="Node2D"]
script = ExtResource("1_1kp37")

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_sqtfq")

[node name="Glow" type="Sprite2D" parent="."]
texture = ExtResource("3_1kp37")

[node name="InteractionArea" type="Area2D" parent="."]
script = ExtResource("1_br1pn")
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="InteractionClickShape" type="CollisionShape2D" parent="InteractionArea"]
position = Vector2(-7, -44.5)
shape = SubResource("RectangleShape2D_o6q4n")

[node name="WalkToPoint" type="Marker2D" parent="."]

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_8uv34")
}
autoplay = "idle"
</file>

<file path="Interactables/Game World/Hospital Room/medicine_cabinet.tscn">
[gd_scene load_steps=10 format=3 uid="uid://crcjecrrvndr2"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_niuas"]
[ext_resource type="Texture2D" uid="uid://t7yho2m7tt4m" path="res://Sprites/Hospital Room/medicine_cabinet.png" id="2_shog1"]
[ext_resource type="Texture2D" uid="uid://xwufbgcjblgc" path="res://Sprites/Hospital Room/medicine_cabinet_glow.png" id="3_shoix"]

[sub_resource type="Gradient" id="Gradient_hiqhm"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.6041096)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_shog1"]
gradient = SubResource("Gradient_hiqhm")
fill = 1
fill_from = Vector2(0.50427353, 0.5)
fill_to = Vector2(0.008547009, 0.014957265)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(622, 1161)

[sub_resource type="Animation" id="Animation_m2n17"]
resource_name = "idle"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 1, 2),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Color(1, 1, 1, 1), Color(1, 1, 1, 0.4509804), Color(1, 1, 1, 1)]
}

[sub_resource type="Animation" id="Animation_x3oxh"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_u5pgw"]
_data = {
&"RESET": SubResource("Animation_x3oxh"),
&"idle": SubResource("Animation_m2n17")
}

[node name="MedicineCabinet" type="Area2D"]
script = ExtResource("1_niuas")
object_display_name = "Medicine Cabinet"
object_id = "MedicineCabinet"

[node name="Contact shadow" type="Sprite2D" parent="."]
modulate = Color(0, 0, 0, 0.08235294)
texture = ExtResource("2_shog1")
offset = Vector2(20.16, 15.235)

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_shog1")

[node name="glow" type="Sprite2D" parent="."]
position = Vector2(-16, -3)
texture = ExtResource("3_shoix")

[node name="FloorShadow" type="Sprite2D" parent="."]
modulate = Color(0.16546667, 0.126, 0.2, 0.32941177)
position = Vector2(3.000001, 748.00006)
scale = Vector2(14.90625, 1.7708337)
texture = SubResource("GradientTexture2D_shog1")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-9, 9.5)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_u5pgw")
}
autoplay = "idle"
</file>

<file path="interactions/actions/OpenMemoryBoxAction.gd">
# res://interactions/actions/OpenMemoryBoxAction.gd
class_name OpenMemoryBoxAction
extends Action

# We preload the scene this action is responsible for opening.
const MemoryBoxScene = preload("res://MemoryBoxOverlay.tscn") # <-- IMPORTANT: Verify this path!

func execute(interactable_node: Interactable) -> bool:
	if not MemoryBoxScene:
		push_warning("OpenMemoryBoxAction failed: Scene could not be loaded.")
		return true


	if GameManager:
		GameManager.enter_conversation_state()

	# Tell the GameManager to handle any state changes if necessary.
	# For example, GameManager.enter_overlay_state()

	var instance = MemoryBoxScene.instantiate()
	interactable_node.get_tree().root.add_child(instance)

	print_rich("[color=cyan]OpenMemoryBoxAction: Opened the Memory Box overlay.[/color]")

	# VERY IMPORTANT: Return false to stop the interaction cycle.
	return false
</file>

<file path="interactions/actions/PlaySoundAction.gd">
# res://interactions/actions/PlaySoundAction.gd
extends Action
class_name PlaySoundAction

## The key name of the sound to play (must exist in SoundManager.sfx_library).
@export var sound_name: String = ""

## If true, the game will wait for the sound to finish before starting the next action.
## Useful for "Sound -> Then Dialogue" sequences.
@export var wait_for_completion: bool = false

@export_range(0.1, 4.0) var pitch: float = 1.0
@export_range(-80.0, 24.0) var volume_db: float = 0.0

func execute(_interactable_node: Interactable) -> Variant:
	if sound_name == "":
		push_warning("PlaySoundAction: No sound_name specified.")
		return true

	# Call the manager and get the player instance back
	var audio_player = SoundManager.play_sfx(sound_name, pitch, volume_db)

	if wait_for_completion and is_instance_valid(audio_player):
		# This pauses the interaction sequence until the sound finishes
		await audio_player.finished
	
	return true
</file>

<file path="interactions/actions/TeleportAction.gd">
class_name TeleportAction
extends Action

@export var target_marker_name: String = ""

func execute(interactable_node: Interactable) -> bool:
	var player = GameManager.player_node
	var transition_layer = GameManager.transition_layer # Grab the layer
	
	if not is_instance_valid(player):
		return false
	
	var target_node = GameManager.main_game_scene_instance.find_child(target_marker_name, true, false)
	if not target_node:
		push_error("TeleportAction: Marker '%s' not found!" % target_marker_name)
		return false

	# 1. Lock Player Movement (Important!)
	# We don't want them walking away while the door closes
	player.set_can_move(false) # Or whatever function locks your player input
	
	# 2. Check if we have a transition layer to use
	if is_instance_valid(transition_layer):
		# Start the animation sequence
		transition_layer.play_transition_sequence()
		
		# WAIT here until the doors are fully closed (black screen)
		await transition_layer.transition_halfway
		
	# 3. Teleport Logic (Happens while screen is black)
	if GameManager.has_method("player_has_finished_walk_command"):
		GameManager.player_has_finished_walk_command()
	if player.has_method("stop_movement"): 
		player.stop_movement() 
	
	player.global_position = target_node.global_position
	
	var camera = interactable_node.get_viewport().get_camera_2d()
	if camera and camera.has_method("snap_to_target"):
		camera.snap_to_target()
		
	# 4. Cleanup
	# If we used the transition, we wait for it to finish opening
	if is_instance_valid(transition_layer):
		await transition_layer.transition_finished
	
	# Unlock player
	player.set_can_move(true)
	
	return true
</file>

<file path="Invigirol.tscn">
[gd_scene load_steps=2 format=3 uid="uid://bbxktfo2natla"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_evh2x"]

[node name="Invigirol" type="Area2D"]
script = ExtResource("1_evh2x")
object_display_name = "Invigirol"
object_id = "invigirol"

[node name="ObjectSprite" type="Sprite2D" parent="."]

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)
</file>

<file path="ItemData.gd">
# ItemData.gd
extends Resource
class_name ItemData # Makes this usable as a type hint and for creating new resources easily

## The unique identifier for this item (e.g., "key_main_door", "burger_mystery_meat").
## Use snake_case, all lowercase, for consistency with verb_ids.
@export var item_id: String = ""

## The name of the item as it will be displayed to the player (e.g., in inventory, in dialogue).
@export var display_name: String = "New Item"

## The texture to use as an icon for this item in the inventory UI.
@export var icon: Texture2D = null

## The description of the item that the player sees/thinks when they "Examine" it
## (either directly in inventory or if they use "Examine" on the item in the world before picking it up).
@export_multiline var description: String = "It's an item."

## Can this item be stacked in the inventory? (e.g., arrows, coins)
## For most classic point-and-click adventure items, this will be false.
@export var is_stackable: bool = false

## If is_stackable is true, what's the maximum number that can be in one stack?
## (Not highly relevant if is_stackable is usually false).
@export var max_stack_size: int = 1

## (Optional) A list of verb_ids that this item can be *primarily* used with.
## This is more for filtering or providing hints, as the actual "Use Item X with Y"
## logic is usually defined on the target interactable (Y).
## Example: A key might primarily be for "use_item" (on a door). A food item might be for "give" or "use_item" (on self).
# @export var compatible_verb_ids: Array[String] = []

# You can add more game-specific properties here later, for example:
# @export var is_quest_item: bool = false
# @export var value: int = 0 # If you had currency
# @export var sfx_on_pickup: AudioStream = null
# @export var sfx_on_use: AudioStream = null

# No functions are strictly needed in this Resource script itself for basic data storage.
# Its purpose is to define a data structure that you can edit in the Inspector.

func _init(id: String = "", name: String = "", tex: Texture2D = null, desc: String = ""):
	# Optional constructor for creating instances from code, though mostly you'll use .tres files
	if id != "": item_id = id
	if name != "": display_name = name
	if tex != null: icon = tex
	if desc != "": description = desc
</file>

<file path="level_state_manager.tscn">
[gd_scene load_steps=2 format=3 uid="uid://bptirrl2ojkpc"]

[ext_resource type="Script" uid="uid://bs05cyo72v37l" path="res://LevelStateManager.gd" id="1_quggg"]

[node name="LevelStateManager" type="Node"]
script = ExtResource("1_quggg")
</file>

<file path="MainMenu.gd">
# MainMenu.gd
extends CanvasLayer
# The GameManager is listening for these specific signals
signal new_game_requested
signal quit_game_requested

func _on_new_game_button_pressed():
	# Verify the click is working in the Output log
	print("MainMenu: New Game Button Pressed") 
	new_game_requested.emit()

func _on_quit_button_pressed():
	print("MainMenu: Quit Button Pressed")
	quit_game_requested.emit()
</file>

<file path="mcbucket_invigirol_conversation.tscn">
[gd_scene load_steps=7 format=3 uid="uid://d4agulio3tpco"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_fjuih"]
[ext_resource type="Resource" uid="uid://b8mle40ah8hb3" path="res://mcbucket_invigirol.dialogue" id="2_fjuih"]
[ext_resource type="Texture2D" uid="uid://cx4r1a1ci7vpj" path="res://sergei.PNG" id="3_csurk"]
[ext_resource type="Texture2D" uid="uid://coo5k2phjvc1e" path="res://Protag.png" id="4_tjmot"]
[ext_resource type="Texture2D" uid="uid://xra4dmomvu43" path="res://Backgrounds/McBucket/invigirol/mcbucket_ivigirol_base.png" id="5_2kt3p"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_csurk")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
layer = 2
script = ExtResource("1_fjuih")
conversation_dialogue_file = ExtResource("2_fjuih")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_tjmot")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(957, 540.5)
scale = Vector2(0.497917, 0.498611)
texture = ExtResource("5_2kt3p")

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6
</file>

<file path="Non Interactables/hospital_bathroom_sink.tscn">
[gd_scene load_steps=6 format=3 uid="uid://b7ruec2vo6haw"]

[ext_resource type="Texture2D" uid="uid://bcxknipqlnnip" path="res://Sprites/Hospital Bathroom/hospital_bathroom_sink.png" id="1_pku02"]
[ext_resource type="Texture2D" uid="uid://hbjklpou26b6" path="res://Sprites/Hospital Bathroom/hospital_bathroom_sink_glow.png" id="2_q62sv"]

[sub_resource type="Animation" id="Animation_s8bgj"]
resource_name = "idle"
length = 4.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 2, 4),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Color(1, 1, 1, 0.67058825), Color(1, 1, 1, 0.42745098), Color(1, 1, 1, 0.67058825)]
}

[sub_resource type="Animation" id="Animation_vww1u"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Glow:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_p3bfk"]
_data = {
&"RESET": SubResource("Animation_vww1u"),
&"idle": SubResource("Animation_s8bgj")
}

[node name="HospitalBathroomSink" type="Node2D"]

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("1_pku02")

[node name="Glow" type="Sprite2D" parent="."]
texture = ExtResource("2_q62sv")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_p3bfk")
}
autoplay = "idle"
</file>

<file path="npc.gd">
extends Area2D

var player_in_zone := false

func _ready():
	set_process(true)  # Enables the _process() function

func _on_body_entered(body):
	if body.is_in_group("player"):
		player_in_zone = true
		print("Player has entered NPC interaction zone!")

func _on_body_exited(body):
	if body.is_in_group("player"):
		player_in_zone = false
		print("Player has left NPC interaction zone.")

func _process(delta):
	if player_in_zone and Input.is_action_just_pressed("talk_to_npc"):
		var dlg = load("res://testdialogue.dialogue")
		DialogueManager.show_dialogue_balloon(dlg, "start")
</file>

<file path="npc.tscn">
[gd_scene load_steps=3 format=3 uid="uid://c34r3tmuut3h6"]

[ext_resource type="Script" uid="uid://ddxsjoyft48w7" path="res://npc.gd" id="1_h31eo"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_nvh0d"]
size = Vector2(32, 64)

[node name="NPC" type="Area2D"]
script = ExtResource("1_h31eo")

[node name="ColorRect" type="ColorRect" parent="."]
offset_right = 32.0
offset_bottom = 64.0
color = Color(0.545098, 1, 0, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(16, 32)
shape = SubResource("RectangleShape2D_nvh0d")

[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="body_exited" from="." to="." method="_on_body_exited"]
</file>

<file path="object_zoom_overlay.gd">
extends CanvasLayer
class_name ObjectZoomOverlay

signal zoom_view_closed

@export var background_texture: Texture2D

@onready var close_button: Button = $RootContainer/CloseButton
@onready var zoom_background: TextureRect = $RootContainer/ZoomBackground

func _ready():
	# --- Set the Background Texture from the Inspector ---
	if zoom_background:
		if background_texture:
			zoom_background.texture = background_texture
		else:
			print_rich("[color=orange]ObjectZoomOverlay: No 'background_texture' has been assigned in the Inspector.[/color]")
	else:
		print_rich("[color=red]ObjectZoomOverlay: The 'ZoomBackground' node was not found under RootContainer![/color]")

	# --- Connect the Close Button ---
	if close_button:
		close_button.pressed.connect(_on_close_button_pressed)
	else:
		print_rich("[color=red]ObjectZoomOverlay: The 'CloseButton' node was not found! The player may get stuck.[/color]")

	# --- Inform the GameManager about the state change ---
	if GameManager and GameManager.has_method("enter_zoom_view_state"):
		GameManager.enter_zoom_view_state()
	else:
		print_rich("[color=orange]ObjectZoomOverlay: GameManager or enter_zoom_view_state() not found.[/color]")


# --- THIS IS THE MISSING FUNCTION ---
func _on_close_button_pressed():
	# When the button is pressed, we start the cleanup process.
	_cleanup_and_queue_free()


# --- Cleanup Functions ---
func _cleanup_and_queue_free():
	# Inform the GameManager that we are returning to the main level.
	if GameManager and GameManager.has_method("exit_to_world_state"):
		GameManager.exit_to_world_state()

	# Disconnect the signal to be tidy.
	if close_button and close_button.pressed.is_connected(_on_close_button_pressed):
		close_button.pressed.disconnect(_on_close_button_pressed)

	# Emit our own signal before we disappear.
	zoom_view_closed.emit()

	# Remove the overlay from the game.
	queue_free()
</file>

<file path="ObjectZoomOverlay.tscn">
[gd_scene load_steps=2 format=3 uid="uid://b5y6x40wshw3c"]

[ext_resource type="Script" uid="uid://dgi247xxwu7j3" path="res://object_zoom_overlay.gd" id="1_flpt1"]

[node name="ObjectZoomOverlay" type="CanvasLayer"]
layer = 2
script = ExtResource("1_flpt1")

[node name="RootContainer" type="Control" parent="."]
process_mode = 3
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="ZoomBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
mouse_filter = 2
expand_mode = 1
stretch_mode = 6

[node name="InteractableContainer" type="Node2D" parent="RootContainer"]

[node name="Button" type="Button" parent="RootContainer"]
layout_mode = 0
offset_left = 22.0
offset_top = 26.0
offset_right = 130.0
offset_bottom = 83.0
text = "BACK LOL"
</file>

<file path="sergey.gd">
extends CharacterBody2D

# 1. Get a reference to the AnimationPlayer node
@onready var animation_player: AnimationPlayer = $AnimationPlayer

# 2. Get a reference to the InteractionArea (useful for later if he needs dialogue)
@onready var interactable_component = $InteractionArea

func _ready():
	# 3. Play the 'idle' animation as soon as the node enters the scene
	# Make sure the animation name in your AnimationPlayer tab is exactly "idle" (case-sensitive)
	animation_player.play("idle")
</file>

<file path="Shaders/grayscale_material.gdshader">
shader_type canvas_item;

// A slider from 0.0 (Normal) to 1.0 (Grayscale)
uniform float strength : hint_range(0.0, 1.0) = 0.0;

void fragment() {
    vec4 original_color = texture(TEXTURE, UV);
    
    // Calculate the gray version
    float gray = dot(original_color.rgb, vec3(0.299, 0.587, 0.114));
    vec3 gray_rgb = vec3(gray, gray, gray);
    
    // Mix the original color with the gray color based on 'strength'
    COLOR.rgb = mix(original_color.rgb, gray_rgb, strength);
    COLOR.a = original_color.a;
}
</file>

<file path="static_bathroom_background.tscn">
[gd_scene load_steps=2 format=3 uid="uid://btku3hrvme7k6"]

[ext_resource type="Texture2D" uid="uid://cigj6loe88g6u" path="res://Backgrounds/Levels/static_hospital_bathroom_background.PNG" id="1_2wpbe"]

[node name="StaticWallBackground" type="Node2D"]

[node name="WallTile1" type="Sprite2D" parent="."]
texture = ExtResource("1_2wpbe")
centered = false
</file>

<file path="static_wall_background_ventless.tscn">
[gd_scene load_steps=2 format=3 uid="uid://mbqo64idf1si"]

[ext_resource type="Texture2D" uid="uid://bhj2e6pwkymsb" path="res://Backgrounds/Levels/static_hospital_background_ventless.png" id="1_oq061"]

[node name="StaticWallBackground" type="Node2D"]

[node name="WallTile1" type="Sprite2D" parent="."]
texture = ExtResource("1_oq061")
centered = false
</file>

<file path="television_screen.gdshader">
shader_type canvas_item;

// A function to generate a pseudo-random number
float random(vec2 uv) {
    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void fragment() {
    // Get the original color of the sprite's texture at this pixel
    vec4 original_color = texture(TEXTURE, UV);

    // Only run the effect on the white parts of the TV screen
    if (original_color.r > 0.9) {
        // --- TV EFFECT CODE START ---

        // 1. Create a smoothly cycling color
        float color_speed = 0.5; // Controls how fast the colors change
        vec3 dynamic_color;
        dynamic_color.r = (sin(TIME * color_speed + 0.0) * 0.5) + 0.5; // Red channel
        dynamic_color.g = (sin(TIME * color_speed + 2.0) * 0.5) + 0.5; // Green channel (offset)
        dynamic_color.b = (sin(TIME * color_speed + 4.0) * 0.5) + 0.5; // Blue channel (offset more)
        
        vec3 white_color = vec3(1.0, 1.0, 1.0);

        // 2. Create the "wavey" movement
        // First, create a horizontal wave that will distort our main wave
        // The '0.1' at the end controls the intensity of the "wobble".
        float horizontal_wobble = sin(UV.x * 15.0 + TIME * 1.5) * 0.1;

        // Now, create the main vertical wave, but add the wobble to it
        // '20.0' is the number of vertical waves. '3.0' is the scroll speed.
        float wave_pattern = sin((UV.y * 20.0) + horizontal_wobble + (TIME * 3.0));
        
        // Map the wave from the [-1, 1] range to the [0, 1] range
        wave_pattern = (wave_pattern * 0.5) + 0.5;

        // 3. Mix the cycling color and white based on our complex wave
        vec3 color = mix(dynamic_color, white_color, wave_pattern);

        // 4. Add a very subtle layer of static so it still feels like a screen
        float noise = random(UV - TIME * 10.0) * 0.1;
        color += vec3(noise);

        COLOR = vec4(color, 1.0);
        // --- TV EFFECT CODE END ---

    } else {
        // Otherwise, it's the TV frame, so just draw the original color
        COLOR = original_color;
    }
}
</file>

<file path="TransitionLayer.gd">
# TransitionLayer.gd
extends CanvasLayer

signal transition_halfway # Emitted when doors are fully closed
signal transition_finished # Emitted when doors are fully open again

@onready var left_shutter = $LeftShutter
@onready var right_shutter = $RightShutter

func _ready():
	# Ensure they start invisible/off-screen
	open_instant()

func open_instant():
	var viewport_width = get_viewport().get_visible_rect().size.x
	left_shutter.position.x = -left_shutter.size.x
	right_shutter.position.x = viewport_width

# This function plays the full sequence: Close -> Wait -> Open
func play_transition_sequence():
	var viewport_width = get_viewport().get_visible_rect().size.x
	var center_x = viewport_width / 2.0
	
	# --- PLAY CLOSE SOUND ---
	# We play this immediately as the shutters start moving in.
	SoundManager.play_sfx("door_close")
	
	var tween = create_tween()
	# Parallel animation: Both doors slide in at the same time
	tween.set_parallel(true)
	tween.set_trans(Tween.TRANS_QUART) # Nice smooth sci-fi motion
	tween.set_ease(Tween.EASE_OUT)
	
	# Slide Left Shutter to 0 (Left edge)
	tween.tween_property(left_shutter, "position:x", 0.0, 0.5)
	# Slide Right Shutter to center (Right edge moves left)
	tween.tween_property(right_shutter, "position:x", center_x, 0.5)
	
	# Wait for animation to finish
	await tween.finished
	
	emit_signal("transition_halfway") # TELL THE GAME TO TELEPORT NOW
	
	# Optional: Small pause while screen is black
	await get_tree().create_timer(0.2).timeout
	
	# --- PLAY OPEN SOUND ---
	# We play this right before the shutters start opening.
	SoundManager.play_sfx("door_open")
	
	# Open the doors
	var open_tween = create_tween()
	open_tween.set_parallel(true)
	open_tween.set_trans(Tween.TRANS_QUART)
	open_tween.set_ease(Tween.EASE_IN)
	
	# Slide back out
	open_tween.tween_property(left_shutter, "position:x", -left_shutter.size.x, 0.5)
	open_tween.tween_property(right_shutter, "position:x", viewport_width, 0.5)
	
	await open_tween.finished
	emit_signal("transition_finished")
</file>

<file path="TransitionLayer.tscn">
[gd_scene load_steps=2 format=3 uid="uid://dk7b3f3vitmx1"]

[ext_resource type="Script" uid="uid://bejnil8lqoueh" path="res://TransitionLayer.gd" id="1_ad7ro"]

[node name="TransitionLayer" type="CanvasLayer"]
layer = 100
script = ExtResource("1_ad7ro")

[node name="LeftShutter" type="ColorRect" parent="."]
anchors_preset = 9
anchor_bottom = 1.0
offset_left = -960.0
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="RightShutter" type="ColorRect" parent="."]
anchors_preset = 11
anchor_left = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 960.0
grow_horizontal = 0
grow_vertical = 2
color = Color(0, 0, 0, 1)
</file>

<file path="tubelight.tscn">
[gd_scene load_steps=2 format=3 uid="uid://3rnka5lbsieb"]

[ext_resource type="Texture2D" uid="uid://dapp6nlti67to" path="res://tubelight.png" id="1_hipca"]

[node name="Tubelight" type="Node2D"]

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = ExtResource("1_hipca")
centered = false
</file>

<file path="tv_controller.gd">
extends Sprite2D

# We need a reference to the shader material to change its parameters.
@onready var tv_material: ShaderMaterial = material

func _ready():
	# Ensure the TV starts in the "On" state.
	# We will use another shader (like the aurora one) for the "On" state.
	# For now, this just sets the shutdown progress to 0.
	tv_material.set_shader_parameter("progress", 0.0)

# This is a simple test to trigger the effect by pressing Spacebar.
# You can call the turn_off() function from anywhere in your game!
func _input(event):
	if event.is_action_pressed("ui_accept"): # "ui_accept" is the Spacebar by default
		turn_off()

func turn_off():
	# A Tween is the perfect tool to animate a value over time.
	var tween = create_tween()

	# Tell the tween to animate the "progress" parameter inside our shader material.
	# It will go from its current value to 1.0 in 0.6 seconds.
	# The easing makes the animation start fast and end slow, which looks natural.
	tween.tween_property(tv_material, "shader_parameter/progress", 1.0, 0.6).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_SINE)
</file>

<file path="tv.tscn">
[gd_scene load_steps=6 format=3 uid="uid://b8abif6uqojn4"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_06tmt"]
[ext_resource type="Shader" uid="uid://cyp05p5euwm50" path="res://television_screen.gdshader" id="1_rlxh4"]
[ext_resource type="Texture2D" uid="uid://dqyuerm7dscue" path="res://tv_sprite.png" id="2_rlxh4"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_arbd3"]
shader = ExtResource("1_rlxh4")

[sub_resource type="RectangleShape2D" id="RectangleShape2D_arbd3"]
size = Vector2(474, 261)

[node name="television_screen" type="Area2D"]
script = ExtResource("1_06tmt")
object_display_name = "Television Screen"
object_id = "television_screen"
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="ObjectSprite" type="Sprite2D" parent="."]
material = SubResource("ShaderMaterial_arbd3")
texture = ExtResource("2_rlxh4")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(0, -0.5)
shape = SubResource("RectangleShape2D_arbd3")

[node name="WalkToPoint" type="Marker2D" parent="."]
</file>

<file path="ui_interactable.gd">
# UI_Interactable.gd
# Attach this script to the root TextureButton node.

extends TextureButton

# Get a reference to the child node that has all the real game logic.
# The '$' syntax is a shorthand way to get a direct child node.
@onready var interactable_logic: Interactable = $Interactable


func _ready():
	# When this UI button is pressed, call our custom function.
	pressed.connect(_on_button_pressed)

	# Connect the hover signals to keep your outline effect!
	# This forwards the UI hover event to the Interactable's existing functions.
	mouse_entered.connect(interactable_logic._on_mouse_entered)
	mouse_exited.connect(interactable_logic._on_mouse_exited)


func _on_button_pressed():
	# When clicked, tell the GameManager to process an interaction,
	# but pass in our child node, which has all the data and logic.
	if GameManager:
		GameManager.process_interaction_click(interactable_logic)
</file>

<file path="UI_Interactable.tscn">
[gd_scene load_steps=3 format=3 uid="uid://c4pi0l0rcx5jd"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="2_npg0b"]
[ext_resource type="Script" uid="uid://hm12uesh52vl" path="res://ui_interactable.gd" id="3_u7fb0"]

[node name="TextureButton" type="TextureButton"]
script = ExtResource("3_u7fb0")

[node name="Interactable" type="Area2D" parent="."]
script = ExtResource("2_npg0b")
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="Sprite2D" type="Sprite2D" parent="Interactable"]
</file>

<file path="verb_ui_2.gd">
# VerbUI.gd
# Refactored to manage a permanent, fixed set of 9 buttons.
extends CanvasLayer

# --- NODE REFERENCES ---
@onready var action_bubble_label: Label = %ActionBubbleLabel
@onready var verb_button_grid: GridContainer = %VerbGridContainer

# --- SCRIPT STATE ---
# An array to hold our 9 permanent button nodes.
var verb_buttons_array: Array[Button] = []
# An array to store the verb_id currently assigned to each button index.
var current_verb_ids: Array[String] = []
# A dictionary to quickly find a button by its verb_id for visual updates.
var active_verb_buttons: Dictionary = {} # Key: verb_id (String), Value: Button node


# --- GODOT BUILT-IN FUNCTIONS ---

func _ready():
	# --- NEW SETUP LOGIC ---
	# 1. Get all 9 buttons from the grid and store them.
	verb_buttons_array = verb_button_grid.get_children() as Array[Button]

	# Safety check
	if verb_buttons_array.size() != 9:
		printerr("VerbUI Error: Expected exactly 9 buttons in the GridContainer.")
		return

	# 2. Connect the 'pressed' signal for each button ONCE.
	for i in range(verb_buttons_array.size()):
		var button: Button = verb_buttons_array[i]
		# We bind the button's index (0-8) so we know which one was clicked.
		button.pressed.connect(_on_verb_button_pressed.bind(i))

	# Initialize the verb IDs array.
	current_verb_ids.resize(9)
	current_verb_ids.fill("")
	# --- END OF NEW SETUP ---

	# Connect to GameManager signals (this is unchanged)
	GameManager.available_verbs_changed.connect(_on_available_verbs_changed)
	GameManager.verb_changed.connect(_on_game_manager_verb_changed)
	GameManager.sentence_line_updated.connect(_on_game_manager_sentence_line_updated)
	GameManager.interaction_complete.connect(_on_interaction_complete)

	action_bubble_label.visible = false
	# Initially update the buttons to their default state
	_on_available_verbs_changed([])


func _process(_delta):
	if action_bubble_label.visible:
		action_bubble_label.global_position = get_viewport().get_mouse_position() + Vector2(15, 15)


# --- SIGNAL HANDLERS ---

func _on_available_verbs_changed(available_verb_data_array: Array[VerbData]):
	# --- COMPLETELY REWRITTEN LOGIC ---
	# This function no longer creates/deletes nodes. It just updates the 9 existing ones.

	active_verb_buttons.clear()

	for i in range(verb_buttons_array.size()): # Loop 0 through 8
		var button: Button = verb_buttons_array[i]

		# Is there a verb available for this button slot?
		if i < available_verb_data_array.size():
			var verb_data: VerbData = available_verb_data_array[i]
			button.text = verb_data.display_text
			button.disabled = false
			# Store the mapping for this active button
			current_verb_ids[i] = verb_data.verb_id
			active_verb_buttons[verb_data.verb_id] = button
		else:
			# This button slot has no verb; set it to a disabled, default state.
			button.text = "-"
			button.disabled = true
			current_verb_ids[i] = ""

	_update_button_selected_visual_state(GameManager.current_verb_id)


func _on_verb_button_pressed(button_index: int):
	# We receive the index (0-8) of the button that was pressed.
	var verb_id_pressed = current_verb_ids[button_index]

	# Only process the click if it's an active verb (not a disabled "-" button).
	if not verb_id_pressed.is_empty():
		GameManager.select_verb(verb_id_pressed)


# The rest of the functions work with the 'active_verb_buttons' dictionary,
# which is still being updated correctly, so they don't need to change.

func _on_game_manager_verb_changed(new_verb_id: String):
	if new_verb_id.is_empty():
		action_bubble_label.visible = false
	else:
		var verb_data = GameManager.get_verb_data_by_id(new_verb_id)
		action_bubble_label.text = verb_data.display_text + ":" if verb_data else new_verb_id + ":"
		action_bubble_label.visible = true

	_update_button_selected_visual_state(new_verb_id)


func _on_game_manager_sentence_line_updated(full_sentence: String):
	if not GameManager.current_verb_id.is_empty():
		action_bubble_label.text = full_sentence
		action_bubble_label.visible = true
	else:
		action_bubble_label.visible = false


func _on_interaction_complete():
	action_bubble_label.visible = false
	_update_button_selected_visual_state("")


func _update_button_selected_visual_state(selected_verb_id: String):
	for verb_id in active_verb_buttons:
		var button_node: Button = active_verb_buttons[verb_id]
		if is_instance_valid(button_node):
			button_node.modulate = Color.SKY_BLUE if verb_id == selected_verb_id else Color.WHITE
</file>

<file path="VerbUI2.tscn">
[gd_scene load_steps=2 format=3 uid="uid://dnjpbjvyhscp8"]

[ext_resource type="Script" uid="uid://cwgwv7i1sx5jn" path="res://verb_ui_2.gd" id="1_ut48v"]

[node name="VerbUI" type="CanvasLayer"]
script = ExtResource("1_ut48v")

[node name="UI_Root" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
scale = Vector2(10.3565, 1)

[node name="ActionsPanel_Container" type="MarginContainer" parent="UI_Root"]
custom_minimum_size = Vector2(960, 200)
layout_mode = 1
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -240.0
offset_right = 960.0
grow_vertical = 0
scale = Vector2(0.0872046, 1.03686)
theme_override_constants/margin_left = 20
theme_override_constants/margin_bottom = 20

[node name="VBoxContainer" type="VBoxContainer" parent="UI_Root/ActionsPanel_Container"]
layout_mode = 2

[node name="Label" type="Label" parent="UI_Root/ActionsPanel_Container/VBoxContainer"]
layout_mode = 2
text = "ACTIONS"

[node name="VerbGridContainer" type="GridContainer" parent="UI_Root/ActionsPanel_Container/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
columns = 3

[node name="Button" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button2" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button3" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button4" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button5" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button6" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button7" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button8" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"

[node name="Button9" type="Button" parent="UI_Root/ActionsPanel_Container/VBoxContainer/VerbGridContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "-"
</file>

<file path="aida.gd">
extends CharacterBody2D


# Add these variables at the top of Aida.gd
const ROOM_THRESHOLD_Y: float = 1000.0 # ADJUST THIS NUMBER to the Y coordinate of the floor between rooms
var _was_in_main_room: bool = true # To track state changes
var _is_interacting_with_me: bool = false

# --- References ---
@onready var animation_player: AnimationPlayer = $AnimationPlayer
@onready var interactable_component: Interactable = $InteractionArea
@onready var movement_controller: WaypointMovement = $MovementController

# --- Timers ---
var _resume_walk_timer: Timer

func _process(_delta):
	# Determine where she is currently based on Y height
	# Assuming Top Room (Main) is < 1000 and Bottom (Bathroom) is > 1000
	var is_currently_in_main = global_position.y < ROOM_THRESHOLD_Y
	
	# Only update the Game Manager if the state has CHANGED
	if is_currently_in_main != _was_in_main_room:
		_was_in_main_room = is_currently_in_main
		
		# Update the flag
		if GameManager:
			print("Aida: Crossed threshold. Entering %s." % ["Main Room" if is_currently_in_main else "Bathroom"])
			GameManager.set_current_level_flag("aida_in_main_room", is_currently_in_main)

func _ready():
	# 1. Setup the Resume Timer (Wait 5 seconds after talking)
	_resume_walk_timer = Timer.new()
	_resume_walk_timer.one_shot = true
	_resume_walk_timer.wait_time = 5.0
	add_child(_resume_walk_timer)
	_resume_walk_timer.timeout.connect(_on_resume_timer_timeout)

	# 2. Connect to the InteractionArea signals
	if interactable_component:
		# Triggered when player CLICKS (before reaching her)
		if not interactable_component.interaction_pending.is_connected(_on_interaction_pending):
			interactable_component.interaction_pending.connect(_on_interaction_pending)
		
		# Triggered when the action script (Talk To) says it's done spawning the dialogue
		if not interactable_component.interaction_processed.is_connected(_on_interaction_finished):
			interactable_component.interaction_processed.connect(_on_interaction_finished)

	# Listen for the global "Interaction Complete" signal from GameManager
	if GameManager:
		GameManager.interaction_complete.connect(_on_global_interaction_complete)
	# --- NEW CODE END ---
	
	# 3. Start default state
	if animation_player:
		animation_player.play("idle")

# --- SIGNAL HANDLERS ---

func _on_interaction_pending():
	print("Aida: Player clicked me. Stopping movement immediately.")
		# --- NEW LINE ---
	_is_interacting_with_me = true 
	# ----------------
	
	# Stop the resume timer if it was already counting down
	_resume_walk_timer.stop()
	
	# Pause movement logic
	if movement_controller:
		movement_controller.pause_movement()
	
	# Force idle animation
	if animation_player:
		animation_player.play("idle")

func _on_interaction_finished():
	# This function runs when the "Action" is technically done.
	# HOWEVER, if the action was "Open Overlay", this fires immediately, not when the overlay closes.
	
	# Check GameManager State: Are we in a full-screen conversation?
	if GameManager.current_interaction_state == GameManager.InteractionState.CONVERSATION:
		print("Aida: Interaction processed, but Player is in a Conversation Overlay. Holding position...")
		
		# Wait for the global signal that the conversation ended
		if not GameManager.character_conversation_ended.is_connected(_on_global_conversation_ended):
			GameManager.character_conversation_ended.connect(_on_global_conversation_ended, CONNECT_ONE_SHOT)
	else:
		# Not a generic conversation (maybe just a text bubble), start timer immediately
		_start_resume_countdown()

func _on_global_conversation_ended(_resource):
	print("Aida: Overlay closed. Now starting 5s cooldown.")
	_start_resume_countdown()

func _start_resume_countdown():
	# Ensure she is visible (safety check)
	visible = true
	modulate.a = 1.0
	
	print("Aida: Waiting 5 seconds...")
	_resume_walk_timer.start()

func _on_resume_timer_timeout():
	# Safety check: Don't resume if the player started talking to us AGAIN during the 5 seconds
	if GameManager.current_interaction_state == GameManager.InteractionState.CONVERSATION:
		print("Aida: Timer finished, but Player is talking again! aborting resume.")
		return
		
	print("Aida: 5 seconds passed. Resuming patrol.")
	if movement_controller:
		movement_controller.resume_movement()

func _on_global_interaction_complete():
	# If the interaction that just finished was with ME, then start the countdown
	if _is_interacting_with_me:
		print("Aida: Global interaction complete. Starting resume countdown.")
		_is_interacting_with_me = false # Reset the flag
		_start_resume_countdown()
</file>

<file path="balloon.gd">
extends CanvasLayer
## A basic dialogue balloon for use with Dialogue Manager.

## The action to use for advancing the dialogue
@export var next_action: StringName = &"ui_accept"

## The action to use to skip typing the dialogue
@export var skip_action: StringName = &"ui_cancel"

## The dialogue resource
var resource: DialogueResource

## Temporary game states
var temporary_game_states: Array = []

## See if we are waiting for the player
var is_waiting_for_input: bool = false

## See if we are running a long mutation and should hide the balloon
var will_hide_balloon: bool = false

## A dictionary to store any ephemeral variables
var locals: Dictionary = {}

var _locale: String = TranslationServer.get_locale()

## The current line
var dialogue_line: DialogueLine:
	set(value):
		if value:
			dialogue_line = value
			apply_dialogue_line()
		else:
			# The dialogue has finished so close the balloon
			queue_free()
	get:
		return dialogue_line

## A cooldown timer for delaying the balloon hide when encountering a mutation.
var mutation_cooldown: Timer = Timer.new()

## The base balloon anchor
@onready var balloon: Control = %Balloon

## The label showing the name of the currently speaking character
@onready var character_label: RichTextLabel = %CharacterLabel

## The label showing the currently spoken dialogue
@onready var dialogue_label: DialogueLabel = %DialogueLabel

## The menu of responses
@onready var responses_menu: DialogueResponsesMenu = %ResponsesMenu


func _ready() -> void:
	balloon.hide()
	Engine.get_singleton("DialogueManager").mutated.connect(_on_mutated)

	# If the responses menu doesn't have a next action set, use this one
	if responses_menu.next_action.is_empty():
		responses_menu.next_action = next_action

	mutation_cooldown.timeout.connect(_on_mutation_cooldown_timeout)
	add_child(mutation_cooldown)



func _unhandled_input(_event: InputEvent) -> void:
	# Only the balloon is allowed to handle input while it's showing
	get_viewport().set_input_as_handled()


func _notification(what: int) -> void:
	## Detect a change of locale and update the current dialogue line to show the new language
	if what == NOTIFICATION_TRANSLATION_CHANGED and _locale != TranslationServer.get_locale() and is_instance_valid(dialogue_label):
		_locale = TranslationServer.get_locale()
		var visible_ratio = dialogue_label.visible_ratio
		self.dialogue_line = await resource.get_next_dialogue_line(dialogue_line.id)
		if visible_ratio < 1:
			dialogue_label.skip_typing()


## Start some dialogue
func start(dialogue_resource: DialogueResource, title: String, extra_game_states: Array = []) -> void:
	temporary_game_states = [self] + extra_game_states
	is_waiting_for_input = false
	resource = dialogue_resource
	self.dialogue_line = await resource.get_next_dialogue_line(title, temporary_game_states)


## Apply any changes to the balloon given a new [DialogueLine].
func apply_dialogue_line() -> void:
	mutation_cooldown.stop()

	is_waiting_for_input = false
	balloon.focus_mode = Control.FOCUS_ALL
	balloon.grab_focus()

	character_label.visible = not dialogue_line.character.is_empty()
	character_label.text = tr(dialogue_line.character, "dialogue")

	dialogue_label.hide()
	dialogue_label.dialogue_line = dialogue_line

	responses_menu.hide()
	responses_menu.responses = dialogue_line.responses

	# Show our balloon
	balloon.show()
	will_hide_balloon = false

	dialogue_label.show()
	if not dialogue_line.text.is_empty():
		dialogue_label.type_out()
		await dialogue_label.finished_typing

	# Wait for input
	if dialogue_line.responses.size() > 0:
		balloon.focus_mode = Control.FOCUS_NONE
		responses_menu.show()
	elif dialogue_line.time != "":
		var time = dialogue_line.text.length() * 0.02 if dialogue_line.time == "auto" else dialogue_line.time.to_float()
		await get_tree().create_timer(time).timeout
		next(dialogue_line.next_id)
	else:
		is_waiting_for_input = true
		balloon.focus_mode = Control.FOCUS_ALL
		balloon.grab_focus()


## Go to the next line
func next(next_id: String) -> void:
	self.dialogue_line = await resource.get_next_dialogue_line(next_id, temporary_game_states)


#region Signals


func _on_mutation_cooldown_timeout() -> void:
	if will_hide_balloon:
		will_hide_balloon = false
		balloon.hide()


func _on_mutated(_mutation: Dictionary) -> void:
	is_waiting_for_input = false
	will_hide_balloon = true
	mutation_cooldown.start(0.1)


func _on_balloon_gui_input(event: InputEvent) -> void:
	# See if we need to skip typing of the dialogue
	if dialogue_label.is_typing:
		var mouse_was_clicked: bool = event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed()
		var skip_button_was_pressed: bool = event.is_action_pressed(skip_action)
		if mouse_was_clicked or skip_button_was_pressed:
			get_viewport().set_input_as_handled()
			dialogue_label.skip_typing()
			return

	if not is_waiting_for_input: return
	if dialogue_line.responses.size() > 0: return

	# When there are no response options the balloon itself is the clickable thing
	get_viewport().set_input_as_handled()

	# --- MODIFIED SECTION BELOW ---
	if event is InputEventMouseButton and event.is_pressed() and event.button_index == MOUSE_BUTTON_LEFT:
		# Play the sound when clicking to go next
		SoundManager.play_sfx("dialogue_advance")
		next(dialogue_line.next_id)

	elif event.is_action_pressed(next_action) and get_viewport().gui_get_focus_owner() == balloon:
		# Play the sound when pressing Space/Enter to go next
		SoundManager.play_sfx("dialogue_advance")
		next(dialogue_line.next_id)


func _on_responses_menu_response_selected(response: DialogueResponse) -> void:
	# Play the sound when clicking a choice button
	SoundManager.play_sfx("dialogue_advance")
	next(response.next_id)

# --- ADD THIS FUNCTION ---
func _on_dialogue_label_spoke(letter: String, letter_index: int, speed: float) -> void:
	# Don't play sound for spaces
	if letter == " ":
		return

	SoundManager.play_dialogue_blip()

#endregion
</file>

<file path="Boot.tscn">
[gd_scene load_steps=2 format=3 uid="uid://vmpt4xerpfew"]

[ext_resource type="Script" uid="uid://bxbrmshoh0egt" path="res://Boot.gd" id="1_6cbyf"]

[node name="Boot" type="Node"]
script = ExtResource("1_6cbyf")
</file>

<file path="camera_2d.gd">
# Attach this script to your Camera2D node in main.tscn
extends Camera2D

@export var target_path: NodePath
var target_node: Node2D

func _ready():
	if target_path:
		target_node = get_node_or_null(target_path)
	if not target_node:
		print_rich("[color=red]Camera target not found! Assign Player to Target Path.[/color]")

	# IMPORTANT: Enable these in the Inspector for the Camera2D node:
	# - Limit Left, Limit Top, Limit Right, Limit Bottom (set your values)
	# - Position Smoothing Enabled (set to true)
	# - Position Smoothing Speed (e.g., 5.0)

func _process(delta): # Or _physics_process, matching player
	if target_node:
		# Simply update the camera's position to the target.
		# Let the built-in limits and position smoothing handle the rest.
		global_position = target_node.global_position


# Add this to camera_2d.gd

func snap_to_target():
	if not target_node: return
	
	# 1. Disable smoothing temporarily
	var previous_smoothing = position_smoothing_enabled
	position_smoothing_enabled = false
	
	# 2. Force position update immediately
	global_position = target_node.global_position
	
	# 3. We need to wait for the physics engine to acknowledge the move
	# before turning smoothing back on, otherwise it might still jitter.
	await get_tree().process_frame
	
	# 4. Re-enable smoothing
	position_smoothing_enabled = previous_smoothing
</file>

<file path="ChapterButton.tscn">
[gd_scene load_steps=5 format=3 uid="uid://bn35sormknu1w"]

[ext_resource type="Theme" uid="uid://dwcpu0kxyu7pq" path="res://chapter_button.tres" id="1_fmhaq"]
[ext_resource type="Script" uid="uid://b242dhfjrtyue" path="res://ChapterButton.gd" id="1_v0ptq"]
[ext_resource type="Texture2D" uid="uid://dmy1iixmc7uvn" path="res://1080test1.jpg" id="3_3xave"]
[ext_resource type="FontFile" uid="uid://blg6ol8nf4fgs" path="res://RobotoMono-VariableFont_wght.ttf" id="3_v8c6v"]

[node name="ChapterButton" type="Button"]
custom_minimum_size = Vector2(180, 120)
anchors_preset = -1
anchor_right = 0.094
anchor_bottom = 0.111
offset_right = -180.48
offset_bottom = -119.88
theme = ExtResource("1_fmhaq")
script = ExtResource("1_v0ptq")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_top = 4

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2

[node name="TextureRect" type="TextureRect" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
texture = ExtResource("3_3xave")
expand_mode = 1
stretch_mode = 5

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(180, 20)
layout_mode = 2
theme_override_fonts/font = ExtResource("3_v8c6v")
text = "Chapter 1"
horizontal_alignment = 1
autowrap_mode = 3
</file>

<file path="DateInputWidget.gd">
# This script MUST extend Control.
extends Control

# --- THIS IS THE CRUCIAL FIX ---
# This code uses direct paths to the nodes shown in your screenshot.
# It is guaranteed to work with your scene structure.
@onready var d1: Control = $HBoxContainer/Day1
@onready var d2: Control = $HBoxContainer/Day2
@onready var m1: Control = $HBoxContainer/Month1
@onready var m2: Control = $HBoxContainer/Month2
@onready var y1: Control = $HBoxContainer/Year1
@onready var y2: Control = $HBoxContainer/Year2
@onready var y3: Control = $HBoxContainer/Year3
@onready var y4: Control = $HBoxContainer/Year4
# ---------------------------------

@onready var hbox_container: HBoxContainer = $HBoxContainer

func _ready():
	# This line fixes the layout/overlap issue.
	self.custom_minimum_size = hbox_container.get_combined_minimum_size()

func get_date_string() -> String:
	# Because the paths above are now correct, this function will work
	# without the "null instance" error.
	var day_str = str(d1.current_digit) + str(d2.current_digit)
	var month_str = str(m1.current_digit) + str(m2.current_digit)
	var year_str = str(y1.current_digit) + str(y2.current_digit) + str(y3.current_digit) + str(y4.current_digit)

	return "%s/%s/%s" % [day_str, month_str, year_str]
</file>

<file path="DateInputWidget.tscn">
[gd_scene load_steps=3 format=3 uid="uid://blho0mfhjkbi3"]

[ext_resource type="Script" uid="uid://cdprstfi6xb0c" path="res://DateInputWidget.gd" id="1_t7n42"]
[ext_resource type="PackedScene" uid="uid://b1jaqkwuy32ds" path="res://DigitSpinner.tscn" id="2_hhyfm"]

[node name="DateInputWidget" type="Control"]
layout_mode = 3
anchor_right = 0.27
anchor_bottom = 0.111
offset_right = -518.4
offset_bottom = -119.88
script = ExtResource("1_t7n42")

[node name="HBoxContainer" type="HBoxContainer" parent="."]
layout_mode = 0
offset_right = 40.0
offset_bottom = 40.0
theme_override_constants/separation = 10

[node name="Day1" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Day2" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Separator" type="Label" parent="HBoxContainer"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
theme_override_font_sizes/font_size = 35
text = "/"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Month1" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Month2" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Separator2" type="Label" parent="HBoxContainer"]
custom_minimum_size = Vector2(0, 120)
layout_mode = 2
theme_override_font_sizes/font_size = 35
text = "/"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Year1" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Year2" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Year3" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2

[node name="Year4" parent="HBoxContainer" instance=ExtResource("2_hhyfm")]
layout_mode = 2
</file>

<file path="DigitSpinner.gd">
# This script MUST extend "Control" because its root node is a Control node.
extends Control

# This signal is how the spinner communicates with the outside world.
# It will be used later if you want to validate the date as it's being entered.
signal digit_changed(new_digit: int)

# Get direct references to the nodes within this scene.
@onready var up_button: Button = $VBoxContainer/UpButton
@onready var down_button: Button = $VBoxContainer/DownButton
@onready var digit_label: Label = $VBoxContainer/DigitLabel

# This variable holds the "state" or current value of this spinner.
var current_digit: int = 0


# The _ready function runs once, when the node is first added to the scene.
# It's the perfect place for setup.
func _ready():
	# Set the label to its starting value.
	_update_label()
	# Connect the buttons' 'pressed' signals to our functions below.
	up_button.pressed.connect(_on_up_pressed)
	down_button.pressed.connect(_on_down_pressed)


# This function is called ONLY when the up_button is pressed.
func _on_up_pressed():
	# Increment the digit, wrapping from 9 back to 0 using the modulo operator.
	current_digit = (current_digit + 1) % 10
	# Update the visual text.
	_update_label()
	# Announce that the digit has changed and what its new value is.
	emit_signal("digit_changed", current_digit)


# This function is called ONLY when the down_button is pressed.
func _on_down_pressed():
	# Decrement the digit, wrapping from 0 back to 9.
	if current_digit == 0:
		current_digit = 9
	else:
		current_digit -= 1
	# Update the visual text.
	_update_label()
	# Announce that the digit has changed and what its new value is.
	emit_signal("digit_changed", current_digit)


# A helper function to avoid repeating the same line of code.
# It simply updates the Label's text to match our current_digit variable.
func _update_label():
	digit_label.text = str(current_digit)
</file>

<file path="DigitSpinner.tscn">
[gd_scene load_steps=2 format=3 uid="uid://b1jaqkwuy32ds"]

[ext_resource type="Script" uid="uid://dfswvmscs8ekj" path="res://DigitSpinner.gd" id="1_nc08d"]

[node name="DigitSpinner" type="Control"]
custom_minimum_size = Vector2(50, 120)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_nc08d")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="UpButton" type="Button" parent="VBoxContainer"]
layout_mode = 2
text = ""

[node name="DigitLabel" type="Label" parent="VBoxContainer"]
layout_mode = 2
size_flags_vertical = 6
text = "0"
horizontal_alignment = 1
vertical_alignment = 1

[node name="DownButton" type="Button" parent="VBoxContainer"]
layout_mode = 2
text = ""
</file>

<file path="explanation_data.gd">
# explanation_data.gd
extends Resource

class_name ExplanationData

## The node we want the spotlight to focus on.
@export var target_node_path: NodePath

## The lines of text that will be displayed one by one.
@export var explanation_lines: PackedStringArray

# You can still add more properties here later, like a title!
# @export var title: String
@export var exceptions_to_hide: Array[NodePath]
</file>

<file path="explanation_layer.gd">
extends CanvasLayer
signal explanation_finished
# --- Node References ---
@onready var color_rect: ColorRect = $ColorRect
@onready var explanation_label: Label = $PanelContainer/VBoxContainer/ExplanationLabel
@onready var next_button: Button = $PanelContainer/VBoxContainer/NextButton

# --- State Variables ---
var current_explanation_data: ExplanationData = null
var current_line_index: int = 0

func _ready():
	next_button.pressed.connect(_on_next_button_pressed)
	hide()

func show_explanation(data: ExplanationData, root_node: Node):
	if not data or data.explanation_lines.is_empty():
		print("Error: Invalid or empty explanation data provided.")
		return

	await get_tree().process_frame

	var target_node: Node = root_node.get_node_or_null(data.target_node_path)

	if is_instance_valid(target_node) and target_node is CanvasItem:
		# --- THIS IS THE KEY FIX ---
		# We now calculate the visual center of the node, not just its origin.
		# A CanvasItem has a 'size' from its get_rect() method.
		var node_size = target_node.get_rect().size
		var center_position = target_node.global_position + (node_size / 2.0)
		# --- END OF FIX ---

		var target_screen_pos: Vector2

		# If it's a UI element, its calculated center is already in screen space.
		if target_node is Control:
			target_screen_pos = center_position

		# If it's a world-space element, we convert the calculated center to screen space.
		elif target_node is Node2D:
			target_screen_pos = get_viewport().get_canvas_transform().affine_inverse() * center_position

		else:
			print_rich("[color=orange]Explanation Warning: Target node is an unsupported visual type. Defaulting to center.[/color]")
			target_screen_pos = get_viewport().get_visible_rect().size / 2

		update_spotlight_position(target_screen_pos)
	else:
		print_rich("[color=orange]Explanation Warning: Target node not found. Defaulting to screen center.[/color]")
		update_spotlight_position(get_viewport().get_visible_rect().size / 2)

	current_explanation_data = data
	current_line_index = 0

	_update_display()
	show()

func hide_explanation():
	current_explanation_data = null
	hide()
	# This new line tells anyone listening (our GameManager) that we are done.
	explanation_finished.emit()

# Replace your existing _on_next_button_pressed function to ensure the signal is emitted correctly.


func update_spotlight_position(pos: Vector2):
	if color_rect.material is ShaderMaterial:
		color_rect.material.set_shader_parameter("hole_position", pos)

func _update_display():
	explanation_label.text = current_explanation_data.explanation_lines[current_line_index]

	if current_line_index == current_explanation_data.explanation_lines.size() - 1:
		next_button.text = "Finish"
	else:
		next_button.text = "Next"

func _on_next_button_pressed():
	current_line_index += 1

	if current_line_index >= current_explanation_data.explanation_lines.size():
		# Instead of just hiding, we call our new function that also emits the signal.
		hide_explanation()
	else:
		_update_display()
</file>

<file path="explanation_layer.gdshader">
shader_type canvas_item;

uniform vec2 hole_position;
uniform float hole_size : hint_range(0.0, 1000.0) = 100.0;
uniform vec4 overlay_color : source_color = vec4(0.0, 0.0, 0.0, 0.7);

void fragment() {
    float distance = distance(FRAGCOORD.xy, hole_position);
    if (distance < hole_size) {
        COLOR.a = 0.0;
    } else {
        COLOR = overlay_color;
    }
}
</file>

<file path="explanation_layer.tscn">
[gd_scene load_steps=5 format=3 uid="uid://cymg2dkrvsnfy"]

[ext_resource type="Script" uid="uid://d3ir7s3bod0lc" path="res://explanation_layer.gd" id="1_3i43q"]
[ext_resource type="Shader" uid="uid://dqabfkkpedlvq" path="res://explanation_layer.gdshader" id="1_gkico"]
[ext_resource type="Theme" uid="uid://bo15lb6dkn0a2" path="res://Themes/general_theme.tres" id="3_iaxr3"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_3i43q"]
shader = ExtResource("1_gkico")
shader_parameter/hole_position = Vector2(0, 0)
shader_parameter/hole_size = 100.0
shader_parameter/overlay_color = Color(0, 0, 0, 0.7)

[node name="ExplanationLayer" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_3i43q")

[node name="ColorRect" type="ColorRect" parent="."]
material = SubResource("ShaderMaterial_3i43q")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.34902)

[node name="PanelContainer" type="PanelContainer" parent="."]
anchors_preset = -1
anchor_left = 0.236
anchor_top = 0.471
anchor_right = 0.763
anchor_bottom = 0.54
offset_left = 0.879974
offset_top = 0.319977
offset_right = 0.0400391
offset_bottom = -0.200012
size_flags_horizontal = 4
size_flags_vertical = 4
theme = ExtResource("3_iaxr3")

[node name="VBoxContainer" type="VBoxContainer" parent="PanelContainer"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="ExplanationLabel" type="Label" parent="PanelContainer/VBoxContainer"]
layout_mode = 2
theme = ExtResource("3_iaxr3")
text = "Explanation text goes here."
horizontal_alignment = 1

[node name="NextButton" type="Button" parent="PanelContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 4
text = "Next"
</file>

<file path="FallbackManager.gd">
# res://scripts/FallbackManager.gd
extends Node

const DEFAULT_CHECKPOINT_NAME = "start"

func trigger_fallback(verb_data: VerbData, object_id: String, item_id: String):
	if not is_instance_valid(verb_data):
		push_warning("FallbackManager: trigger_fallback was called with invalid VerbData.")
		return

	var fallback_resource = verb_data.fallback_dialogue_file
	if not is_instance_valid(fallback_resource):
		print_rich("[color=orange]FallbackManager: Verb '%s' has no fallback file assigned. No action taken.[/color]" % verb_data.verb_id)
		GameManager.interaction_complete.emit()
		return

	var checkpoint_to_use: String = _find_valid_checkpoint(fallback_resource, object_id, item_id)

	DialogueManager.dialogue_ended.connect(
		GameManager._on_dialogue_ended_for_object_dialogue,
		CONNECT_ONE_SHOT
	)

	print_rich("[color=cyan]FallbackManager: Triggering fallback dialogue from '%s' with checkpoint '%s'.[/color]" % [fallback_resource.resource_path, checkpoint_to_use])
	DialogueManager.show_dialogue_balloon(fallback_resource, checkpoint_to_use)


# This function now uses the correct method to check for checkpoints.
func _find_valid_checkpoint(resource: DialogueResource, object_id: String, item_id: String) -> String:
	# Level 1: Item + Object Combination
	if not item_id.is_empty():
		var item_specific_checkpoint = "%s_item_%s" % [object_id, item_id]
		# Use the confirmed method: check the 'titles' dictionary directly.
		if resource.titles.has(item_specific_checkpoint):
			print_rich("[color=green]FallbackManager: Found item-specific checkpoint: '%s'[/color]" % item_specific_checkpoint)
			return item_specific_checkpoint

	# Level 2: Object-Only
	if not object_id.is_empty():
		var object_specific_checkpoint = object_id
		if resource.titles.has(object_specific_checkpoint):
			print_rich("[color=green]FallbackManager: Found object-specific checkpoint: '%s'[/color]" % object_specific_checkpoint)
			return object_specific_checkpoint

	# Level 3: Generic Default
	print_rich("[color=yellow]FallbackManager: No specific checkpoint found. Using default: '%s'[/color]" % DEFAULT_CHECKPOINT_NAME)
	return DEFAULT_CHECKPOINT_NAME
</file>

<file path="have_more_logo.tscn">
[gd_scene load_steps=11 format=3 uid="uid://b7dat8bd2cm67"]

[ext_resource type="Texture2D" uid="uid://7etrb6a0mhdf" path="res://HavemoreLogoAnims/HavemoreLogo_0001.png" id="1_fwvy4"]
[ext_resource type="Texture2D" uid="uid://dtew73ad5g83k" path="res://HavemoreLogoAnims/HavemoreLogo_0002.png" id="2_0fhey"]
[ext_resource type="Texture2D" uid="uid://3gcd12thb3dt" path="res://HavemoreLogoAnims/HavemoreLogo_0004.png" id="3_wccbv"]
[ext_resource type="Texture2D" uid="uid://dqfhq24m0syoh" path="res://HavemoreLogoAnims/HavemoreLogo_0003.png" id="4_32ijw"]
[ext_resource type="Texture2D" uid="uid://bshe37846sx31" path="res://HavemoreLogoAnims/HavemoreLogo_0005.png" id="5_4bmte"]
[ext_resource type="Texture2D" uid="uid://2e3uap0gv3vs" path="res://HavemoreLogoAnims/HavemoreLogo_0006.png" id="6_sx0pc"]
[ext_resource type="Texture2D" uid="uid://bn4x835cqhyai" path="res://HavemoreLogoAnims/HavemoreLogo_0007.png" id="7_5r1u2"]
[ext_resource type="Texture2D" uid="uid://cstyl7n1n63qw" path="res://HavemoreLogoAnims/HavemoreLogo_0008.png" id="8_iwr3t"]
[ext_resource type="Texture2D" uid="uid://cabh6xj18bu6s" path="res://HavemoreLogoAnims/HavemoreLogo_0009.png" id="9_uytcx"]

[sub_resource type="SpriteFrames" id="SpriteFrames_3sbhv"]
animations = [{
"frames": [{
"duration": 1.5,
"texture": ExtResource("1_fwvy4")
}, {
"duration": 1.5,
"texture": ExtResource("2_0fhey")
}, {
"duration": 1.5,
"texture": ExtResource("3_wccbv")
}, {
"duration": 1.5,
"texture": ExtResource("4_32ijw")
}, {
"duration": 1.5,
"texture": ExtResource("5_4bmte")
}, {
"duration": 1.5,
"texture": ExtResource("6_sx0pc")
}, {
"duration": 1.5,
"texture": ExtResource("7_5r1u2")
}, {
"duration": 1.5,
"texture": ExtResource("8_iwr3t")
}, {
"duration": 1.5,
"texture": ExtResource("9_uytcx")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="HaveMoreLogo" type="Node2D"]

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="."]
sprite_frames = SubResource("SpriteFrames_3sbhv")
autoplay = "default"
frame_progress = 0.880328
</file>

<file path="insurance_form_button_ui.gd">
extends CanvasLayer

# This is the signal that the GameManager will listen for.
signal form_button_pressed

# Get a reference to the actual button node in the scene.
@onready var texture_button: TextureButton = $TextureButton


func _ready():
	# Connect the child button's 'pressed' signal to a function in THIS script.
	# We are essentially "listening" to our own child.
	texture_button.pressed.connect(_on_texture_button_pressed)


func _on_texture_button_pressed():
	# This function runs when the child button is clicked.
	print("The insurance form was clicked on! (Signal from inside the scene)")

	# Now, we emit our OWN signal to notify the outside world (like GameManager).
	# This is called "bubbling up" a signal.
	emit_signal("form_button_pressed")
</file>

<file path="insurance_form.gd">
extends CanvasLayer

signal field_submitted(field_id: String, value)
signal form_closed

# --- NEW, CORRECT NODE PATHS FOR YOUR ORGANIZED SCENE ---
# We get a reference to every single input and button.

# Inputs from LineEditContainer
@onready var first_name_edit: LineEdit = $TabletFrame/Padding/ContentCanvas/LineEditContainer/FirstName_Edit
@onready var middle_name_edit: LineEdit = $TabletFrame/Padding/ContentCanvas/LineEditContainer/MiddleName_Edit
@onready var last_name_edit: LineEdit = $TabletFrame/Padding/ContentCanvas/LineEditContainer/LastName_Edit
@onready var dob_edit: LineEdit = $TabletFrame/Padding/ContentCanvas/LineEditContainer/DOB_Edit # Now a LineEdit
@onready var phone_number_edit: LineEdit = $TabletFrame/Padding/ContentCanvas/LineEditContainer/PhoneNumber_Edit
@onready var account_number_edit: LineEdit = $TabletFrame/Padding/ContentCanvas/LineEditContainer/AccountNumber_Edit

# Buttons from ButtonContainer
@onready var first_name_button: Button = $TabletFrame/Padding/ContentCanvas/ButtonContainer/FirstName_Button
@onready var middle_name_button: Button = $TabletFrame/Padding/ContentCanvas/ButtonContainer/MiddleName_Button
@onready var last_name_button: Button = $TabletFrame/Padding/ContentCanvas/ButtonContainer/LastName_Button
@onready var dob_button: Button = $TabletFrame/Padding/ContentCanvas/ButtonContainer/DOB_Button
@onready var phone_number_button: Button = $TabletFrame/Padding/ContentCanvas/ButtonContainer/PhoneNumber_Button
@onready var account_number_button: Button = $TabletFrame/Padding/ContentCanvas/ButtonContainer/AccountNumber_Button

# The final submit button (renamed from close_button)
@onready var submit_button: Button = $TabletFrame/Padding/ContentCanvas/Submit_Button


func _ready():
	hide()
	# Connect every single button to its own function.
	first_name_button.pressed.connect(_on_first_name_submit)
	middle_name_button.pressed.connect(_on_middle_name_submit)
	last_name_button.pressed.connect(_on_last_name_submit)
	dob_button.pressed.connect(_on_dob_submit)
	phone_number_button.pressed.connect(_on_phone_number_submit)
	account_number_button.pressed.connect(_on_account_number_submit)

	submit_button.pressed.connect(_on_submit_form) # This is your old close button

# --- HANDLER FUNCTIONS FOR EACH "OKAY" BUTTON ---

func _on_first_name_submit():
	var value = first_name_edit.text
	emit_signal("field_submitted", "first_name", value)

func _on_middle_name_submit():
	var value = middle_name_edit.text
	emit_signal("field_submitted", "middle_name", value)

func _on_last_name_submit():
	var value = last_name_edit.text
	emit_signal("field_submitted", "last_name", value)

func _on_dob_submit():
	# This now gets the text from the LineEdit, not the date spinner.
	var value = dob_edit.text
	emit_signal("field_submitted", "date_of_birth", value)

func _on_phone_number_submit():
	var value = phone_number_edit.text
	emit_signal("field_submitted", "phone_number", value)

func _on_account_number_submit():
	var value = account_number_edit.text
	emit_signal("field_submitted", "account_number", value)

# --- HANDLER FOR THE FINAL SUBMIT/CLOSE BUTTON ---

func _on_submit_form():
	# This function simply closes the form.
	emit_signal("form_closed")
	queue_free()
</file>

<file path="insurance_form.tscn">
[gd_scene load_steps=7 format=3 uid="uid://cp46m7fekq0br"]

[ext_resource type="Script" uid="uid://b512h764u3gd2" path="res://insurance_form.gd" id="1_u10l7"]
[ext_resource type="Texture2D" uid="uid://bl3s30lkgiord" path="res://insurance form bg.png" id="3_a7jub"]
[ext_resource type="FontFile" uid="uid://dybhfcuqdaiov" path="res://hiragino-kaku-gothic-std-w8.otf" id="3_bhfgh"]
[ext_resource type="Theme" uid="uid://bxpy47r6xqv38" path="res://Themes/medfinance_theme.tres" id="4_oj0y3"]
[ext_resource type="Theme" uid="uid://e650fn5dy145" path="res://insurance_form_field_font.tres" id="5_yunj8"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_oj0y3"]
bg_color = Color(0.67, 0.1474, 0.15611, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4
expand_margin_left = 6.0
expand_margin_top = 6.0
expand_margin_right = 6.0
expand_margin_bottom = 6.0

[node name="InsuranceForm" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_u10l7")

[node name="ColorRect" type="ColorRect" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 0.392157)

[node name="TabletFrame" type="NinePatchRect" parent="."]
anchors_preset = -1
anchor_left = 0.182
anchor_top = 0.142
anchor_right = 0.826
anchor_bottom = 0.704556
offset_left = -0.440033
offset_top = -0.360001
offset_right = -0.920044
offset_bottom = 0.0799561
grow_horizontal = 2
grow_vertical = 2
texture = ExtResource("3_a7jub")
region_rect = Rect2(46.978, 52.8306, 2460.63, 1327.46)
metadata/_edit_use_anchors_ = true

[node name="Padding" type="MarginContainer" parent="TabletFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 30
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 30

[node name="ContentCanvas" type="Control" parent="TabletFrame/Padding"]
layout_mode = 2

[node name="HavemoreLabel" type="Label" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 2
anchor_left = 0.009
anchor_top = 0.022
anchor_right = 0.214
anchor_bottom = 0.089
offset_left = -0.34401
offset_top = -0.220994
offset_right = 0.575958
offset_bottom = 0.0630074
theme_override_fonts/font = ExtResource("3_bhfgh")
theme_override_font_sizes/font_size = 36
theme_override_styles/normal = SubResource("StyleBoxFlat_oj0y3")
text = "HAVEMORE"

[node name="Label2" type="Label" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 2
anchor_left = 0.226
anchor_top = 0.051
anchor_right = 0.34
anchor_bottom = 0.092
offset_left = 0.0580139
offset_top = -0.257999
offset_right = -0.00598145
offset_bottom = 0.273998
size_flags_vertical = 8
theme = ExtResource("4_oj0y3")
text = "MedFinance"

[node name="Label" type="Label" parent="TabletFrame/Padding/ContentCanvas"]
visible = false
layout_mode = 2
text = "Insurance Claim Form"
horizontal_alignment = 1

[node name="Subtitle" type="Label" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.238
anchor_top = 0.146
anchor_right = 0.804
anchor_bottom = 0.177
offset_left = 0.11203
offset_top = -6.008
offset_right = -0.504028
offset_bottom = 0.0039978
theme = ExtResource("5_yunj8")
text = "Please enter your credentials below to access your insurance account:"

[node name="LabelsContainer" type="VBoxContainer" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.132
anchor_top = 0.234
anchor_right = 0.383
anchor_bottom = 0.77
offset_left = -0.0999756
offset_top = -0.23201
offset_right = -0.0249939
offset_bottom = 0.039978
theme_override_constants/separation = 37

[node name="FirstName_Label" type="Label" parent="TabletFrame/Padding/ContentCanvas/LabelsContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
text = "First Name:"

[node name="MiddleName_Label" type="Label" parent="TabletFrame/Padding/ContentCanvas/LabelsContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
text = "Middle Name:"

[node name="LastName_Label" type="Label" parent="TabletFrame/Padding/ContentCanvas/LabelsContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
text = "Last Name:"

[node name="DOB_Label" type="Label" parent="TabletFrame/Padding/ContentCanvas/LabelsContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
text = "Date of Birth:"

[node name="PhoneNumber_Label" type="Label" parent="TabletFrame/Padding/ContentCanvas/LabelsContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
text = "Phone Number:"

[node name="AccountNumber_Label" type="Label" parent="TabletFrame/Padding/ContentCanvas/LabelsContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
text = "Account Number:"

[node name="LineEditContainer" type="VBoxContainer" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.328
anchor_top = 0.23
anchor_right = 0.719
anchor_bottom = 0.768
offset_left = -0.399994
offset_top = -0.0400009
offset_right = 0.174927
offset_bottom = 0.135986
theme_override_constants/separation = 22

[node name="FirstName_Edit" type="LineEdit" parent="TabletFrame/Padding/ContentCanvas/LineEditContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
placeholder_text = "Enter First Name...."

[node name="MiddleName_Edit" type="LineEdit" parent="TabletFrame/Padding/ContentCanvas/LineEditContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
placeholder_text = "Enter Middle Name..."

[node name="LastName_Edit" type="LineEdit" parent="TabletFrame/Padding/ContentCanvas/LineEditContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
placeholder_text = "Enter Last Name..."

[node name="DOB_Edit" type="LineEdit" parent="TabletFrame/Padding/ContentCanvas/LineEditContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
placeholder_text = "Enter Date of Birth..."

[node name="PhoneNumber_Edit" type="LineEdit" parent="TabletFrame/Padding/ContentCanvas/LineEditContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
placeholder_text = "Enter Phone Number..."

[node name="AccountNumber_Edit" type="LineEdit" parent="TabletFrame/Padding/ContentCanvas/LineEditContainer"]
layout_mode = 2
theme = ExtResource("5_yunj8")
placeholder_text = "Enter Account Number..."

[node name="ButtonContainer" type="VBoxContainer" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.751
anchor_top = 0.223
anchor_right = 0.894
anchor_bottom = 0.776
offset_left = 0.574951
offset_top = -0.204002
offset_right = 0.549927
offset_bottom = -0.248016
theme_override_constants/separation = 35

[node name="FirstName_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas/ButtonContainer"]
layout_mode = 2
theme = ExtResource("4_oj0y3")
text = "Okay"

[node name="MiddleName_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas/ButtonContainer"]
layout_mode = 2
theme = ExtResource("4_oj0y3")
text = "Okay"

[node name="LastName_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas/ButtonContainer"]
layout_mode = 2
theme = ExtResource("4_oj0y3")
text = "Okay"

[node name="DOB_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas/ButtonContainer"]
layout_mode = 2
theme = ExtResource("4_oj0y3")
text = "Okay"

[node name="PhoneNumber_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas/ButtonContainer"]
layout_mode = 2
theme = ExtResource("4_oj0y3")
text = "Okay"

[node name="AccountNumber_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas/ButtonContainer"]
layout_mode = 2
theme = ExtResource("4_oj0y3")
text = "Okay"

[node name="Submit_Button" type="Button" parent="TabletFrame/Padding/ContentCanvas"]
layout_mode = 2
anchor_left = 0.49
anchor_top = 0.861
anchor_right = 0.533
anchor_bottom = 0.918
offset_left = 0.25
offset_top = 0.171967
offset_right = -0.275085
offset_bottom = -0.0640259
theme = ExtResource("4_oj0y3")
text = "Submit"
</file>

<file path="interactions/actions/AddItemAction.gd">
# res://interactions/actions/AddItemAction.gd
class_name AddItemAction
extends Action

@export var item_id_to_add: String = ""


# CHANGE THIS LINE: from "-> void" to "-> bool"
func execute(interactable_node: Interactable) -> bool:
	if item_id_to_add.is_empty():
		push_warning("AddItemAction executed on '%s' with an empty item_id." % interactable_node.object_display_name)
		return true # Also return true here for consistency

	interactable_node.request_add_item_to_inventory.emit(item_id_to_add)
	print_rich("[color=cyan]AddItemAction: Requested to add item '%s' to inventory.[/color]" % item_id_to_add)

	# This line is now valid because the function is declared to return a bool.
	return true
</file>

<file path="interactions/actions/CallMethodAction.gd">
# res://interactions/actions/CallMethodAction.gd
class_name CallMethodAction
extends Action

## A path to the node you want to call a function on.
@export var target_node_path: NodePath

## The name of the function to call on the target node.
@export var method_name: String = ""

## An array of arguments (optional) to pass to the function.
@export var arguments: Array


func execute(interactable_node: Interactable) -> bool:
	if target_node_path.is_empty() or method_name.is_empty():
		push_warning("CallMethodAction on '%s' is not configured correctly." % interactable_node.object_display_name)
		return true

	# Get the target node. The path is relative to the interactable that is
	# running this action. This is flexible and powerful.
	var target_node = interactable_node.get_node_or_null(target_node_path)

	if not is_instance_valid(target_node):
		push_warning("CallMethodAction on '%s' could not find the target node at path: %s" % [interactable_node.object_display_name, target_node_path])
		return true

	if not target_node.has_method(method_name):
		push_warning("CallMethodAction: Target node '%s' does not have method '%s'." % [target_node.name, method_name])
		return true

	# Call the method on the target node, passing the arguments.
	# callv is used to call a method with an array of arguments.
	target_node.callv(method_name, arguments)
	print_rich("[color=cyan]CallMethodAction: Called method '%s' on node '%s'[/color]" % [method_name, target_node.name])
	return true
</file>

<file path="interactions/actions/DestroyAction.gd">
# res://interactions/actions/DestroyAction.gd
class_name DestroyAction
extends Action

## An optional message to display just before the object is destroyed.
@export var message_on_destroy: String = ""


func execute(interactable_node: Interactable) -> bool:
	if not message_on_destroy.is_empty():
		interactable_node.display_dialogue.emit(message_on_destroy)

	# This logic is copied directly from your old _execute_action_details function.
	# It handles the special case where the interactable might be inside a UI
	# element (like a TextureButton) in a zoom view.
	var parent_node = interactable_node.get_parent()
	if parent_node is TextureButton:
		print_rich("[color=cyan]DestroyAction: Destroying parent TextureButton wrapper for '%s'.[/color]" % interactable_node.object_display_name)
		parent_node.queue_free()
		return true
	else:
		# If it's not in a UI wrapper, we just ask the Interactable to destroy itself.
		# We use the existing signal to ensure a clean, deferred removal.
		print_rich("[color=cyan]DestroyAction: Requesting self-destruction for '%s'.[/color]" % interactable_node.object_display_name)
		interactable_node.self_destruct_requested.emit()
		return true
</file>

<file path="interactions/actions/OpenZoomViewAction.gd">
# res://interactions/actions/OpenZoomViewAction.gd
class_name OpenZoomViewAction
extends Action

# This action is simple and needs no exported variables. It uses the
# PackedScene that is already configured on the Interactable itself.

func execute(interactable_node: Interactable) -> bool:
	# First, check if the Interactable has a zoom scene assigned.
	if interactable_node.object_zoom_overlay_scene:
		# Tell the GameManager to prepare for the zoom state.
		if GameManager:
			GameManager.enter_zoom_view_state()

		# Instantiate the scene and add it to the tree.
		var zoom_instance = interactable_node.object_zoom_overlay_scene.instantiate()
		interactable_node.get_tree().root.add_child(zoom_instance)

		print_rich("[color=cyan]OpenZoomViewAction: Opened zoom view for '%s'.[/color]" % interactable_node.object_display_name)

		# VERY IMPORTANT: Return false to stop the interaction cycle.
		# This prevents the UI from resetting while the zoom view is open.
		return false
	else:
		# If no scene is assigned, print an error and continue normally.
		push_warning("OpenZoomViewAction failed: No 'object_zoom_overlay_scene' assigned to '%s'." % interactable_node.object_display_name)
		interactable_node.display_dialogue.emit("It doesn't seem to open.")
		return true
</file>

<file path="interactions/actions/RemoveItemAction.gd">
# res://interactions/actions/RemoveItemAction.gd
class_name RemoveItemAction
extends Action

## The unique ID of the item to remove from the player's inventory.
@export var item_id_to_remove: String = ""


func execute(interactable_node: Interactable) -> bool:
	if item_id_to_remove.is_empty():
		push_warning("RemoveItemAction executed on '%s' with an empty item_id." % interactable_node.object_display_name)
		return true

	# We use the interactable_node to emit the existing signal that the
	# GameManager is already set up to listen for.
	interactable_node.request_remove_item_from_inventory.emit(item_id_to_remove)
	print_rich("[color=cyan]RemoveItemAction: Requested to remove item '%s' from inventory.[/color]" % item_id_to_remove)
	return true
</file>

<file path="interactions/actions/SayLineAction.gd">
# res://interactions/actions/SayLineAction.gd
class_name SayLineAction
extends Action

## The line of dialogue for the character to say.
@export var line_to_say: String = "..."


# Override the base execute method with specific logic for this action.
func execute(interactable_node: Interactable) -> bool:
	# We have access to the interactable that is running this action.
	# We can use it to emit its `display_dialogue` signal, which the
	# GameManager is already set up to listen for.
	interactable_node.display_dialogue.emit(line_to_say)
	return true
</file>

<file path="interactions/actions/ShowCustomDialogueAction.gd">
# res://interactions/actions/ShowCustomDialogueAction.gd
class_name ShowCustomDialogueAction
extends Action

@export var dialogue_resource: DialogueResource
@export var dialogue_checkpoint: String = ""

# Define the specific balloon scene
const BALLOON_SCENE_PATH = "res://conversationballoon.tscn"

# Change return type to Variant to allow 'await' to work correctly
func execute(interactable_node: Interactable) -> Variant:
	if not dialogue_resource or dialogue_checkpoint.is_empty():
		push_warning("ShowCustomDialogueAction is not configured correctly.")
		return true

	# 1. Start the dialogue using the CUSTOM SCENE
	# We use show_dialogue_balloon_scene to force our styled balloon
	DialogueManager.show_dialogue_balloon_scene(
		BALLOON_SCENE_PATH, 
		dialogue_resource, 
		dialogue_checkpoint
	)

	# 2. Wait for completion
	# We await the signal so the Action List pauses here.
	# (We do NOT connect to GameManager cleanup here, because Interactable.gd 
	# handles the cleanup after the whole list of actions is finished).
	await DialogueManager.dialogue_ended
	
	# 3. Return true to signal the Action List to continue (e.g. play sounds next)
	return true
</file>

<file path="interactions/actions/ShowDialogueActiont.gd">
# res://interactions/actions/ShowDialogueAction.gd
class_name ShowDialogueAction
extends Action

@export var dialogue_resource: DialogueResource = preload("res://examinables.dialogue")

# Define the specific balloon scene to ensure visual consistency
const BALLOON_SCENE_PATH = "res://conversationballoon.tscn"

func execute(interactable_node: Interactable) -> bool:
	# --- Safety Checks ---
	if not dialogue_resource:
		push_warning("ShowDialogueAction on '%s' has no DialogueResource assigned." % interactable_node.object_display_name)
		return true

	if not DialogueManager:
		push_warning("DialogueManager autoload not found.")
		return true

	if not GameManager:
		push_warning("GameManager autoload not found.")
		return true

	if interactable_node.object_id.is_empty():
		push_warning("Interactable '%s' has an empty object_id." % interactable_node.object_display_name)

	# --- Connect Signal to GameManager ---
	# This ensures UI is restored and player is unpaused when dialogue closes.
	DialogueManager.dialogue_ended.connect(
		GameManager._on_dialogue_ended_for_object_dialogue,
		CONNECT_ONE_SHOT
	)

	# --- Core Logic ---
	var target_object_id: String = interactable_node.object_id

	print_rich("[color=cyan]ShowDialogueAction: Showing custom balloon for '%s'[/color]" % target_object_id)

	# USE THE CUSTOM SCENE instead of the default project setting
	DialogueManager.show_dialogue_balloon_scene(
		BALLOON_SCENE_PATH, 
		dialogue_resource, 
		target_object_id
	)
	
	return true
</file>

<file path="interactions/actions/StartConversationAction.gd">
# res://interactions/actions/StartConversationAction.gd
class_name StartConversationAction
extends Action

# This action is very simple and requires no exported variables.
# It intelligently uses the "character_conversation_overlay_scene"
# that is already assigned on the Interactable itself.

func execute(interactable_node: Interactable) -> bool:
	# First, check if the Interactable has a conversation scene assigned.
	if interactable_node.character_conversation_overlay_scene:
		# Safety check for the GameManager.
		if not GameManager:
			push_warning("GameManager not found. Cannot enter conversation state.")
			return true # Fail gracefully, continue interaction cycle.

		# Tell the GameManager to hide the main UI and prepare for the conversation.
		GameManager.enter_conversation_state()

		# Instantiate the scene and add it to the root of the tree.
		var conversation_instance = interactable_node.character_conversation_overlay_scene.instantiate()
		interactable_node.get_tree().root.add_child(conversation_instance)

		# The old GameManager logic connected a signal to know when the conversation
		# was done. We must replicate that here to ensure the UI comes back!
		# We connect to the existing function on the GameManager.
		if conversation_instance.has_signal("conversation_finished"):
			conversation_instance.conversation_finished.connect(
				GameManager._on_character_conversation_finished,
				CONNECT_ONE_SHOT
			)

		print_rich("[color=cyan]StartConversationAction: Launched conversation for '%s'.[/color]" % interactable_node.object_display_name)

		# VERY IMPORTANT: Return false to stop the interaction cycle.
		# This leaves the game in the "conversation" state.
		return false
	else:
		# If no scene is assigned, the character can't talk.
		push_warning("StartConversationAction failed: No 'character_conversation_overlay_scene' assigned to '%s'." % interactable_node.object_display_name)
		# We can use the simple dialogue system for a fallback line.
		interactable_node.display_dialogue.emit("They don't seem to have much to say.")
		return true # Return true because the interaction is "over".
</file>

<file path="logo_splash.tscn">
[gd_scene load_steps=6 format=3 uid="uid://b8uah06h8o6v"]

[ext_resource type="FontFile" uid="uid://dp4mppnkvijv" path="res://CherryBomb-Regular.ttf" id="1_l8pnb"]
[ext_resource type="Script" uid="uid://duejqbmx520g" path="res://LogoSplash.gd" id="1_lh0uv"]

[sub_resource type="Animation" id="Animation_aj0d6"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}

[sub_resource type="Animation" id="Animation_l6s3m"]
resource_name = "splash_animation"
length = 3.0
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.5, 2, 2.5),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [Color(1, 1, 1, 0), Color(1, 1, 1, 1), Color(1, 1, 1, 1), Color(1, 1, 1, 0)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_vw2qx"]
_data = {
&"RESET": SubResource("Animation_aj0d6"),
&"splash_animation": SubResource("Animation_l6s3m")
}

[node name="LogoSplash" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_lh0uv")

[node name="BackgroundRect" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="LogoLabel" type="RichTextLabel" parent="."]
layout_mode = 1
anchors_preset = 14
anchor_top = 0.5
anchor_right = 1.0
anchor_bottom = 0.5
offset_top = -25.0
offset_right = -0.0849609
offset_bottom = 57.645
grow_horizontal = 2
grow_vertical = 2
theme_override_fonts/normal_font = ExtResource("1_l8pnb")
theme_override_font_sizes/normal_font_size = 80
bbcode_enabled = true
text = "[center][color=#FF007F]LEW[/color][color=#000000]GEN[/color][color=#FF007F]D[/color][/center]"

[node name="LogoAnimator" type="AnimationPlayer" parent="LogoLabel"]
libraries = {
&"": SubResource("AnimationLibrary_vw2qx")
}
autoplay = "splash_animation"
</file>

<file path="LogoSplash.gd">
# LogoSplash.gd
extends Control

# Define a signal that this scene will emit when it's done.
signal splash_finished

# Get a reference to the AnimationPlayer that animates your logo.
# I'm assuming it's named "LogoAnimator" based on your screenshot.
@onready var logo_animator: AnimationPlayer = $LogoLabel/LogoAnimator

func _ready():
	# Connect to the AnimationPlayer's "animation_finished" signal.
	# When the animation is done, we'll call our own function.
	logo_animator.animation_finished.connect(_on_animation_finished)

	# Start playing the logo animation (assuming it's named "play_logo")
	logo_animator.play("splash_animation")

func _on_animation_finished(_anim_name: String):
	# The animation is done. Now we emit our custom signal.
	splash_finished.emit()

	# And finally, remove the splash screen from the game.
	queue_free()
</file>

<file path="mcbucket_hyper_conversation.tscn">
[gd_scene load_steps=7 format=3 uid="uid://ba560cukc85ql"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_ximbx"]
[ext_resource type="Resource" uid="uid://cv8to4jygkg5i" path="res://mcbucket_default_dialogue.dialogue" id="2_lbsgd"]
[ext_resource type="Texture2D" uid="uid://ij27xt1yb7y3" path="res://sergei.PNG" id="3_pkhah"]
[ext_resource type="Texture2D" uid="uid://dy3ncsp5fixia" path="res://Protag.png" id="4_3gkl1"]
[ext_resource type="Texture2D" uid="uid://cg86pt8j73x3m" path="res://mcbucket.png" id="5_8ds7v"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_pkhah")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
layer = 2
script = ExtResource("1_ximbx")
conversation_dialogue_file = ExtResource("2_lbsgd")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_3gkl1")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(957, 540.5)
scale = Vector2(0.497917, 0.498611)
texture = ExtResource("5_8ds7v")

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6
</file>

<file path="mcbucket_sleeping_conversation.tscn">
[gd_scene load_steps=7 format=3 uid="uid://c1wbgb5hjkicp"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_qdrsu"]
[ext_resource type="Resource" uid="uid://cv8to4jygkg5i" path="res://mcbucket_default_dialogue.dialogue" id="2_ixdtd"]
[ext_resource type="Texture2D" uid="uid://ij27xt1yb7y3" path="res://sergei.PNG" id="3_b5wws"]
[ext_resource type="Texture2D" uid="uid://dy3ncsp5fixia" path="res://Protag.png" id="4_s6kqq"]
[ext_resource type="Texture2D" uid="uid://cg86pt8j73x3m" path="res://mcbucket.png" id="5_81dsl"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_b5wws")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
layer = 2
script = ExtResource("1_qdrsu")
conversation_dialogue_file = ExtResource("2_ixdtd")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_s6kqq")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(957, 540.5)
scale = Vector2(0.497917, 0.498611)
texture = ExtResource("5_81dsl")

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6
</file>

<file path="MemoryBoxOverlay.tscn">
[gd_scene load_steps=19 format=3 uid="uid://dxh3iucevq7uw"]

[ext_resource type="Script" uid="uid://3ljv44t6bc3i" path="res://MemoryBoxOverlay.gd" id="1_nw7nd"]
[ext_resource type="Theme" uid="uid://dn3c6kdmu6tyb" path="res://memorybox.tres" id="1_rxlxx"]
[ext_resource type="Script" uid="uid://coccmochs1n0s" path="res://MemoryGroupData.gd" id="2_2chyr"]
[ext_resource type="StyleBox" uid="uid://dxdc82o7pmbig" path="res://memoryboxbackbutton.tres" id="2_ut4ol"]
[ext_resource type="FontFile" uid="uid://blg6ol8nf4fgs" path="res://RobotoMono-VariableFont_wght.ttf" id="3_2j1ub"]
[ext_resource type="ButtonGroup" uid="uid://hfwad7vwdjea" path="res://story_spicy_button_group.tres" id="3_kaas7"]
[ext_resource type="Resource" uid="uid://dstoitdqjd6hj" path="res://location_university.tres" id="3_myt65"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_ut4ol"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_kaas7"]
bg_color = Color(0.537255, 0.866667, 1, 0.196078)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_2j1ub"]
bg_color = Color(0.537255, 0.866667, 1, 0.392157)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(1, 1, 1, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_kaas7"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_nw7nd"]
bg_color = Color(0.537255, 0.866667, 1, 0.117647)
border_width_left = 1
border_width_top = 1
border_width_bottom = 1
border_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_left = 15
corner_radius_bottom_left = 15

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_xqacp"]
bg_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_left = 15
corner_radius_bottom_left = 15

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_qkydy"]
bg_color = Color(0.6, 0.6, 0.6, 0)
border_width_left = 1
border_width_top = 1
border_width_bottom = 1
border_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_left = 15
corner_radius_bottom_left = 15

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_2j1ub"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_xhuc4"]
bg_color = Color(0.537255, 0.866667, 1, 0.117647)
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_right = 15
corner_radius_bottom_right = 15

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_2chyr"]
bg_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_right = 15
corner_radius_bottom_right = 15

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_myt65"]
bg_color = Color(0.6, 0.6, 0.6, 0)
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.537255, 0.866667, 1, 1)
corner_radius_top_right = 15
corner_radius_bottom_right = 15

[node name="MemoryBoxOverlay" type="CanvasLayer"]
script = ExtResource("1_nw7nd")
all_memory_data = Array[ExtResource("2_2chyr")]([ExtResource("3_myt65")])

[node name="ColorRect" type="ColorRect" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.101961, 0.109804, 0.172549, 1)

[node name="Panel" type="Panel" parent="."]
anchors_preset = -1
anchor_left = 0.019
anchor_top = 0.051
anchor_right = 0.981
anchor_bottom = 0.939
offset_left = 0.519997
offset_top = -0.0800018
offset_right = 0.479858
offset_bottom = -0.120056
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("1_rxlxx")

[node name="TitleLabel" type="Label" parent="Panel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.405
anchor_top = 0.028
anchor_right = 0.611
anchor_bottom = 0.088
offset_left = -0.0350342
offset_top = 0.148001
offset_right = 0.483032
offset_bottom = -0.391998
theme_override_colors/font_shadow_color = Color(0.537255, 0.866667, 1, 0.588235)
theme_override_font_sizes/font_size = 30
text = "M E M O R Y  B O X"
horizontal_alignment = 1

[node name="BackButton" type="Button" parent="Panel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.022
anchor_top = 0.029
anchor_right = 0.058
anchor_bottom = 0.084
offset_left = -0.633991
offset_top = 0.189009
offset_right = 0.874008
offset_bottom = 0.444008
theme_override_font_sizes/font_size = 38
theme_override_styles/focus = SubResource("StyleBoxEmpty_ut4ol")
theme_override_styles/hover = SubResource("StyleBoxFlat_kaas7")
theme_override_styles/pressed = SubResource("StyleBoxFlat_2j1ub")
theme_override_styles/normal = ExtResource("2_ut4ol")
text = "<"

[node name="TabContainer" type="HBoxContainer" parent="Panel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.451
anchor_top = 0.103
anchor_right = 0.564
anchor_bottom = 0.186
offset_left = 0.00299072
offset_top = 0.223
offset_right = -88.708
offset_bottom = -0.373993
theme_override_constants/separation = -1

[node name="StoryButton" type="Button" parent="Panel/TabContainer"]
layout_mode = 2
theme_override_fonts/font = ExtResource("3_2j1ub")
theme_override_styles/focus = SubResource("StyleBoxEmpty_kaas7")
theme_override_styles/hover = SubResource("StyleBoxFlat_nw7nd")
theme_override_styles/pressed = SubResource("StyleBoxFlat_xqacp")
theme_override_styles/normal = SubResource("StyleBoxFlat_qkydy")
toggle_mode = true
button_pressed = true
button_group = ExtResource("3_kaas7")
text = " Story   "

[node name="SpicyButton" type="Button" parent="Panel/TabContainer"]
layout_mode = 2
theme_override_fonts/font = ExtResource("3_2j1ub")
theme_override_styles/focus = SubResource("StyleBoxEmpty_2j1ub")
theme_override_styles/hover = SubResource("StyleBoxFlat_xhuc4")
theme_override_styles/pressed = SubResource("StyleBoxFlat_2chyr")
theme_override_styles/normal = SubResource("StyleBoxFlat_myt65")
toggle_mode = true
button_group = ExtResource("3_kaas7")
text = " Spicy  "

[node name="ScrollContainer" type="ScrollContainer" parent="Panel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.026
anchor_top = 0.194
anchor_right = 0.979
anchor_bottom = 0.967
offset_left = -0.0219994
offset_top = -0.0460052
offset_right = 0.786987
offset_bottom = -0.353088

[node name="LocationListContainer" type="VBoxContainer" parent="Panel/ScrollContainer"]
clip_contents = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 20
</file>

<file path="MemoryChapterData.gd">
# MemoryChapterData.gd
class_name MemoryChapterData
extends Resource

## The name of the chapter displayed on the button.
@export var chapter_name: String = "Chapter Title"

## The image displayed on the button.
@export var chapter_image: Texture2D

## The scene that will be loaded when this chapter is selected.
@export var scene_path_to_load: String = ""

## The GameManager flag that must be 'true' for this chapter to be unlocked.
## If empty, the chapter is unlocked by default.
@export var unlock_flag: String = ""
</file>

<file path="MemoryGroupData.gd">
# MemoryGroupData.gd
class_name MemoryGroupData
extends Resource

## Defines whether this group belongs in the "Story" or "Spicy" tab.
enum MemoryCategory { STORY, SPICY }

## The name of the group (e.g., "University", "Faye").
@export var group_name: String = "Location Name"

## The image for the location/group.
@export var group_image: Texture2D

## The category this group will be displayed under.
@export var category: MemoryCategory = MemoryCategory.STORY

## An array that holds all the chapter data resources for this group.
@export var chapters: Array[MemoryChapterData] = []
</file>

<file path="Notification.gd">
# Notification.gd
extends PanelContainer

# Set the duration for the notification
const DURATION = 5.0 # 5 seconds

@onready var label = $Label
@onready var timer = $Timer

# This function is called by the NotificationManager to set up the notification
func show_message(text: String):
	label.text = text
	timer.wait_time = DURATION
	timer.start()

# This function is called when the Timer finishes its countdown
func _on_timer_timeout():
	# Optional: You can add a fade-out animation here using a Tween
	# For now, we will just remove the notification from the scene
	queue_free()
</file>

<file path="Notification.tscn">
[gd_scene load_steps=3 format=3 uid="uid://c3ide4uljt8hs"]

[ext_resource type="Theme" uid="uid://bo15lb6dkn0a2" path="res://Themes/general_theme.tres" id="1_017wr"]
[ext_resource type="Script" uid="uid://dsvh3fnvh8lt8" path="res://Notification.gd" id="1_rer52"]

[node name="Notification" type="PanelContainer"]
offset_right = 1.0
offset_bottom = 23.0
theme = ExtResource("1_017wr")
script = ExtResource("1_rer52")

[node name="Label" type="Label" parent="."]
layout_mode = 2
theme_override_font_sizes/font_size = 24

[node name="Timer" type="Timer" parent="."]

[connection signal="timeout" from="Timer" to="." method="_on_timer_timeout"]
</file>

<file path="NotificationManager.gd">
# NotificationManager.gd
extends CanvasLayer

const NOTIFICATION_SCENE = preload("res://Notification.tscn")

@onready var notification_container = $NotificationContainer

func _ready():
	GameManager.notification_requested.connect(add_notification)

func add_notification(message: String):
	# --- ADD THIS LINE ---
	# Play the sound effect as soon as a notification is requested.
	SoundManager.play_sfx("notification_ping")
	# --------------------

	# Create a new instance of our Notification scene
	var notification_instance = NOTIFICATION_SCENE.instantiate()

	# Add it to the VBoxContainer. The container will handle positioning.
	notification_container.add_child(notification_instance)

	# Set the message on the new notification instance.
	notification_instance.show_message(message)
</file>

<file path="NotificationManager.tscn">
[gd_scene load_steps=2 format=3 uid="uid://ff07w20q21uo"]

[ext_resource type="Script" uid="uid://u132a54bhi87" path="res://NotificationManager.gd" id="1_7jvge"]

[node name="NotificationManager" type="CanvasLayer"]
layer = 10
script = ExtResource("1_7jvge")

[node name="NotificationContainer" type="VBoxContainer" parent="."]
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -161.18
offset_top = 56.54
offset_right = -121.18
offset_bottom = 96.54
grow_horizontal = 0
</file>

<file path="sergei_med_dispenser.tscn">
[gd_scene load_steps=4 format=3 uid="uid://dg2mtprp1wybv"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_4a56b"]
[ext_resource type="Texture2D" uid="uid://faqm8qmqqx3f" path="res://med dispenser.png" id="2_a2hnt"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(293, 370)

[node name="SergeiMedicineDispenser" type="Area2D"]
script = ExtResource("1_4a56b")
object_display_name = "Medicine Dispenser"
object_id = "sergei_medicine_dispenser"

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_a2hnt")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(13.5, -192)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)
</file>

<file path="static_wall_background.tscn">
[gd_scene load_steps=2 format=3 uid="uid://d3c3oshbfjh6w"]

[ext_resource type="Texture2D" uid="uid://dldvj1j53uooh" path="res://Backgrounds/Levels/static_hospital_background.PNG" id="1_ewx0a"]

[node name="StaticWallBackground" type="Node2D"]

[node name="WallTile1" type="Sprite2D" parent="."]
texture = ExtResource("1_ewx0a")
centered = false
</file>

<file path="table.tscn">
[gd_scene format=3 uid="uid://d2jpsne6k1xfa"]

[node name="Node2D" type="ColorRect"]
anchors_preset = -1
anchor_right = 1.0
anchor_bottom = 0.064
offset_bottom = -0.120003
grow_horizontal = 2
size_flags_horizontal = 3
size_flags_vertical = 3
color = Color(0.946587, 0.962104, 0.984834, 1)
</file>

<file path="test_box.tscn">
[gd_scene load_steps=14 format=3 uid="uid://bpk8g8k1r5vb6"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_i5csg"]
[ext_resource type="Script" uid="uid://bmq0s1nqhqi4j" path="res://InteractionResponse.gd" id="2_faxy5"]
[ext_resource type="Texture2D" uid="uid://cfkvy6v701sh1" path="res://icon.svg" id="2_po7q6"]
[ext_resource type="Script" uid="uid://dltqnu07oiff" path="res://action.gd" id="3_gyrdm"]
[ext_resource type="Script" uid="uid://bapryqa2s86c5" path="res://interactions/actions/SayLineAction.gd" id="4_yy0q5"]
[ext_resource type="Script" uid="uid://nvyqoryt5sbh" path="res://interactions/actions/AddItemAction.gd" id="5_gyrdm"]
[ext_resource type="Script" uid="uid://c5bw6trnybm71" path="res://interactions/actions/DestroyAction.gd" id="6_yy0q5"]

[sub_resource type="Resource" id="Resource_hgn4j"]
script = ExtResource("4_yy0q5")
line_to_say = "I am examining a box!"
metadata/_custom_type_script = "uid://bapryqa2s86c5"

[sub_resource type="Resource" id="Resource_0qfd0"]
script = ExtResource("2_faxy5")
verb_id = "examine"
required_item_id = ""
actions_to_perform = Array[ExtResource("3_gyrdm")]([SubResource("Resource_hgn4j"), null])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_yy0q5"]
script = ExtResource("5_gyrdm")
item_id_to_add = "test_box"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_d6e5j"]
script = ExtResource("6_yy0q5")
message_on_destroy = ""
metadata/_custom_type_script = "uid://c5bw6trnybm71"

[sub_resource type="Resource" id="Resource_ppfqe"]
script = ExtResource("2_faxy5")
verb_id = "pickup"
required_item_id = ""
actions_to_perform = Array[ExtResource("3_gyrdm")]([SubResource("Resource_yy0q5"), SubResource("Resource_d6e5j")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="RectangleShape2D" id="RectangleShape2D_buv8t"]
size = Vector2(127, 127)

[node name="TestBox" type="Area2D"]
script = ExtResource("1_i5csg")
object_display_name = "Test Box"
object_id = "test_box"
interactions = Array[ExtResource("2_faxy5")]([SubResource("Resource_0qfd0"), SubResource("Resource_ppfqe")])

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = ExtResource("2_po7q6")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-0.5, -0.5)
shape = SubResource("RectangleShape2D_buv8t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(1, 63)
</file>

<file path="WaypointMovement.gd">
# WaypointMovement.gd
class_name WaypointMovement
extends Node

# --- Configuration ---
@export var enabled: bool = true
@export var movement_speed: float = 50.0
@export var wait_duration: float = 2.0 

@export var waypoints: Array[NodePath]

enum LoopType { ONE_SHOT, LOOP, PING_PONG }
@export var loop_type: LoopType = LoopType.LOOP

# --- Internal State ---
var _target_node: CharacterBody2D
var _animation_player: AnimationPlayer
var _sprite_2d: Sprite2D 
var _current_waypoint_index: int = 0
var _is_waiting: bool = false
var _ping_pong_direction: int = 1

var _wait_timer: Timer

func _ready():
	if not enabled or get_parent() == null or waypoints.is_empty():
		set_physics_process(false)
		return

	_target_node = get_parent()
	if not _target_node is CharacterBody2D:
		set_physics_process(false)
		return

	_animation_player = _target_node.get_node_or_null("AnimationPlayer")
	
	# Try to find the sprite
	_sprite_2d = _target_node.get_node_or_null("Sprite")
	if not _sprite_2d:
		_sprite_2d = _target_node.get_node_or_null("ObjectSprite")

	_wait_timer = Timer.new()
	_wait_timer.wait_time = wait_duration
	_wait_timer.one_shot = true
	add_child(_wait_timer)
	_wait_timer.timeout.connect(_on_wait_timer_timeout)

func _physics_process(delta: float):
	if _is_waiting:
		return

	var target_marker: Marker2D = get_node_or_null(waypoints[_current_waypoint_index])
	if not target_marker:
		set_physics_process(false)
		return

	var target_position = target_marker.global_position

	if _target_node.global_position.distance_to(target_position) < 5.0:
		_handle_arrival()
	else:
		_move_towards(target_position)

func _handle_arrival():
	_target_node.velocity = Vector2.ZERO 
	
	if _animation_player: 
		_animation_player.play("idle")

	_is_waiting = true
	_wait_timer.start()

	if loop_type == LoopType.PING_PONG:
		_current_waypoint_index += _ping_pong_direction
		if _current_waypoint_index >= waypoints.size() or _current_waypoint_index < 0:
			_ping_pong_direction *= -1
			_current_waypoint_index += _ping_pong_direction * 2
	else:
		_current_waypoint_index += 1

	if _current_waypoint_index >= waypoints.size():
		if loop_type == LoopType.ONE_SHOT:
			enabled = false
			set_physics_process(false)
			return
		elif loop_type == LoopType.LOOP:
			_current_waypoint_index = 0

func _move_towards(target_position: Vector2):
	var direction = _target_node.global_position.direction_to(target_position)
	_target_node.velocity = direction * movement_speed
	_target_node.move_and_slide()

	if _animation_player and _animation_player.current_animation != "walk":
		_animation_player.play("walk")

	if _sprite_2d:
		if _target_node.velocity.x > 0.1:
			_sprite_2d.flip_h = false 
		elif _target_node.velocity.x < -0.1:
			_sprite_2d.flip_h = true

func _on_wait_timer_timeout():
	_is_waiting = false 

# --- NEW PUBLIC FUNCTIONS FOR AIDA TO CONTROL ---
func pause_movement():
	set_physics_process(false) # Stops the _physics_process loop
	_wait_timer.paused = true  # Pauses the waypoint wait timer if it was running
	if _target_node:
		_target_node.velocity = Vector2.ZERO
	if _animation_player:
		_animation_player.play("idle")

func resume_movement():
	_wait_timer.paused = false # Unpauses the timer
	set_physics_process(true)  # Resumes the loop
	
# --- CUTSCENE CONTROL ---

# This function is a "Coroutine". We can 'await' it!
func move_to_position_async(target_pos: Vector2, stop_distance: float = 5.0, timeout: float = 8.0) -> void:
	pause_movement()
	
	print_rich("[color=orange]AidaMove: START. From %s to %s. Timeout: %ss[/color]" % [_target_node.global_position, target_pos, timeout])
	
	var start_time = Time.get_ticks_msec()
	var arrived = false
	
	while not arrived:
		if not is_instance_valid(_target_node): return

		# --- DEBUGGING EVERY SECOND ---
		# We use modulo to print only occasionally, otherwise console floods
		if Time.get_ticks_msec() % 1000 < 20: 
			var dist = _target_node.global_position.distance_to(target_pos)
			print("AidaMove: Dist: %.2f | Velocity: %s | TargetY: %.2f vs MyY: %.2f" % [dist, _target_node.velocity, target_pos.y, _target_node.global_position.y])

		# 1. CHECK TIMEOUT (The Safety Net)
		var elapsed = (Time.get_ticks_msec() - start_time) / 1000.0
		if elapsed > timeout:
			print_rich("[color=red]AidaMove: TIMEOUT! Force teleporting.[/color]")
			_target_node.global_position = target_pos
			arrived = true
			break

		# 2. CALCULATE HORIZONTAL DISTANCE ONLY (The Logic Fix)
		# We only care about X distance, ignoring Y height differences
		var x_distance = abs(_target_node.global_position.x - target_pos.x)
		
		if x_distance <= stop_distance:
			arrived = true
			_target_node.velocity = Vector2.ZERO
			if _animation_player: _animation_player.play("idle")
			print_rich("[color=green]AidaMove: Arrived at X coordinate.[/color]")
		else:
			# 3. MOVE HORIZONTALLY ONLY
			# Determine direction: 1.0 (Right) or -1.0 (Left)
			var direction_x = sign(target_pos.x - _target_node.global_position.x)
			
			# Apply velocity only to X. Leave Y alone (or apply gravity if needed)
			_target_node.velocity.x = direction_x * movement_speed
			_target_node.velocity.y = 0 # Or apply gravity here if she needs it
			
			_target_node.move_and_slide()
			
			if _animation_player and _animation_player.current_animation != "walk":
				_animation_player.play("walk")
			
			if _sprite_2d:
				if _target_node.velocity.x > 0.1: _sprite_2d.flip_h = false
				elif _target_node.velocity.x < -0.1: _sprite_2d.flip_h = true
		
		await get_tree().physics_frame
		
func set_target_waypoint_index(index: int):
	if waypoints.is_empty(): return
	
	# Clamp ensures we don't crash if you give a bad number
	_current_waypoint_index = clamp(index, 0, waypoints.size() - 1)
	print("WaypointMovement: Manually reset target to waypoint index %s" % _current_waypoint_index)
</file>

<file path="action.gd">
# res://interactions/Action.gd
class_name Action
extends Resource

# CHANGE: Removed "-> bool" and replaced with "-> Variant"
# This allows the function to handle both instant returns AND async "await" returns.
func execute(interactable_node: Interactable) -> Variant:
	push_warning("An Action resource did not override the execute() method!")
	# Return true by default.
	return true
</file>

<file path="ChapterButton.gd">
# ChapterButton.gd
extends Button

# This signal is emitted when the button is pressed, sending its own data along.
signal chapter_selected(data: MemoryChapterData)

# --- NODE REFERENCES ---
@onready var chapter_name_label: Label = $MarginContainer/VBoxContainer/Label
@onready var chapter_image_rect: TextureRect = $MarginContainer/VBoxContainer/TextureRect

# --- DATA ---
var chapter_data: MemoryChapterData
func _ready():
	# Connect our own "pressed" signal to a handler function.
	self.pressed.connect(_on_pressed)

func _on_pressed():
	# When this button is pressed, emit our custom signal,
	# passing our own chapter_data along with it.
	emit_signal("chapter_selected", chapter_data)

## This function takes MemoryChapterData and configures the button's UI.
func populate(data: MemoryChapterData):
	self.chapter_data = data

	# --- 1. SET THE VISUALS ---
	chapter_name_label.text = chapter_data.chapter_name
	chapter_image_rect.texture = chapter_data.chapter_image

	# --- 2. HANDLE LOCKED/UNLOCKED STATE ---
	# Check if the chapter has a flag that needs to be checked.
	if not chapter_data.unlock_flag.is_empty():
		# Ask the GameManager if the flag is true or false.
		var is_unlocked = GameManager.get_game_flag(chapter_data.unlock_flag)

		if not is_unlocked:
			# If the chapter is locked, make it look disabled.
			self.disabled = true
			# Modulate makes the button and its children look grayed out.
			self.modulate = Color(0.5, 0.5, 0.5, 1.0)

	# If there's no unlock_flag, the button is unlocked by default,
	# so we don't need to do anything.
</file>

<file path="insurance_form_button_ui.tscn">
[gd_scene load_steps=3 format=3 uid="uid://cn3wt8p41equ0"]

[ext_resource type="Script" uid="uid://ccgy2wd4maav6" path="res://insurance_form_button_ui.gd" id="1_2vgf4"]
[ext_resource type="Texture2D" uid="uid://6rxirp1vpl7s" path="res://Icons/insurance_form_icon.png" id="2_2vgf4"]

[node name="InsuranceFormButtonUI" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_2vgf4")

[node name="TextureButton" type="TextureButton" parent="."]
anchors_preset = -1
anchor_left = 0.8
anchor_top = 0.81100005
anchor_right = 0.87600005
anchor_bottom = 0.97900003
offset_top = 0.11993408
offset_right = -0.92004395
offset_bottom = -0.32006836
pivot_offset = Vector2(76, 78.0001)
texture_normal = ExtResource("2_2vgf4")
ignore_texture_size = true
stretch_mode = 0
</file>

<file path="interactions/actions/SetLevelFlagAction.gd">
# res://interactions/actions/SetLevelFlagAction.gd
class_name SetLevelFlagAction
extends Action

@export var flag_name: String = ""
@export var flag_value: bool = true

func execute(_interactable_node: Interactable) -> Variant:
	if flag_name == "":
		push_warning("SetLevelFlagAction: No flag_name specified.")
		return true

	if GameManager:
		# This calls the function you already set up in GameManager
		# which routes it to the current LevelStateManager
		GameManager.set_current_level_flag(flag_name, flag_value)
		print("Action: Set Level Flag '%s' to %s" % [flag_name, str(flag_value)])
	
	return true
</file>

<file path="LocationRow.gd">
# LocationRow.gd
extends HBoxContainer
# This signal relays the message from a ChapterButton up to the main overlay.
signal chapter_selected(data: MemoryChapterData)

# --- NODE REFERENCES ---
# We need to get references to the parts of our scene that we want to change.
@onready var location_name_label: Label = $LocationInfoPanel/VBoxContainer/Label
@onready var location_image_rect: TextureRect = $LocationInfoPanel/VBoxContainer/TextureRect
@onready var chapter_list_container: HBoxContainer = $ChaptersAreaPanel/HBoxContainer/ViewportPanel/ChapterListContainer
@onready var left_arrow_button: Button = $ChaptersAreaPanel/HBoxContainer/LeftArrowButton
@onready var right_arrow_button: Button = $ChaptersAreaPanel/HBoxContainer/RightArrowButton

# --- PRELOADS ---
# We need to load the ChapterButton scene so we can create instances of it.
const ChapterButtonScene = preload("res://ChapterButton.tscn") # <-- IMPORTANT: Verify this path!

# --- SCROLLING VARIABLES ---
@export var scroll_speed: float = 0.5 # How long the scroll animation takes.
var _target_scroll_x: float = 0.0 # The target X position for our container.
var _is_scrolling: bool = false   # A flag to prevent spamming the scroll buttons.

# --- DATA ---
# This variable will hold the MemoryGroupData resource for this row.
var memory_data: MemoryGroupData


func _ready():
	# Connect the arrow buttons' "pressed" signals to functions in this script.
	left_arrow_button.pressed.connect(_on_left_arrow_pressed)
	right_arrow_button.pressed.connect(_on_right_arrow_pressed)


## This function takes a MemoryGroupData resource and configures the row's UI.
func populate(data: MemoryGroupData):
	# Store the data for later use.
	self.memory_data = data

	# --- 1. SET LOCATION INFO ---
	# Set the text and texture for the left-side panel.
	location_name_label.text = memory_data.group_name
	location_image_rect.texture = memory_data.group_image

	# --- 2. CLEAR ANY EXISTING CHAPTERS ---
	# This is important for when we switch tabs (Story/Spicy).
	for child in chapter_list_container.get_children():
		child.queue_free()

	# --- 3. CREATE NEW CHAPTER BUTTONS ---
	# Loop through the chapter data in our resource.
	for chapter_data in memory_data.chapters:
		# Create a new instance of our template scene.
		var new_chapter_button = ChapterButtonScene.instantiate()
		# Add the new button to our HBoxContainer.
		chapter_list_container.add_child(new_chapter_button)
		# Call the populate function on the new button and pass it the data.
		new_chapter_button.populate(chapter_data)

		# Listen for the button's signal and connect it to a relay function.
		new_chapter_button.chapter_selected.connect(_on_chapter_button_selected)

	# After creating the buttons, update the arrow visibility.
	_update_arrow_state()


func _update_arrow_state():
	# Wait until the next idle frame. This is more reliable than the physics frame
	# for UI size calculations after adding new nodes.
	await get_tree().process_frame

	var viewport_panel = $ChaptersAreaPanel/HBoxContainer/ViewportPanel
	var viewport_width = viewport_panel.size.x
	var content_width = chapter_list_container.size.x

	# --- CORE LOGIC FIX ---
	# The maximum distance the content can scroll is its total width minus the visible width.
	# We use max(0, ...) to ensure this isn't negative if the content is smaller.
	var max_scroll = max(0.0, content_width - viewport_width)

	# Disable the left button if we are at the beginning (or can't scroll at all).
	# Use a small tolerance to handle floating point inaccuracies.
	left_arrow_button.disabled = (_target_scroll_x >= -1.0)

	# Disable the right button if we have reached the end (or can't scroll at all).
	right_arrow_button.disabled = (_target_scroll_x <= -max_scroll + 1.0)

func _on_left_arrow_pressed():
	# Don't do anything if we are already scrolling or the button is disabled.
	if _is_scrolling or left_arrow_button.disabled: return

	var viewport_width = $ChaptersAreaPanel/HBoxContainer/ViewportPanel.size.x
	# Move the target position to the right (less negative) by one "page".
	_target_scroll_x = min(0.0, _target_scroll_x + viewport_width)
	_animate_scroll()

func _on_chapter_button_selected(data: MemoryChapterData):
	# When we hear a signal from a chapter button, we just pass it up the chain.
	emit_signal("chapter_selected", data)

func _on_right_arrow_pressed():
	# Don't do anything if we are already scrolling or the button is disabled.
	if _is_scrolling or right_arrow_button.disabled: return

	var viewport_width = $ChaptersAreaPanel/HBoxContainer/ViewportPanel.size.x
	var content_width = chapter_list_container.size.x

	# Only calculate max_scroll if there's actually something to scroll.
	var max_scroll = 0.0
	if content_width > viewport_width:
		max_scroll = content_width - viewport_width

	# Move the target position to the left (more negative) by one "page".
	# Use max() to ensure we don't scroll past the end of the content.
	_target_scroll_x = max(-max_scroll, _target_scroll_x - viewport_width)
	_animate_scroll()


## This function performs the actual animation.
func _animate_scroll():
	_is_scrolling = true

	# Create a new Tween (Godot's animation tool).
	var tween = create_tween()
	# Tell it to animate the 'position:x' property of our chapter container.
	tween.tween_property(chapter_list_container, "position:x", _target_scroll_x, scroll_speed)\
		 .set_trans(Tween.TRANS_SINE)\
		 .set_ease(Tween.EASE_OUT)

	# When the animation is finished, update state and button visibility.
	await tween.finished
	_is_scrolling = false
	_update_arrow_state()
</file>

<file path="LocationRow.tscn">
[gd_scene load_steps=10 format=3 uid="uid://btapuvtuo8pu6"]

[ext_resource type="Script" uid="uid://dxg1w2hmijjfa" path="res://LocationRow.gd" id="1_d7ebr"]
[ext_resource type="StyleBox" uid="uid://dxdc82o7pmbig" path="res://memoryboxbackbutton.tres" id="1_uocnp"]
[ext_resource type="FontFile" uid="uid://blg6ol8nf4fgs" path="res://RobotoMono-VariableFont_wght.ttf" id="2_3w4a0"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_uocnp"]
content_margin_left = 8.0
content_margin_top = 8.0
content_margin_right = 8.0
content_margin_bottom = 8.0
bg_color = Color(0.133333, 0.141176, 0.2, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_d7ebr"]
content_margin_left = 8.0
content_margin_top = 8.0
content_margin_right = 8.0
content_margin_bottom = 8.0
bg_color = Color(0.133333, 0.141176, 0.2, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_d7ebr"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_3w4a0"]
bg_color = Color(0.6, 0.6, 0.6, 0)
border_width_left = 1
border_width_top = 1
border_width_right = 1
border_width_bottom = 1
border_color = Color(0.376471, 0.376471, 0.376471, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_uocnp"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_3w4a0"]

[node name="LocationRow" type="HBoxContainer"]
anchors_preset = -1
anchor_right = 1.0
anchor_bottom = 0.139
offset_bottom = -0.12001
size_flags_horizontal = 3
script = ExtResource("1_d7ebr")

[node name="LocationInfoPanel" type="PanelContainer" parent="."]
custom_minimum_size = Vector2(220, 150)
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_uocnp")

[node name="VBoxContainer" type="VBoxContainer" parent="LocationInfoPanel"]
layout_mode = 2

[node name="TextureRect" type="TextureRect" parent="LocationInfoPanel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 5

[node name="Label" type="Label" parent="LocationInfoPanel/VBoxContainer"]
layout_mode = 2
theme_override_fonts/font = ExtResource("2_3w4a0")
text = "Location 1"
horizontal_alignment = 1
vertical_alignment = 1

[node name="ChaptersAreaPanel" type="PanelContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3
theme_override_styles/panel = SubResource("StyleBoxFlat_d7ebr")

[node name="HBoxContainer" type="HBoxContainer" parent="ChaptersAreaPanel"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="LeftArrowButton" type="Button" parent="ChaptersAreaPanel/HBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 44
theme_override_styles/focus = SubResource("StyleBoxEmpty_d7ebr")
theme_override_styles/disabled = SubResource("StyleBoxFlat_3w4a0")
theme_override_styles/normal = ExtResource("1_uocnp")
text = "  <  "

[node name="ViewportPanel" type="Panel" parent="ChaptersAreaPanel/HBoxContainer"]
clip_contents = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_styles/panel = SubResource("StyleBoxEmpty_uocnp")

[node name="ChapterListContainer" type="HBoxContainer" parent="ChaptersAreaPanel/HBoxContainer/ViewportPanel"]
layout_mode = 1
anchors_preset = -1
anchor_right = 0.995
anchor_bottom = 0.963
offset_right = -0.360107
offset_bottom = -0.0420074
theme_override_constants/separation = 50

[node name="RightArrowButton" type="Button" parent="ChaptersAreaPanel/HBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 44
theme_override_styles/focus = SubResource("StyleBoxEmpty_3w4a0")
theme_override_styles/disabled = SubResource("StyleBoxFlat_3w4a0")
theme_override_styles/normal = ExtResource("1_uocnp")
text = "  >  "
</file>

<file path="main_menu.tscn">
[gd_scene load_steps=7 format=3 uid="uid://bj3w6acg6sb7g"]

[ext_resource type="Script" uid="uid://ctc8mysw5ic3e" path="res://MainMenu.gd" id="1_jix8l"]
[ext_resource type="Texture2D" uid="uid://dj36rtbdioqh3" path="res://Backgrounds/Game Images/Template Background 2.jpg" id="2_glbon"]
[ext_resource type="FontFile" uid="uid://6fxwb86ujy6q" path="res://Fonts/IBMPlexSans-SemiBold.ttf" id="3_nlkkf"]
[ext_resource type="FontFile" uid="uid://b1iquuxsqnjah" path="res://Fonts/RubikGlitch-Regular.ttf" id="4_qe12f"]

[sub_resource type="Gradient" id="Gradient_eiy7p"]
colors = PackedColorArray(0, 0, 0, 0, 0, 0, 0, 0.85882354)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_h7a2f"]
gradient = SubResource("Gradient_eiy7p")
fill = 1
fill_from = Vector2(0.5, 0.5)
fill_to = Vector2(1, 0.5)

[node name="MainMenu" type="CanvasLayer"]
script = ExtResource("1_jix8l")

[node name="Content" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Background" type="TextureRect" parent="Content"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = ExtResource("2_glbon")
expand_mode = 1
stretch_mode = 6

[node name="Vignette" type="TextureRect" parent="Content"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = SubResource("GradientTexture2D_h7a2f")

[node name="TitleBlock" type="VBoxContainer" parent="Content"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.05
anchor_top = 0.70000005
anchor_right = 0.5
anchor_bottom = 0.95100003
offset_top = -6.1035156e-05
offset_bottom = -0.080078125

[node name="Label" type="Label" parent="Content/TitleBlock"]
layout_mode = 2
theme_override_colors/font_color = Color(0.9411765, 0.9411765, 0.9411765, 1)
theme_override_fonts/font = ExtResource("3_nlkkf")
theme_override_font_sizes/font_size = 71
text = "I F   I   R E M E M B E R"

[node name="Label2" type="Label" parent="Content/TitleBlock"]
layout_mode = 2
theme_override_colors/font_color = Color(0.5921569, 0.8627451, 0.92156863, 1)
theme_override_fonts/font = ExtResource("4_qe12f")
theme_override_font_sizes/font_size = 122
text = "CORRECTLY"

[node name="ButtonBlock" type="VBoxContainer" parent="Content"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.6
anchor_top = 0.4
anchor_right = 0.89100003
anchor_bottom = 0.606
offset_right = -0.7200928
offset_bottom = 0.52001953
theme_override_constants/separation = 15
alignment = 1

[node name="StartButton" type="Button" parent="Content/ButtonBlock"]
layout_mode = 2
focus_mode = 0
mouse_default_cursor_shape = 2
theme_override_colors/font_color = Color(0.93333334, 0.93333334, 0.93333334, 1)
theme_override_colors/font_pressed_color = Color(0.2684, 0.4335066, 0.61, 1)
theme_override_colors/font_hover_color = Color(0.5921569, 0.8627451, 0.92156863, 1)
theme_override_fonts/font = ExtResource("3_nlkkf")
theme_override_font_sizes/font_size = 36
text = "START DEMO"
flat = true
alignment = 2

[node name="QuitButton" type="Button" parent="Content/ButtonBlock"]
layout_mode = 2
focus_mode = 0
mouse_default_cursor_shape = 2
theme_override_colors/font_color = Color(0.93333334, 0.93333334, 0.93333334, 1)
theme_override_colors/font_pressed_color = Color(0.2684, 0.4335066, 0.61, 1)
theme_override_colors/font_hover_color = Color(0.5921569, 0.8627451, 0.92156863, 1)
theme_override_fonts/font = ExtResource("3_nlkkf")
theme_override_font_sizes/font_size = 36
text = "QUIT
"
flat = true
alignment = 2

[connection signal="pressed" from="Content/ButtonBlock/StartButton" to="." method="_on_new_game_button_pressed"]
[connection signal="pressed" from="Content/ButtonBlock/StartButton" to="." method="_on_start_button_pressed"]
[connection signal="pressed" from="Content/ButtonBlock/QuitButton" to="." method="_on_quit_button_pressed"]
</file>

<file path="mcbucket_default_conversation.tscn">
[gd_scene load_steps=7 format=3 uid="uid://ckc058if0px63"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_pa1l3"]
[ext_resource type="Resource" uid="uid://cv8to4jygkg5i" path="res://mcbucket_default_dialogue.dialogue" id="2_nv1g7"]
[ext_resource type="Texture2D" uid="uid://cx4r1a1ci7vpj" path="res://sergei.PNG" id="3_w54lt"]
[ext_resource type="Texture2D" uid="uid://coo5k2phjvc1e" path="res://Protag.png" id="4_qktef"]
[ext_resource type="Texture2D" uid="uid://bsc4qxo3h14qh" path="res://Backgrounds/McBucket/default/mcbucket_normal_base.png" id="5_1ebgl"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_w54lt")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
layer = 2
script = ExtResource("1_pa1l3")
conversation_dialogue_file = ExtResource("2_nv1g7")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_qktef")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(957, 540.5)
scale = Vector2(0.497917, 0.498611)
texture = ExtResource("5_1ebgl")

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6
</file>

<file path="mcbucket_med_dispenser.tscn">
[gd_scene load_steps=10 format=3 uid="uid://dq4pkbax7ni44"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_weaf5"]
[ext_resource type="Script" uid="uid://bmq0s1nqhqi4j" path="res://InteractionResponse.gd" id="2_6k5h2"]
[ext_resource type="Texture2D" uid="uid://dx6p4253tam3g" path="res://med dispenser.png" id="2_xo2a3"]
[ext_resource type="Resource" uid="uid://bivfrghh084ym" path="res://interactions/actions/DefaultExamineResponse.tres" id="3_gaeqw"]
[ext_resource type="Script" uid="uid://dltqnu07oiff" path="res://action.gd" id="4_wn268"]
[ext_resource type="Script" uid="uid://7xsscyp60ilq" path="res://interactions/actions/CallMethodAction.gd" id="5_gaeqw"]

[sub_resource type="Resource" id="Resource_gaeqw"]
resource_local_to_scene = true
script = ExtResource("5_gaeqw")
target_node_path = NodePath("")
method_name = ""
arguments = []
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_34au0"]
script = ExtResource("2_6k5h2")
verb_id = "use_on_target"
required_item_id = "cannathink"
actions_to_perform = Array[ExtResource("4_wn268")]([SubResource("Resource_gaeqw")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(293, 370)

[node name="McbucketMedicineDispenser" type="Area2D"]
script = ExtResource("1_weaf5")
object_display_name = "Medicine Dispenser"
object_id = "mcbucket_medicine_dispenser"
interactions = Array[ExtResource("2_6k5h2")]([ExtResource("3_gaeqw"), SubResource("Resource_34au0")])

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_xo2a3")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(13.5, -192)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(11, 385)
</file>

<file path="mcbucket_thinking_conversation.tscn">
[gd_scene load_steps=7 format=3 uid="uid://byi5q4k4m762l"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_g3y2i"]
[ext_resource type="Resource" uid="uid://fxlpt5jaaje7" path="res://mcbucket_cannathink.dialogue" id="2_g3y2i"]
[ext_resource type="Texture2D" uid="uid://cx4r1a1ci7vpj" path="res://sergei.PNG" id="3_awfyy"]
[ext_resource type="Texture2D" uid="uid://coo5k2phjvc1e" path="res://Protag.png" id="4_6hk7o"]
[ext_resource type="Texture2D" uid="uid://dkfxelpqykxt6" path="res://Backgrounds/McBucket/high/mcbucket_high_base.png" id="5_g3y2i"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_awfyy")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
layer = 2
script = ExtResource("1_g3y2i")
conversation_dialogue_file = ExtResource("2_g3y2i")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_6hk7o")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(957, 540.5)
scale = Vector2(0.497917, 0.498611)
texture = ExtResource("5_g3y2i")

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6
</file>

<file path="mcbucket.gd">
extends Node2D

enum State { IDLE, HIGH, INVIGIROL, SLEEPING }

# --- Step 1: Define a constant for the new dialogue scene ---
# Make sure the path "res://mcbucket_invigirol_conversation.tscn" is correct for your project.
const THINKING_DIALOGUE_SCENE = preload("res://mcbucket_thinking_conversation.tscn")
const INVIGIROL_DIALOGUE_SCENE = preload("res://mcbucket_invigirol_conversation.tscn") # ADD THIS LINE
const DEFAULT_DIALOGUE_SCENE = preload("res://mcbucket_default_conversation.tscn")


@onready var animation_player: AnimationPlayer = $AnimationPlayer
@onready var interactable_component: Interactable = $InteractionArea


func _ready():
	await get_tree().process_frame
	if not GameManager: return

	if GameManager.get_current_level_flag("mcbucket_cannathink_used"):
		change_state(State.HIGH)
	elif GameManager.get_current_level_flag("mcbucket_invigirol_used"):
		change_state(State.INVIGIROL)
	elif GameManager.get_current_level_flag("mcbucket_zanopram_used"):
		change_state(State.SLEEPING)
	else:
		change_state(State.IDLE)


func change_state(new_state: State):
	if not animation_player or not interactable_component:
		push_warning("McBucket script is missing node references!")
		return

	# --- (No changes needed in this logic block) ---
	if GameManager:
		GameManager.set_current_level_flag("mcbucket_cannathink_used", new_state == State.HIGH)
		GameManager.set_current_level_flag("mcbucket_invigirol_used", new_state == State.INVIGIROL)
		GameManager.set_current_level_flag("mcbucket_zanopram_used", new_state == State.SLEEPING)
	# ---

	match new_state:
		State.IDLE:
			animation_player.play("idle")
			# (RECOMMENDED ADDITION) Reset to default dialogue behavior
			interactable_component.character_conversation_overlay_scene = DEFAULT_DIALOGUE_SCENE
		State.HIGH:
			animation_player.play("high")
			interactable_component.character_conversation_overlay_scene = THINKING_DIALOGUE_SCENE
			print_rich("[color=cyan]McBucket state changed to HIGH.[/color]")
		State.INVIGIROL:
			animation_player.play("invigirol", -1, 4.0)
			# --- Step 2: Assign the conversation scene when the state changes ---
			interactable_component.character_conversation_overlay_scene = INVIGIROL_DIALOGUE_SCENE # ADD THIS LINE
			print_rich("[color=cyan]McBucket state changed to INVIGIROL.[/color]")
		State.SLEEPING:
			animation_player.play("sleeping")
			# (Optional) You could also clear the conversation here if a sleeping character can't talk
			interactable_component.character_conversation_overlay_scene = null
			print_rich("[color=cyan]McBucket state changed to SLEEPING.[/color]")
</file>

<file path="mcbucket.tscn">
[gd_scene load_steps=110 format=3 uid="uid://c8w3xusvs4d7d"]

[ext_resource type="Script" uid="uid://criacytdq5a44" path="res://mcbucket.gd" id="1_71fhx"]
[ext_resource type="Script" uid="uid://d3ltdedfvykko" path="res://WaypointMovement.gd" id="1_rp6bs"]
[ext_resource type="Texture2D" uid="uid://bmidi6l33bump" path="res://image0(6).png" id="2_74ntj"]
[ext_resource type="Texture2D" uid="uid://cyo7mtlscpycq" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0002.png" id="4_nsoc5"]
[ext_resource type="Texture2D" uid="uid://c64kqdpuvbxfm" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0003.png" id="5_qxfbv"]
[ext_resource type="Texture2D" uid="uid://dflicmxsgke1b" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0004.png" id="6_443qn"]
[ext_resource type="Texture2D" uid="uid://cppn583prv6hg" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0005.png" id="7_u2w06"]
[ext_resource type="Texture2D" uid="uid://hdmk8k2cnjmp" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0006.png" id="8_lhr5h"]
[ext_resource type="Texture2D" uid="uid://b38vcxcnro2fy" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0007.png" id="9_74a6j"]
[ext_resource type="Texture2D" uid="uid://ks5t8tpbtuei" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0008.png" id="10_qyaou"]
[ext_resource type="Texture2D" uid="uid://g540pudlvtu3" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0009.png" id="11_214r7"]
[ext_resource type="Texture2D" uid="uid://bkob70cyaku3h" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0010.png" id="12_snvge"]
[ext_resource type="Texture2D" uid="uid://cfc50vuxqvkse" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0011.png" id="13_0tdub"]
[ext_resource type="Texture2D" uid="uid://dsdb8hl41pb77" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0012.png" id="14_auinh"]
[ext_resource type="Texture2D" uid="uid://credtb1qk2htu" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0013.png" id="15_dqx4y"]
[ext_resource type="Texture2D" uid="uid://dvlvqox3j0br8" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0014.png" id="16_octvt"]
[ext_resource type="Texture2D" uid="uid://dva8hvbhnndew" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0015.png" id="17_t2mai"]
[ext_resource type="Texture2D" uid="uid://ccfymcshhra2m" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0016.png" id="18_ppi45"]
[ext_resource type="Texture2D" uid="uid://bjjntpahdrl50" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0017.png" id="19_m3dpd"]
[ext_resource type="Texture2D" uid="uid://cnjspdygjiker" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0018.png" id="20_s6jdf"]
[ext_resource type="Texture2D" uid="uid://ct1dpwaum07m8" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0019.png" id="21_v7spw"]
[ext_resource type="Texture2D" uid="uid://dxr0ndfkfwc78" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0020.png" id="22_joblu"]
[ext_resource type="Texture2D" uid="uid://dd0ljqb4r7xks" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0021.png" id="23_2cx86"]
[ext_resource type="Texture2D" uid="uid://c82xhejtllkjc" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0022.png" id="24_majvw"]
[ext_resource type="Texture2D" uid="uid://b88bysu4eylah" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0023.png" id="25_h4acy"]
[ext_resource type="Texture2D" uid="uid://borjkge1im4p0" path="res://Animations/Mcbucket/Idle/Mcbucket_idle_0024.png" id="26_cg6dl"]
[ext_resource type="Texture2D" uid="uid://da1hv0yflmbox" path="res://Animations/Mcbucket/High/Mcbucket_high_0001.png" id="28_3ye72"]
[ext_resource type="Texture2D" uid="uid://cd7uiv7sg76os" path="res://Animations/Mcbucket/High/Mcbucket_high_0002.png" id="29_qaecp"]
[ext_resource type="Texture2D" uid="uid://dcp2huvc3rnid" path="res://Animations/Mcbucket/High/Mcbucket_high_0003.png" id="30_0gapf"]
[ext_resource type="Texture2D" uid="uid://dxf7aeh4qlbby" path="res://Animations/Mcbucket/High/Mcbucket_high_0004.png" id="31_lv7fp"]
[ext_resource type="Texture2D" uid="uid://b10bssksw1jgy" path="res://Animations/Mcbucket/High/Mcbucket_high_0005.png" id="32_g0nbx"]
[ext_resource type="Texture2D" uid="uid://6a58jxd8ehwu" path="res://Animations/Mcbucket/High/Mcbucket_high_0006.png" id="33_nv3ga"]
[ext_resource type="Texture2D" uid="uid://bv13mcx77wgp" path="res://Animations/Mcbucket/High/Mcbucket_high_0007.png" id="34_2v23n"]
[ext_resource type="Texture2D" uid="uid://okq3drbx1ucb" path="res://Animations/Mcbucket/High/Mcbucket_high_0008.png" id="35_o3xpm"]
[ext_resource type="Texture2D" uid="uid://bj8hi81o1p07t" path="res://Animations/Mcbucket/High/Mcbucket_high_0009.png" id="36_n2q47"]
[ext_resource type="Texture2D" uid="uid://d1ku68mnh8npo" path="res://Animations/Mcbucket/High/Mcbucket_high_0010.png" id="37_r1yoi"]
[ext_resource type="Texture2D" uid="uid://bouk7sl0n68i2" path="res://Animations/Mcbucket/High/Mcbucket_high_0011.png" id="38_o0edk"]
[ext_resource type="Texture2D" uid="uid://qwqf0o7fi3tq" path="res://Animations/Mcbucket/High/Mcbucket_high_0012.png" id="39_tq7g7"]
[ext_resource type="Texture2D" uid="uid://br7hnt85hl8eu" path="res://Animations/Mcbucket/High/Mcbucket_high_0013.png" id="40_rulfq"]
[ext_resource type="Texture2D" uid="uid://8ncw364713fj" path="res://Animations/Mcbucket/High/Mcbucket_high_0014.png" id="41_lg3ah"]
[ext_resource type="Texture2D" uid="uid://cifgoj4xulles" path="res://Animations/Mcbucket/High/Mcbucket_high_0015.png" id="42_mr60l"]
[ext_resource type="Texture2D" uid="uid://vrtwjuofvyyw" path="res://Animations/Mcbucket/High/Mcbucket_high_0016.png" id="43_p071p"]
[ext_resource type="Texture2D" uid="uid://c4s6sklfxf5ls" path="res://Animations/Mcbucket/High/Mcbucket_high_0017.png" id="44_5yusu"]
[ext_resource type="Texture2D" uid="uid://dgtr86a3dvesh" path="res://Animations/Mcbucket/High/Mcbucket_high_0018.png" id="45_1pbuw"]
[ext_resource type="Texture2D" uid="uid://bg24tjmk3hggb" path="res://Animations/Mcbucket/High/Mcbucket_high_0019.png" id="46_o600h"]
[ext_resource type="Texture2D" uid="uid://c3yi2lgjyktoe" path="res://Animations/Mcbucket/High/Mcbucket_high_0020.png" id="47_nffmn"]
[ext_resource type="Texture2D" uid="uid://cvyshrbudkj5f" path="res://Animations/Mcbucket/High/Mcbucket_high_0021.png" id="48_vdlg6"]
[ext_resource type="Texture2D" uid="uid://f8sfxlrl5xxc" path="res://Animations/Mcbucket/High/Mcbucket_high_0022.png" id="49_jp5mk"]
[ext_resource type="Texture2D" uid="uid://dxer72vnytxom" path="res://Animations/Mcbucket/High/Mcbucket_high_0023.png" id="50_tl4cy"]
[ext_resource type="Texture2D" uid="uid://de7h4sltqapxh" path="res://Animations/Mcbucket/High/Mcbucket_high_0024.png" id="51_r5geb"]
[ext_resource type="Texture2D" uid="uid://cugvo522jx4s8" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0001.png" id="52_pr8uv"]
[ext_resource type="Texture2D" uid="uid://cqncrayxsky6b" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0002.png" id="53_2oynf"]
[ext_resource type="Texture2D" uid="uid://b7n2avf0di7fw" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0003.png" id="54_1kish"]
[ext_resource type="Texture2D" uid="uid://k1ep2draaxg" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0004.png" id="55_127ue"]
[ext_resource type="Texture2D" uid="uid://but0csp278bq7" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0005.png" id="56_ckrwo"]
[ext_resource type="Texture2D" uid="uid://t223e23mvpra" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0006.png" id="57_slyn3"]
[ext_resource type="Texture2D" uid="uid://bo6eg7actuedm" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0007.png" id="58_fnaf0"]
[ext_resource type="Texture2D" uid="uid://ciby0ecabmw3m" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0008.png" id="59_g4ghl"]
[ext_resource type="Texture2D" uid="uid://ds0r5mh2if6w6" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0009.png" id="60_1kkar"]
[ext_resource type="Texture2D" uid="uid://csfbcfjkn2pxq" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0010.png" id="61_jv3au"]
[ext_resource type="Texture2D" uid="uid://b6lfc20y5ak5y" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0011.png" id="62_gn1lo"]
[ext_resource type="Texture2D" uid="uid://bylt8mdy3r6dl" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0012.png" id="63_a87x3"]
[ext_resource type="Texture2D" uid="uid://b5hr7t8rbwqsd" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0013.png" id="64_le2t1"]
[ext_resource type="Texture2D" uid="uid://dmeqqj4lvmv4w" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0014.png" id="65_6qu0y"]
[ext_resource type="Texture2D" uid="uid://dc7avhqydfhay" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0015.png" id="66_8dpcx"]
[ext_resource type="Texture2D" uid="uid://bxg5vykawt0b1" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0016.png" id="67_6d076"]
[ext_resource type="Texture2D" uid="uid://dp1nui78mpayp" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0017.png" id="68_v6gqn"]
[ext_resource type="Texture2D" uid="uid://bfxw281nte8q" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0018.png" id="69_jk0ie"]
[ext_resource type="Texture2D" uid="uid://daq5m1niuclv" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0019.png" id="70_hrn7m"]
[ext_resource type="Texture2D" uid="uid://dtxx2gvj6sm0y" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0020.png" id="71_5yj01"]
[ext_resource type="Texture2D" uid="uid://db4xmcok4ve4u" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0021.png" id="72_8h83p"]
[ext_resource type="Texture2D" uid="uid://dcmawhkde3xpr" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0022.png" id="73_lie4b"]
[ext_resource type="Texture2D" uid="uid://dubk2oiaxxroe" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0023.png" id="74_qsalf"]
[ext_resource type="Texture2D" uid="uid://fieeurroyjln" path="res://Animations/Mcbucket/Invigirol/Mcbucket_invigirol_0024.png" id="75_6gujg"]
[ext_resource type="Texture2D" uid="uid://d12xarw54ed8l" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0001.png" id="76_saxfo"]
[ext_resource type="Texture2D" uid="uid://ckpcalbiiju0a" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0002.png" id="77_i17tx"]
[ext_resource type="Texture2D" uid="uid://cbhuo0u25iy6f" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0003.png" id="78_jveid"]
[ext_resource type="Texture2D" uid="uid://dlgpy1phvjesq" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0004.png" id="79_h5rjw"]
[ext_resource type="Texture2D" uid="uid://d3l0rvgj4pvlj" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0005.png" id="80_mh8e5"]
[ext_resource type="Texture2D" uid="uid://b0xru52sega4y" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0006.png" id="81_yndl5"]
[ext_resource type="Texture2D" uid="uid://gp2e3ibp4t5g" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0007.png" id="82_nyajo"]
[ext_resource type="Texture2D" uid="uid://uidsbdahu155" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0008.png" id="83_dv0f4"]
[ext_resource type="Texture2D" uid="uid://0b6su6ryt56a" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0009.png" id="84_7rykg"]
[ext_resource type="Texture2D" uid="uid://dgedm7vqeuywy" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0010.png" id="85_kx2bl"]
[ext_resource type="Texture2D" uid="uid://ct155oda6ksbv" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0011.png" id="86_abfxk"]
[ext_resource type="Texture2D" uid="uid://cvdvnhllcl7pf" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0012.png" id="87_hk85n"]
[ext_resource type="Texture2D" uid="uid://c6oi57h0l82eu" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0013.png" id="88_rfsae"]
[ext_resource type="Texture2D" uid="uid://dcxqvsi60uxyh" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0014.png" id="89_mluww"]
[ext_resource type="Texture2D" uid="uid://cnob3xoxh0gr0" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0015.png" id="90_m0pga"]
[ext_resource type="Texture2D" uid="uid://bc7xwxlnx2s3p" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0016.png" id="91_7p747"]
[ext_resource type="Texture2D" uid="uid://r2hel70630hr" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0017.png" id="92_i88i5"]
[ext_resource type="Texture2D" uid="uid://dbiiffyl320se" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0018.png" id="93_t6462"]
[ext_resource type="Texture2D" uid="uid://d2shw1dm46q1n" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0019.png" id="94_ifte0"]
[ext_resource type="Texture2D" uid="uid://n3m5gh2jnm0l" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0020.png" id="95_n4id7"]
[ext_resource type="Texture2D" uid="uid://cjd64064fhv8w" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0021.png" id="96_f454y"]
[ext_resource type="Texture2D" uid="uid://br2gdcoct7o2" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0022.png" id="97_lmdvk"]
[ext_resource type="Texture2D" uid="uid://dcethwhh47lo7" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0023.png" id="98_ors7v"]
[ext_resource type="Texture2D" uid="uid://cuyewotjjlmkp" path="res://Animations/Mcbucket/Sleeping/Mcbucket_sleeping_0024.png" id="99_8rwa8"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_hsqv2"]
size = Vector2(493, 571)

[sub_resource type="Animation" id="Animation_71fhx"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("2_74ntj")]
}

[sub_resource type="Animation" id="Animation_qxfbv"]
resource_name = "high"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.0833, 0.1667, 0.25, 0.3333, 0.4167, 0.5, 0.5833, 0.6667, 0.75, 0.8333, 0.9167, 1, 1.0833, 1.1667, 1.25, 1.3333, 1.4167, 1.5, 1.5833, 1.6667, 1.75, 1.86667, 1.9167),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("28_3ye72"), ExtResource("29_qaecp"), ExtResource("30_0gapf"), ExtResource("31_lv7fp"), ExtResource("32_g0nbx"), ExtResource("33_nv3ga"), ExtResource("34_2v23n"), ExtResource("35_o3xpm"), ExtResource("36_n2q47"), ExtResource("37_r1yoi"), ExtResource("38_o0edk"), ExtResource("39_tq7g7"), ExtResource("40_rulfq"), ExtResource("41_lg3ah"), ExtResource("42_mr60l"), ExtResource("43_p071p"), ExtResource("44_5yusu"), ExtResource("45_1pbuw"), ExtResource("46_o600h"), ExtResource("47_nffmn"), ExtResource("48_vdlg6"), ExtResource("49_jp5mk"), ExtResource("50_tl4cy"), ExtResource("51_r5geb")]
}

[sub_resource type="Animation" id="Animation_3ye72"]
resource_name = "idle"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0.0833, 0.1667, 0.25, 0.3333, 0.4167, 0.5, 0.5833, 0.6667, 0.75, 0.8333, 0.9167, 1, 1.0833, 1.1667, 1.25, 1.3333, 1.4167, 1.5, 1.5833, 1.6667, 1.75, 1.8333, 1.9167),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("4_nsoc5"), ExtResource("5_qxfbv"), ExtResource("6_443qn"), ExtResource("7_u2w06"), ExtResource("8_lhr5h"), ExtResource("9_74a6j"), ExtResource("10_qyaou"), ExtResource("11_214r7"), ExtResource("12_snvge"), ExtResource("13_0tdub"), ExtResource("14_auinh"), ExtResource("15_dqx4y"), ExtResource("16_octvt"), ExtResource("17_t2mai"), ExtResource("18_ppi45"), ExtResource("19_m3dpd"), ExtResource("20_s6jdf"), ExtResource("21_v7spw"), ExtResource("22_joblu"), ExtResource("23_2cx86"), ExtResource("24_majvw"), ExtResource("25_h4acy"), ExtResource("26_cg6dl")]
}

[sub_resource type="Animation" id="Animation_i8dlw"]
resource_name = "idle_hyper"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.366667),
"transitions": PackedFloat32Array(1, 1),
"update": 1,
"values": [ExtResource("2_74ntj"), ExtResource("2_74ntj")]
}

[sub_resource type="Animation" id="Animation_55nt8"]
resource_name = "invigirol"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.0833, 0.1667, 0.266667, 0.3333, 0.4167, 0.5, 0.5833, 0.6667, 0.75, 0.8333, 0.9167, 1, 1.0833, 1.1667, 1.25, 1.3333, 1.4167, 1.5, 1.5833, 1.6667, 1.75, 1.8333, 1.9167),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("52_pr8uv"), ExtResource("53_2oynf"), ExtResource("54_1kish"), ExtResource("55_127ue"), ExtResource("56_ckrwo"), ExtResource("57_slyn3"), ExtResource("58_fnaf0"), ExtResource("59_g4ghl"), ExtResource("60_1kkar"), ExtResource("61_jv3au"), ExtResource("62_gn1lo"), ExtResource("63_a87x3"), ExtResource("64_le2t1"), ExtResource("65_6qu0y"), ExtResource("66_8dpcx"), ExtResource("67_6d076"), ExtResource("68_v6gqn"), ExtResource("69_jk0ie"), ExtResource("70_hrn7m"), ExtResource("71_5yj01"), ExtResource("72_8h83p"), ExtResource("73_lie4b"), ExtResource("74_qsalf"), ExtResource("75_6gujg")]
}

[sub_resource type="Animation" id="Animation_riif7"]
resource_name = "react_chaos"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.366667),
"transitions": PackedFloat32Array(1, 1),
"update": 1,
"values": [ExtResource("2_74ntj"), ExtResource("2_74ntj")]
}

[sub_resource type="Animation" id="Animation_c64w3"]
resource_name = "react_injection"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.366667),
"transitions": PackedFloat32Array(1, 1),
"update": 1,
"values": [ExtResource("2_74ntj"), ExtResource("2_74ntj")]
}

[sub_resource type="Animation" id="Animation_qcxj6"]
resource_name = "react_thinking"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.366667),
"transitions": PackedFloat32Array(1, 1),
"update": 1,
"values": [ExtResource("2_74ntj"), ExtResource("2_74ntj")]
}

[sub_resource type="Animation" id="Animation_gy5et"]
resource_name = "sleeping"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.0833, 0.1667, 0.266667, 0.3333, 0.4167, 0.5, 0.5833, 0.6667, 0.75, 0.8333, 0.9167, 1, 1.0833, 1.1667, 1.25, 1.3333, 1.4167, 1.5, 1.5833, 1.6667, 1.75, 1.8333, 1.9167),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("76_saxfo"), ExtResource("77_i17tx"), ExtResource("78_jveid"), ExtResource("79_h5rjw"), ExtResource("80_mh8e5"), ExtResource("81_yndl5"), ExtResource("82_nyajo"), ExtResource("83_dv0f4"), ExtResource("84_7rykg"), ExtResource("85_kx2bl"), ExtResource("86_abfxk"), ExtResource("87_hk85n"), ExtResource("88_rfsae"), ExtResource("89_mluww"), ExtResource("90_m0pga"), ExtResource("91_7p747"), ExtResource("92_i88i5"), ExtResource("93_t6462"), ExtResource("94_ifte0"), ExtResource("95_n4id7"), ExtResource("96_f454y"), ExtResource("97_lmdvk"), ExtResource("98_ors7v"), ExtResource("99_8rwa8")]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_562c1"]
_data = {
&"RESET": SubResource("Animation_71fhx"),
&"high": SubResource("Animation_qxfbv"),
&"idle": SubResource("Animation_3ye72"),
&"idle_hyper": SubResource("Animation_i8dlw"),
&"invigirol": SubResource("Animation_55nt8"),
&"react_chaos": SubResource("Animation_riif7"),
&"react_injection": SubResource("Animation_c64w3"),
&"react_thinking": SubResource("Animation_qcxj6"),
&"sleeping": SubResource("Animation_gy5et")
}

[node name="McBucket" type="CharacterBody2D"]
script = ExtResource("1_71fhx")

[node name="Sprite" type="AnimatedSprite2D" parent="."]
animation = &""

[node name="MovementController" type="Node" parent="."]
script = ExtResource("1_rp6bs")

[node name="InteractionArea" type="Area2D" parent="."]

[node name="InteractionClickShape" type="CollisionShape2D" parent="InteractionArea"]
position = Vector2(-116.5, 36.5)
shape = SubResource("RectangleShape2D_hsqv2")

[node name="Sprite2D" type="Sprite2D" parent="."]
position = Vector2(-8.49999, 2.99997)
texture = ExtResource("2_74ntj")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_562c1")
}
</file>

<file path="MedCabinetzoomin.tscn">
[gd_scene load_steps=7 format=3 uid="uid://bjnf6egwtuqv5"]

[ext_resource type="Script" uid="uid://dk4awdnwdvbr6" path="res://Scripts/MedicineCabinetZoom.gd" id="1_34wwt"]
[ext_resource type="Texture2D" uid="uid://dp1cbodca3siq" path="res://medcabinetzoomed.png" id="2_mvlbe"]
[ext_resource type="Resource" uid="uid://dmkt054qdywph" path="res://test.dialogue" id="2_oa20e"]
[ext_resource type="PackedScene" uid="uid://b5eqmwcgkinbv" path="res://UI_cannathink.tscn" id="3_34wwt"]
[ext_resource type="PackedScene" uid="uid://b8jbh3bghi1rb" path="res://UI_Zanopram.tscn" id="5_oa20e"]
[ext_resource type="PackedScene" uid="uid://bi8u415ulvhb" path="res://UI_Invigirol.tscn" id="6_oa20e"]

[node name="ObjectZoomOverlay" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_34wwt")
caught_dialogue_resource = ExtResource("2_oa20e")
caught_dialogue_start_id = "test"

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(1, 1, 1, 0)

[node name="ZoomBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
mouse_filter = 2
texture = ExtResource("2_mvlbe")
expand_mode = 1
stretch_mode = 6

[node name="InteractableContainer" type="Node2D" parent="RootContainer"]

[node name="TextureButton" parent="RootContainer/InteractableContainer" instance=ExtResource("3_34wwt")]
offset_left = 825.0
offset_top = 127.0
offset_right = 1525.0
offset_bottom = 1027.0
scale = Vector2(0.45, 0.45)

[node name="TextureButton2" parent="RootContainer/InteractableContainer" instance=ExtResource("6_oa20e")]
offset_left = 339.0
offset_top = 122.0
offset_right = 1039.0
offset_bottom = 1022.0
scale = Vector2(0.45, 0.45)

[node name="TextureButton3" parent="RootContainer/InteractableContainer" instance=ExtResource("5_oa20e")]
offset_left = 1309.0
offset_top = 125.0
offset_right = 2009.0
offset_bottom = 1025.0
scale = Vector2(0.45, 0.45)

[node name="CloseButton" type="Button" parent="RootContainer"]
layout_mode = 0
offset_left = 22.0
offset_top = 26.0
offset_right = 130.0
offset_bottom = 83.0
text = "BACK LOL"
</file>

<file path="memory_box.tscn">
[gd_scene load_steps=4 format=3 uid="uid://cpvtyvf4t8pht"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_13axh"]
[ext_resource type="Texture2D" uid="uid://gnko17ua8soc" path="res://memory_box_sprite.png" id="2_5gyts"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_13axh"]
size = Vector2(281, 667)

[node name="MemoryBox" type="Area2D"]
script = ExtResource("1_13axh")
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_5gyts")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(8.5, -8.5)
shape = SubResource("RectangleShape2D_13axh")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 321)
</file>

<file path="MemoryBoxOverlay.gd">
# MemoryBoxOverlay.gd
extends CanvasLayer

## EXPORTED VARIABLES
## Drag all of your MemoryGroupData (.tres) files into this array in the Inspector.
@export var all_memory_data: Array[MemoryGroupData] = []

## NODE REFERENCES
@onready var location_list_container: VBoxContainer = $Panel/ScrollContainer/LocationListContainer
@onready var story_button: Button = $Panel/TabContainer/StoryButton
@onready var spicy_button: Button = $Panel/TabContainer/SpicyButton
@onready var back_button: Button = $Panel/BackButton

## PRELOADS
const LocationRowScene = preload("res://LocationRow.tscn") # <-- IMPORTANT: Verify this path!


func _ready():
	# Connect the buttons to their handler functions
	story_button.pressed.connect(_on_story_button_pressed)
	spicy_button.pressed.connect(_on_spicy_button_pressed)
	back_button.pressed.connect(_on_back_button_pressed)

	# When the scene opens, show the "Story" category by default.
	_populate_list(MemoryGroupData.MemoryCategory.STORY)


func _populate_list(category_to_show: MemoryGroupData.MemoryCategory):
	# First, clear any location rows that are already there.
	for child in location_list_container.get_children():
		child.queue_free()

	# Now, loop through all of our data files.
	for memory_group in all_memory_data:
		# Check if the data's category matches the tab we want to show.
		if memory_group.category == category_to_show:
			# If it matches, create a new LocationRow instance.
			var new_row = LocationRowScene.instantiate()
			# Add it to our VBoxContainer.
			location_list_container.add_child(new_row)
			# And tell the new row to populate itself with this data.
			new_row.populate(memory_group)

			# --- THIS IS THE CRITICAL LINE, CORRECTLY INDENTED ---
			# It MUST be inside this 'if' block to access 'new_row'.
			new_row.chapter_selected.connect(_on_chapter_selected)

# --- Signal Handlers ---

func _on_story_button_pressed():
	# When the story button is pressed, rebuild the list with STORY data.
	_populate_list(MemoryGroupData.MemoryCategory.STORY)


func _on_spicy_button_pressed():
	# When the spicy button is pressed, rebuild the list with SPICY data.
	_populate_list(MemoryGroupData.MemoryCategory.SPICY)


func _on_back_button_pressed():

	if GameManager:
		GameManager.exit_to_world_state()


	print("Back button pressed, closing overlay.")
	queue_free()


func _on_chapter_selected(data: MemoryChapterData):
	print("Chapter selected in main overlay!")
	print("  - Name: ", data.chapter_name)
	print("  - Scene to load: ", data.scene_path_to_load)

	# --- TODO: FUTURE LOGIC GOES HERE ---
	# For example:
	# if not data.scene_path_to_load.is_empty():
	#     get_tree().change_scene_to_file(data.scene_path_to_load)
	# self.queue_free() # Close the memory box
</file>

<file path="Sergei_Conversation.tscn">
[gd_scene load_steps=8 format=3 uid="uid://c2mnsensqkur6"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_y71nh"]
[ext_resource type="Resource" uid="uid://ckg6wmvrckv0q" path="res://sergei_dialogue.dialogue" id="2_gvw3d"]
[ext_resource type="Texture2D" uid="uid://cx4r1a1ci7vpj" path="res://sergei.PNG" id="3_y71nh"]
[ext_resource type="Texture2D" uid="uid://coo5k2phjvc1e" path="res://Protag.png" id="4_qw1wr"]
[ext_resource type="Material" uid="uid://dek82a5tuykas" path="res://Shaders/grayscale_material.tres" id="5_cwuwn"]
[ext_resource type="Texture2D" uid="uid://dg6a8t20eu1yu" path="res://Backgrounds/Sergey/sergey_neutral.png" id="5_jy7bi"]

[sub_resource type="SpriteFrames" id="SpriteFrames_jy7bi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_y71nh")
}],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_y71nh")
conversation_dialogue_file = ExtResource("2_gvw3d")
background_animations = SubResource("SpriteFrames_jy7bi")
initial_animation_name = ""
scene_character_sprite_texture = ExtResource("4_qw1wr")
mental_image_shader = ExtResource("5_cwuwn")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(960.9997, 540.5)
scale = Vector2(0.5000002, 0.498611)
texture = ExtResource("5_jy7bi")
centered = false

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6

[node name="MentalImageSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(960.9997, 540.5)
scale = Vector2(0.5000002, 0.498611)
texture = ExtResource("5_jy7bi")
</file>

<file path="Sergei.tscn">
[gd_scene load_steps=31 format=3 uid="uid://frycmvsnkt3j"]

[ext_resource type="Script" uid="uid://hk0fo4fyepak" path="res://sergey.gd" id="1_li012"]
[ext_resource type="Texture2D" uid="uid://duhu5w16u7jsh" path="res://Animations/Sergey/Idle/Sergey_idle_0001.png" id="2_3hibr"]
[ext_resource type="Texture2D" uid="uid://vjvm2vltq5yf" path="res://Animations/Sergey/Idle/Sergey_idle_0002.png" id="4_tx2cy"]
[ext_resource type="Texture2D" uid="uid://xagusqxllgml" path="res://Animations/Sergey/Idle/Sergey_idle_0003.png" id="5_8qdt4"]
[ext_resource type="Texture2D" uid="uid://bdkoybqywx5pu" path="res://Animations/Sergey/Idle/Sergey_idle_0004.png" id="6_xy0ev"]
[ext_resource type="Texture2D" uid="uid://dsm4i1rlu76xf" path="res://Animations/Sergey/Idle/Sergey_idle_0005.png" id="7_oq4m0"]
[ext_resource type="Texture2D" uid="uid://dupsfhdvt16j6" path="res://Animations/Sergey/Idle/Sergey_idle_0006.png" id="8_pmp40"]
[ext_resource type="Texture2D" uid="uid://ttt2oxfu8xna" path="res://Animations/Sergey/Idle/Sergey_idle_0007.png" id="9_c7832"]
[ext_resource type="Texture2D" uid="uid://qvm73xm5xg4t" path="res://Animations/Sergey/Idle/Sergey_idle_0008.png" id="10_qqmrf"]
[ext_resource type="Texture2D" uid="uid://c7pcphc3h380v" path="res://Animations/Sergey/Idle/Sergey_idle_0009.png" id="11_0rrqv"]
[ext_resource type="Texture2D" uid="uid://ba4nd1gkqmts3" path="res://Animations/Sergey/Idle/Sergey_idle_0010.png" id="12_trjii"]
[ext_resource type="Script" uid="uid://d3ltdedfvykko" path="res://WaypointMovement.gd" id="13_2vcks"]
[ext_resource type="Texture2D" uid="uid://csnqa7wb6t6fg" path="res://Animations/Sergey/Idle/Sergey_idle_0011.png" id="13_5y5j0"]
[ext_resource type="Texture2D" uid="uid://dop8hm85s6ff5" path="res://Animations/Sergey/Idle/Sergey_idle_0012.png" id="14_3a84v"]
[ext_resource type="Texture2D" uid="uid://du11rc30gu8w3" path="res://Animations/Sergey/Idle/Sergey_idle_0013.png" id="15_8mu2b"]
[ext_resource type="Texture2D" uid="uid://o3ekd2vmvwi7" path="res://Animations/Sergey/Idle/Sergey_idle_0014.png" id="16_v7x2n"]
[ext_resource type="Texture2D" uid="uid://3qhhq7okuwrt" path="res://Animations/Sergey/Idle/Sergey_idle_0015.png" id="17_1e0mo"]
[ext_resource type="Texture2D" uid="uid://dh78yn2ehgiuf" path="res://Animations/Sergey/Idle/Sergey_idle_0016.png" id="18_i8ysh"]
[ext_resource type="Texture2D" uid="uid://dyud13rt7u572" path="res://Animations/Sergey/Idle/Sergey_idle_0017.png" id="19_5r1mv"]
[ext_resource type="Texture2D" uid="uid://cgd56pkviyny2" path="res://Animations/Sergey/Idle/Sergey_idle_0018.png" id="20_c76b6"]
[ext_resource type="Texture2D" uid="uid://bymtvwyig5ma5" path="res://Animations/Sergey/Idle/Sergey_idle_0019.png" id="21_1qawx"]
[ext_resource type="Texture2D" uid="uid://c56dyl8egu8pi" path="res://Animations/Sergey/Idle/Sergey_idle_0020.png" id="22_mj0xp"]
[ext_resource type="Texture2D" uid="uid://isxoilgj2duw" path="res://Animations/Sergey/Idle/Sergey_idle_0021.png" id="23_o0q68"]
[ext_resource type="Texture2D" uid="uid://de75xs6unswdb" path="res://Animations/Sergey/Idle/Sergey_idle_0022.png" id="24_jo2rn"]
[ext_resource type="Texture2D" uid="uid://kt2bnx5uocdq" path="res://Animations/Sergey/Idle/Sergey_idle_0023.png" id="25_clmv0"]
[ext_resource type="Texture2D" uid="uid://bmconsgliybfb" path="res://Animations/Sergey/Idle/Sergey_idle_0024.png" id="26_v52hy"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_hsqv2"]
size = Vector2(250, 508)

[sub_resource type="Animation" id="Animation_3hibr"]
resource_name = "idle"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0.0833, 0.1667, 0.25, 0.333, 0.417, 0.5, 0.583, 0.667, 0.75, 0.833, 0.917, 1, 1.083, 1.167, 1.25, 1.333, 1.4, 1.5, 1.583, 1.667, 1.75, 1.833, 1.917, 2),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("4_tx2cy"), ExtResource("5_8qdt4"), ExtResource("6_xy0ev"), ExtResource("7_oq4m0"), ExtResource("8_pmp40"), ExtResource("9_c7832"), ExtResource("10_qqmrf"), ExtResource("11_0rrqv"), ExtResource("12_trjii"), ExtResource("13_5y5j0"), ExtResource("14_3a84v"), ExtResource("15_8mu2b"), ExtResource("16_v7x2n"), ExtResource("17_1e0mo"), ExtResource("18_i8ysh"), ExtResource("19_5r1mv"), ExtResource("20_c76b6"), ExtResource("21_1qawx"), ExtResource("22_mj0xp"), ExtResource("23_o0q68"), ExtResource("24_jo2rn"), ExtResource("25_clmv0"), ExtResource("26_v52hy"), ExtResource("2_3hibr")]
}

[sub_resource type="Animation" id="Animation_f2i0d"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite2D:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("2_3hibr")]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_7jyp4"]
_data = {
&"RESET": SubResource("Animation_f2i0d"),
&"idle": SubResource("Animation_3hibr")
}

[node name="Sergey" type="CharacterBody2D"]
script = ExtResource("1_li012")

[node name="Sprite" type="AnimatedSprite2D" parent="."]
animation = &""
autoplay = "idle"

[node name="MovementController" type="Node" parent="."]
script = ExtResource("13_2vcks")

[node name="InteractionArea" type="Area2D" parent="."]

[node name="InteractionClickShape" type="CollisionShape2D" parent="InteractionArea"]
position = Vector2(162, -28)
shape = SubResource("RectangleShape2D_hsqv2")

[node name="Sprite2D" type="Sprite2D" parent="."]
position = Vector2(-8.49999, 2.99997)
texture = ExtResource("2_3hibr")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_7jyp4")
}
</file>

<file path="VerbData.gd">
# VerbData.gd
extends Resource
class_name VerbData # Makes it usable as a type hint

## The unique internal identifier for this verb (e.g., "examine", "talk_to")
@export var verb_id: String = ""

## The text displayed on the UI button for this verb (e.g., "Examine", "Talk to")
@export var display_text: String = ""

## Optional: An icon for the verb button
# @export var icon: Texture2D = null

## Is this verb available by default when the game starts or a new general state begins?
@export var unlocked_by_default: bool = true

## Does this verb typically require the player to click on a target object after selecting the verb?
## (e.g., "Examine" might sometimes be used on the general scene, but mostly on objects)
@export var requires_target_object: bool = true

# --- ADD THIS NEW LINE ---
## The dialogue file to use as a fallback if no specific interaction is defined for this verb.
@export var fallback_dialogue_file: DialogueResource
# --- END OF ADDITION ---
# i can add new properties here later!
</file>

<file path="VerbUI.gd">
# VerbUI.gd
extends CanvasLayer

@onready var action_bubble_label: Label = $ActionBubbleLabel
@onready var verb_button_grid: GridContainer = $VerbGridPanel/GridContainer # VERIFY THIS PATH

# This will store references to the actual Button nodes, mapping verb_id to Button
var active_verb_buttons: Dictionary = {} # Key: verb_id (String), Value: Button node
# We'll also keep an ordered list of all 9 button slots for easy iteration
var all_button_slots: Array[Button] = []


func _ready():
	# Ensure GridContainer is set to 3 columns (can also be done in Inspector)
	if verb_button_grid:
		verb_button_grid.columns = 3
	else:
		print_rich("[color=red]VerbUI: VerbButtonGrid node not found! Cannot set columns.[/color]")
		return # Critical error

	# --- Initialize exactly 9 button slots ---
	# First, clear any existing children in the GridContainer from the editor
	for child in verb_button_grid.get_children():
		verb_button_grid.remove_child(child) # Remove from container first
		child.queue_free()               # Then free it

	all_button_slots.clear() # Clear our internal array too
	active_verb_buttons.clear()

	for i in range(9): # Create 9 base buttons
		var new_button = Button.new()
		new_button.text = "-"
		new_button.disabled = true # Start disabled until populated
		new_button.name = "VerbSlotButton_" + str(i) # For debugging
		# Set a minimum size for buttons if they appear too small initially
		new_button.custom_minimum_size = Vector2(100, 30) # Adjust as needed
		# Set size flags to expand within the grid cell
		new_button.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		new_button.size_flags_vertical = Control.SIZE_EXPAND_FILL

		all_button_slots.append(new_button)
		verb_button_grid.add_child(new_button)
		# Connection will be done when verbs are assigned in _on_available_verbs_changed

	# Connect to GameManager signals
	if GameManager: # Ensure GameManager is available
		GameManager.available_verbs_changed.connect(_on_available_verbs_changed)
		GameManager.verb_changed.connect(_on_game_manager_verb_changed)
		GameManager.sentence_line_updated.connect(_on_game_manager_sentence_line_updated)
		GameManager.interaction_complete.connect(_on_interaction_complete)

		# Request initial verb list from GameManager
		# It will emit available_verbs_changed in its _ready if it's set up after this UI
		# or we can call a function to get current state if GM is already ready.
		if GameManager.has_method("get_currently_displayable_verbs"):
			_on_available_verbs_changed(GameManager.get_currently_displayable_verbs())
		else:
			print_rich("[color=orange]VerbUI: GameManager doesn't have get_currently_displayable_verbs yet.[/color]")

	else:
		print_rich("[color=red]VerbUI: GameManager not found during _ready().[/color]")


	action_bubble_label.visible = false


func _process(_delta: float) -> void: # Unchanged
	if action_bubble_label.visible:
		action_bubble_label.global_position = get_viewport().get_mouse_position() + Vector2(15, 15)


func _on_available_verbs_changed(available_verb_data_array: Array[VerbData]):
	print("VerbUI: Received available verbs: ", available_verb_data_array.size())
	active_verb_buttons.clear() # Clear map of verb_id to button

	# Iterate through our 9 button slots
	for i in range(all_button_slots.size()):
		var button_node: Button = all_button_slots[i]

		# Disconnect any previous pressed signal to avoid multiple connections
		if button_node.is_connected("pressed", Callable(self, "_on_verb_button_pressed_dynamic")):
			button_node.pressed.disconnect(Callable(self, "_on_verb_button_pressed_dynamic"))

		if i < available_verb_data_array.size():
			# This slot gets an active verb
			var verb_data: VerbData = available_verb_data_array[i]
			if verb_data and is_instance_valid(verb_data): # Check if verb_data is valid
				button_node.text = verb_data.display_text
				button_node.disabled = false
				# Store verb_id in button's metadata for easy retrieval, or use the active_verb_buttons map
				button_node.set_meta("verb_id", verb_data.verb_id)
				button_node.pressed.connect(_on_verb_button_pressed_dynamic.bind(verb_data.verb_id)) # Bind verb_id
				active_verb_buttons[verb_data.verb_id] = button_node
				print("VerbUI: Set button %s to verb '%s' (%s)" % [i, verb_data.verb_id, verb_data.display_text])

			else: # Should not happen if GameManager sends valid data
				button_node.text = "-"
				button_node.disabled = true
				button_node.set_meta("verb_id", "")
				print_rich("[color=orange]VerbUI: Invalid VerbData at index %s[/color]" % i)
		else:
			# This slot is a placeholder
			button_node.text = "-"
			button_node.disabled = true
			button_node.set_meta("verb_id", "") # Clear any old verb_id

	_update_button_selected_visual_state(GameManager.current_verb_id if GameManager else "")


# Renamed to avoid conflict if an old _on_verb_button_pressed was connected from editor
# In VerbUI.gd

func _on_verb_button_pressed_dynamic(verb_id_pressed: String):
	# Play the sound 20% faster. Experiment with this value! Try 1.1, 1.3, etc.
	SoundManager.play_sfx("ui_click", 1.5)

	if GameManager and verb_id_pressed != "":
		GameManager.select_verb(verb_id_pressed)
	else:
		print("VerbUI: GameManager not found or empty verb_id pressed.")

func _on_game_manager_verb_changed(new_verb_id: String): # Unchanged from previous version
	if new_verb_id == "":
		action_bubble_label.visible = false
	else:
		var verb_data = GameManager.get_verb_data_by_id(new_verb_id) if GameManager else null
		if verb_data:
			action_bubble_label.text = verb_data.display_text + ":"
			action_bubble_label.visible = true
		else:
			action_bubble_label.text = new_verb_id + ":" # Fallback
			action_bubble_label.visible = true
	_update_button_selected_visual_state(new_verb_id)

# In VerbUI.gd

func _on_game_manager_sentence_line_updated(full_sentence: String):
	# ADD THIS LINE FOR DEBUGGING
	#print("VerbUI received sentence: '", full_sentence, "'")

	if GameManager and GameManager.current_verb_id != "":
		action_bubble_label.text = full_sentence
		action_bubble_label.visible = true
	else:
		# Let's modify this part to handle the "implicit use" case
		if full_sentence != "":
			action_bubble_label.text = full_sentence
			action_bubble_label.visible = true
		else:
			action_bubble_label.visible = false

func _on_interaction_complete(): # Unchanged
	action_bubble_label.visible = false
	_update_button_selected_visual_state("")

func _update_button_selected_visual_state(selected_verb_id: String): # Unchanged
	for button_node in all_button_slots: # Iterate through all_button_slots
		var button_verb_id = button_node.get_meta("verb_id", "") # Get verb_id from metadata
		if is_instance_valid(button_node):
			if button_verb_id != "" and button_verb_id == selected_verb_id:
				button_node.modulate = Color(0.7, 0.7, 1.0)
			else:
				button_node.modulate = Color(1.0, 1.0, 1.0)
</file>

<file path="Zanopram.tscn">
[gd_scene load_steps=4 format=3 uid="uid://diod8d2fs3i3u"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_xr87r"]
[ext_resource type="Texture2D" uid="uid://bjuaurrw0logr" path="res://zanopram.png" id="2_xr87r"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(613, 728)

[node name="Zzzanopram" type="Area2D"]
script = ExtResource("1_xr87r")
object_display_name = "Zzzanopram"
object_id = "zanopram"
interaction_location = 1

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_xr87r")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-3.5, -1)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)
</file>

<file path="aida.tscn">
[gd_scene load_steps=43 format=3 uid="uid://oy53tf8tvxe5"]

[ext_resource type="Script" uid="uid://dgdtb6o10kuyr" path="res://aida.gd" id="1_c6jtv"]
[ext_resource type="Texture2D" uid="uid://2om663l1jjvd" path="res://Animations/AIda/Idle/AIda_idle_0001.png" id="1_rbbfu"]
[ext_resource type="Texture2D" uid="uid://dssecnye0c5ww" path="res://Animations/AIda/Idle/AIda_idle_0002.png" id="4_a1bqy"]
[ext_resource type="Texture2D" uid="uid://cgad6gyr5cx57" path="res://Animations/AIda/Idle/AIda_idle_0003.png" id="5_4dvv0"]
[ext_resource type="Texture2D" uid="uid://bd7pgwyg2t0lm" path="res://Animations/AIda/Idle/AIda_idle_0004.png" id="6_mruqf"]
[ext_resource type="Texture2D" uid="uid://bcc1qhncd1ouw" path="res://Animations/AIda/Idle/AIda_idle_0005.png" id="7_yi4fc"]
[ext_resource type="Texture2D" uid="uid://br1vtso3pedmq" path="res://Animations/AIda/Idle/AIda_idle_0006.png" id="8_d3mpw"]
[ext_resource type="Texture2D" uid="uid://te3e8xrcgn0i" path="res://Animations/AIda/Idle/AIda_idle_0007.png" id="9_o60a8"]
[ext_resource type="Texture2D" uid="uid://ch6bvd2lu6ppa" path="res://Animations/AIda/Idle/AIda_idle_0008.png" id="10_5xdnd"]
[ext_resource type="Texture2D" uid="uid://b00hfmno02lyj" path="res://Animations/AIda/Idle/AIda_idle_0009.png" id="11_b36qa"]
[ext_resource type="Texture2D" uid="uid://cujmek6s8rxfm" path="res://Animations/AIda/Idle/AIda_idle_0010.png" id="12_xoi07"]
[ext_resource type="Script" uid="uid://d3ltdedfvykko" path="res://WaypointMovement.gd" id="13_5x1vy"]
[ext_resource type="Texture2D" uid="uid://6v2shbe06i71" path="res://Animations/AIda/Idle/AIda_idle_0011.png" id="13_f5e6k"]
[ext_resource type="Texture2D" uid="uid://dt3jmatxocest" path="res://Animations/AIda/Idle/AIda_idle_0012.png" id="14_pvvs7"]
[ext_resource type="Texture2D" uid="uid://ch5if0l2fcoba" path="res://Animations/AIda/Idle/AIda_idle_0013.png" id="15_0qbb8"]
[ext_resource type="Texture2D" uid="uid://cndevya51bhhc" path="res://Animations/AIda/Idle/AIda_idle_0014.png" id="16_fqh8o"]
[ext_resource type="Texture2D" uid="uid://caavnkngupuoa" path="res://Animations/AIda/Idle/AIda_idle_0015.png" id="17_j51ha"]
[ext_resource type="Texture2D" uid="uid://b5olom0amk7g2" path="res://Animations/AIda/Idle/AIda_idle_0016.png" id="18_2wnib"]
[ext_resource type="Texture2D" uid="uid://tfhnugby7yxq" path="res://Animations/AIda/Idle/AIda_idle_0017.png" id="19_mhq4g"]
[ext_resource type="Texture2D" uid="uid://c7t2rxc3k4x2f" path="res://Animations/AIda/Idle/AIda_idle_0018.png" id="20_6eamu"]
[ext_resource type="Texture2D" uid="uid://bq2uphnww10m5" path="res://Animations/AIda/Idle/AIda_idle_0019.png" id="21_fj1q1"]
[ext_resource type="Texture2D" uid="uid://dn7nomdjm26yk" path="res://Animations/AIda/Idle/AIda_idle_0020.png" id="22_r1p7p"]
[ext_resource type="Texture2D" uid="uid://okq8fkonytxm" path="res://Animations/AIda/Idle/AIda_idle_0021.png" id="23_g6pxa"]
[ext_resource type="Texture2D" uid="uid://dmpbp2ycpme0d" path="res://Animations/AIda/Idle/AIda_idle_0022.png" id="24_ob116"]
[ext_resource type="Texture2D" uid="uid://bjs8bxv1kkp1j" path="res://Animations/AIda/Idle/AIda_idle_0023.png" id="25_dxcwj"]
[ext_resource type="Texture2D" uid="uid://w8qcsrcpfibn" path="res://Animations/AIda/Idle/AIda_idle_0024.png" id="26_joril"]
[ext_resource type="Texture2D" uid="uid://p3xfl3qi0yt" path="res://Animations/AIda/Walk/Aida_walking_0001.png" id="27_b36qa"]
[ext_resource type="Texture2D" uid="uid://cm6wdi1xu3axm" path="res://Animations/AIda/Walk/Aida_walking_0002.png" id="28_xoi07"]
[ext_resource type="Texture2D" uid="uid://cs8knrftlrb27" path="res://Animations/AIda/Walk/Aida_walking_0003.png" id="29_f5e6k"]
[ext_resource type="Texture2D" uid="uid://yf5wvort68sq" path="res://Animations/AIda/Walk/Aida_walking_0004.png" id="30_pvvs7"]
[ext_resource type="Texture2D" uid="uid://erlbr055rc0h" path="res://Animations/AIda/Walk/Aida_walking_0005.png" id="31_0qbb8"]
[ext_resource type="Texture2D" uid="uid://bbi4iwca7a1ix" path="res://Animations/AIda/Walk/Aida_walking_0006.png" id="32_fqh8o"]
[ext_resource type="Texture2D" uid="uid://c1l4ago0mrn7i" path="res://Animations/AIda/Walk/Aida_walking_0007.png" id="33_j51ha"]
[ext_resource type="Texture2D" uid="uid://c6a2cjojiwtxa" path="res://Animations/AIda/Walk/Aida_walking_0008.png" id="34_2wnib"]

[sub_resource type="Gradient" id="Gradient_sqtfq"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.6041096)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_mhq4g"]
gradient = SubResource("Gradient_sqtfq")
fill = 1
fill_from = Vector2(0.50427353, 0.5)
fill_to = Vector2(0.008547009, 0.014957265)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_hsqv2"]
size = Vector2(275, 1010)

[sub_resource type="Animation" id="Animation_wanmg"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("1_rbbfu")]
}

[sub_resource type="Animation" id="Animation_b36qa"]
resource_name = "fix_toilet"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0.083, 0.167, 0.25, 0.333, 0.417, 0.5, 0.583, 0.667, 0.75, 0.833, 0.917, 1, 1.083, 1.167, 1.25, 1.333, 1.417, 1.5, 1.583, 1.667, 1.75, 1.833, 1.917, 2),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("4_a1bqy"), ExtResource("5_4dvv0"), ExtResource("6_mruqf"), ExtResource("7_yi4fc"), ExtResource("8_d3mpw"), ExtResource("9_o60a8"), ExtResource("10_5xdnd"), ExtResource("11_b36qa"), ExtResource("12_xoi07"), ExtResource("13_f5e6k"), ExtResource("14_pvvs7"), ExtResource("15_0qbb8"), ExtResource("16_fqh8o"), ExtResource("17_j51ha"), ExtResource("18_2wnib"), ExtResource("19_mhq4g"), ExtResource("20_6eamu"), ExtResource("21_fj1q1"), ExtResource("22_r1p7p"), ExtResource("23_g6pxa"), ExtResource("24_ob116"), ExtResource("25_dxcwj"), ExtResource("26_joril"), ExtResource("1_rbbfu")]
}

[sub_resource type="Animation" id="Animation_eyku3"]
resource_name = "idle"
length = 2.0
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0.083, 0.167, 0.25, 0.333, 0.417, 0.5, 0.583, 0.667, 0.75, 0.833, 0.917, 1, 1.083, 1.167, 1.25, 1.333, 1.417, 1.5, 1.583, 1.667, 1.75, 1.833, 1.917, 2),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("4_a1bqy"), ExtResource("5_4dvv0"), ExtResource("6_mruqf"), ExtResource("7_yi4fc"), ExtResource("8_d3mpw"), ExtResource("9_o60a8"), ExtResource("10_5xdnd"), ExtResource("11_b36qa"), ExtResource("12_xoi07"), ExtResource("13_f5e6k"), ExtResource("14_pvvs7"), ExtResource("15_0qbb8"), ExtResource("16_fqh8o"), ExtResource("17_j51ha"), ExtResource("18_2wnib"), ExtResource("19_mhq4g"), ExtResource("20_6eamu"), ExtResource("21_fj1q1"), ExtResource("22_r1p7p"), ExtResource("23_g6pxa"), ExtResource("24_ob116"), ExtResource("25_dxcwj"), ExtResource("26_joril"), ExtResource("1_rbbfu")]
}

[sub_resource type="Animation" id="Animation_6eamu"]
resource_name = "walk"
length = 0.666
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.0833, 0.1667, 0.25, 0.33333334, 0.4167, 0.5, 0.5833, 0.666),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("27_b36qa"), ExtResource("28_xoi07"), ExtResource("29_f5e6k"), ExtResource("30_pvvs7"), ExtResource("31_0qbb8"), ExtResource("32_fqh8o"), ExtResource("33_j51ha"), ExtResource("34_2wnib"), ExtResource("27_b36qa")]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_cvq8c"]
_data = {
&"RESET": SubResource("Animation_wanmg"),
&"fix_toilet": SubResource("Animation_b36qa"),
&"idle": SubResource("Animation_eyku3"),
&"walk": SubResource("Animation_6eamu")
}

[node name="AIda" type="CharacterBody2D"]
script = ExtResource("1_c6jtv")

[node name="FloorShadow" type="Sprite2D" parent="."]
modulate = Color(0.16546667, 0.126, 0.2, 0.32941177)
position = Vector2(-2.4999847, 525)
scale = Vector2(8.453125, 1.7708337)
texture = SubResource("GradientTexture2D_mhq4g")

[node name="Sprite" type="Sprite2D" parent="."]
texture = ExtResource("1_rbbfu")

[node name="MovementController" type="Node" parent="."]
script = ExtResource("13_5x1vy")

[node name="InteractionArea" type="Area2D" parent="."]

[node name="InteractionClickShape" type="CollisionShape2D" parent="InteractionArea"]
position = Vector2(-9.5, 7)
shape = SubResource("RectangleShape2D_hsqv2")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_cvq8c")
}
</file>

<file path="AidaDialogue.tscn">
[gd_scene load_steps=4 format=3 uid="uid://c4v86fmondjfo"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_2hui6"]
[ext_resource type="Resource" uid="uid://ccyinn2ynsx1p" path="res://AIda.dialogue" id="2_2hui6"]
[ext_resource type="Texture2D" uid="uid://cpbqty51mjfsj" path="res://Backgrounds/Aida/aida_hospital_base.png" id="3_5kjlo"]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 2
script = ExtResource("1_2hui6")
conversation_dialogue_file = ExtResource("2_2hui6")
initial_animation_name = ""

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(959, 540)
scale = Vector2(0.498958, 0.500926)
texture = ExtResource("3_5kjlo")

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6

[node name="MentalImageSprite" type="Sprite2D" parent="RootContainer"]
</file>

<file path="Boot.gd">
# Boot.gd
extends Node

const LOGO_SPLASH_SCENE_PATH = "res://logo_splash.tscn"

func _ready():
	if not GameManager:
		print_rich("[color=red]Boot Error: GameManager not found! Cannot proceed.[/color]")
		return

	start_logo_splash()


func start_logo_splash():
	print_rich("[color=yellow]Boot: Starting logo splash...[/color]")

	if GameManager:
		GameManager.change_game_state(GameManager.GameState.LOGO_SPLASH)

	var logo_splash_packed_scene = load(LOGO_SPLASH_SCENE_PATH)
	if not logo_splash_packed_scene:
		print_rich("[color=red]Boot Error: Failed to load Logo Splash Scene at path: %s[/color]" % LOGO_SPLASH_SCENE_PATH)
		# If the logo fails, go straight to the menu
		if GameManager:
			GameManager.change_game_state(GameManager.GameState.MAIN_MENU)
		return

	var logo_splash_instance = logo_splash_packed_scene.instantiate()

	if not logo_splash_instance.has_signal("splash_finished"):
		print_rich("[color=red]Boot Error: LogoSplash scene does not have a 'splash_finished' signal. Cannot proceed automatically.[/color]")
		add_child(logo_splash_instance)
		return

	logo_splash_instance.splash_finished.connect(_on_logo_splash_finished, CONNECT_ONE_SHOT)
	add_child(logo_splash_instance)


func _on_logo_splash_finished():
	print_rich("[color=yellow]Boot: Logo splash finished. Transitioning to main menu...[/color]")
	if GameManager:
		GameManager.change_game_state(GameManager.GameState.MAIN_MENU)
</file>

<file path="ConversationEventManager.gd">
# ConversationEventManager.gd
extends Node


# Signal to request a background change in the active conversation overlay
# We pass the new texture path as an argument.
signal change_conversation_background(new_background_texture_path: String)

# You can add more conversation-related signals here later if needed,
# e.g., for character sprite changes, sound effects, etc.
var show_special_response: bool = false

#Sergey's variables
var has_heard_fresh_start_line: bool = false
</file>

<file path="hospital_door.tscn">
[gd_scene load_steps=4 format=3 uid="uid://cxo2auakscy0h"]

[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="1_qr4xx"]
[ext_resource type="Texture2D" uid="uid://dp8i02xba8j7y" path="res://Sprites/Hospital Room/hospital_room_door.png" id="2_qr4xx"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_rhf3t"]
size = Vector2(697, 1259)

[node name="ExitDoor" type="Area2D"]
script = ExtResource("1_qr4xx")
object_display_name = "Exit Door"
object_id = "exit_door"

[node name="ObjectSprite" type="Sprite2D" parent="."]
texture = ExtResource("2_qr4xx")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-2.5, 1.5)
shape = SubResource("RectangleShape2D_rhf3t")

[node name="WalkToPoint" type="Marker2D" parent="."]
position = Vector2(0, 381)
</file>

<file path="InteractionResponse.gd">
# res://interactions/InteractionResponse.gd
class_name InteractionResponse
extends Resource

## The verb that the player must use (e.g., "use", "examine", "pickup").
@export var verb_id: String = ""

## If not empty, this is the item the player must have selected ("in hand").
@export var required_item_id: String = ""

## Optional: The name of a game flag that must be checked.
@export var required_flag_id: String = ""
## The value the flag must have for this interaction to be valid.
@export var required_flag_value: bool = true

# --- ADD THIS VARIABLE ---
## Checked: Player walks to object. Unchecked: Player acts from current position (remote).
@export var requires_walk: bool = true 
# -------------------------

## The sequence of actions to perform if the conditions are met.
@export var actions_to_perform: Array[Action]
</file>

<file path="InventoryUI.gd">
# InventoryUI.gd
extends CanvasLayer

# --- Node References ---
@onready var item_name_hover_label: Label = $ItemNameHoverLabel
@onready var inventory_grid_container: GridContainer = $InventoryGridPanel/InventoryGridContainer
@onready var up_button: Button = $InventoryGridPanel/UpButton
@onready var down_button: Button = $InventoryGridPanel/DownButton

# --- Configuration ---
const ITEMS_PER_PAGE: int = 6 # 3 columns * 2 rows
const EQUIPPED_INDICATOR_NODE_NAME: String = "EquippedIndicator"
const ITEM_ICON_NODE_NAME: String = "ItemIcon"


# --- State Variables ---
var all_inventory_slots: Array[Button] = [] # Will hold the 6 Button nodes for slots
var current_player_inventory_cache: Array[ItemData] = [] # Local cache of player's items
var current_page_index: int = 0
var total_pages: int = 0

var _hover_label_stylebox: StyleBoxFlat = null


func _ready():
	# Validate node paths
	if not item_name_hover_label: print_rich("[color=red]InventoryUI: ItemNameHoverLabel not found![/color]")
	if not inventory_grid_container: print_rich("[color=red]InventoryUI: InventoryGridContainer not found![/color]"); return
	if not up_button: print_rich("[color=red]InventoryUI: UpButton not found![/color]")
	if not down_button: print_rich("[color=red]InventoryUI: DownButton not found![/color]")

	if inventory_grid_container:
		inventory_grid_container.columns = 3 # Ensure 3 columns for 3x2 layout

	# --- Initialize Hover Label ---
	if item_name_hover_label:
		item_name_hover_label.visible = false
		_hover_label_stylebox = StyleBoxFlat.new()
		_hover_label_stylebox.bg_color = Color(0.1, 0.1, 0.1, 0.8)
		_hover_label_stylebox.set_content_margin_all(5)
		_hover_label_stylebox.corner_radius_top_left = 3
		_hover_label_stylebox.corner_radius_top_right = 3
		_hover_label_stylebox.corner_radius_bottom_left = 3
		_hover_label_stylebox.corner_radius_bottom_right = 3
		item_name_hover_label.add_theme_stylebox_override("panel", _hover_label_stylebox)

	# --- Initialize exactly ITEMS_PER_PAGE slot buttons ---
	# Clear any existing children from the editor (good practice)
	for child in inventory_grid_container.get_children():
		inventory_grid_container.remove_child(child)
		child.queue_free()
	all_inventory_slots.clear()

	for i in range(ITEMS_PER_PAGE):
		var slot_button = Button.new()
		slot_button.name = "InventorySlotButton_" + str(i)
		slot_button.custom_minimum_size = Vector2(60, 60) # Adjusted for label space
		slot_button.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		slot_button.size_flags_vertical = Control.SIZE_EXPAND_FILL
		slot_button.disabled = true # Start disabled
		slot_button.focus_mode = Control.FOCUS_NONE # Prevent keyboard focus unless desired
		slot_button.clip_text = true # Might be useful if text ever overflows

		# Add a TextureRect inside the button for the icon
		var icon_rect = TextureRect.new()
		icon_rect.name = ITEM_ICON_NODE_NAME
		icon_rect.expand_mode = TextureRect.EXPAND_IGNORE_SIZE
		icon_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
		icon_rect.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT, Control.PRESET_MODE_MINSIZE, 2)
		icon_rect.mouse_filter = Control.MOUSE_FILTER_IGNORE
		slot_button.add_child(icon_rect)

		# Add "Equipped" Indicator Label to each slot
		var equipped_label = Label.new()
		equipped_label.name = EQUIPPED_INDICATOR_NODE_NAME
		equipped_label.text = "Selected" # Changed text to "Selected" for clarity
		equipped_label.visible = false # Initially hidden
		equipped_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		equipped_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
		equipped_label.autowrap_mode = TextServer.AUTOWRAP_WORD
		equipped_label.clip_text = true

		var label_stylebox = StyleBoxFlat.new()
		label_stylebox.bg_color = Color(0.9, 0.9, 0.9, 0.85) # Light gray, slightly transparent
		label_stylebox.border_width_left = 1
		label_stylebox.border_width_right = 1
		label_stylebox.border_width_top = 1
		label_stylebox.border_width_bottom = 1
		label_stylebox.border_color = Color(0.3, 0.3, 0.3, 0.9)
		label_stylebox.set_content_margin_all(1) # Smaller margin
		label_stylebox.corner_radius_top_left = 3
		label_stylebox.corner_radius_bottom_right = 3
		equipped_label.add_theme_stylebox_override("normal", label_stylebox)
		equipped_label.add_theme_color_override("font_color", Color.BLACK)
		equipped_label.add_theme_font_size_override("font_size", 10) # Smaller font

		# Positioning the "Equipped" label at the top right of the button.
		# This uses anchors to make it relative to the button's size.
		# Adjust these values as needed for your desired look.
		equipped_label.set_anchor(SIDE_LEFT, 0.55)   # Start from 55% from the left
		equipped_label.set_anchor(SIDE_TOP, 0.05)    # Start 5% from the top
		equipped_label.set_anchor(SIDE_RIGHT, 0.95)  # End at 95% from the left (making it 40% wide)
		equipped_label.set_anchor(SIDE_BOTTOM, 0.30) # End at 30% from the top (making it 25% tall)
		# Ensure offsets are zero if using anchors like this for full control by anchors
		equipped_label.offset_left = 0
		equipped_label.offset_top = 0
		equipped_label.offset_right = 0
		equipped_label.offset_bottom = 0

		slot_button.add_child(equipped_label)

		all_inventory_slots.append(slot_button)
		inventory_grid_container.add_child(slot_button)

	# --- Connect to GameManager Signals ---
	if GameManager:
		GameManager.inventory_updated.connect(_on_game_manager_inventory_updated)
		GameManager.selected_inventory_item_changed.connect(_on_game_manager_selected_item_changed)
		GameManager.interaction_complete.connect(_on_interaction_complete)

		if GameManager.has_method("get_player_inventory"):
			_on_game_manager_inventory_updated(GameManager.get_player_inventory())
		else:
			print_rich("[color=orange]InventoryUI: GameManager has no get_player_inventory method.[/color]")
	else:
		print_rich("[color=red]InventoryUI: GameManager not found![/color]")

	# --- Connect Pagination Buttons ---
	if up_button: up_button.pressed.connect(_on_up_button_pressed)
	if down_button: down_button.pressed.connect(_on_down_button_pressed)

	_update_pagination_buttons_state() # Initial state


func _process(_delta: float) -> void:
	if item_name_hover_label and item_name_hover_label.visible:
		item_name_hover_label.global_position = get_viewport().get_mouse_position() + Vector2(20, -30)


func _on_game_manager_inventory_updated(full_inventory_data: Array[ItemData]):
	current_player_inventory_cache = full_inventory_data.duplicate() # Store a copy

	total_pages = 1 if current_player_inventory_cache.is_empty() else ceil(float(current_player_inventory_cache.size()) / ITEMS_PER_PAGE)
	current_page_index = clamp(current_page_index, 0, max(0, total_pages - 1))

	_render_current_page() # This will also update selected state via its call to _update_slot_selected_visual_state
	_update_pagination_buttons_state()
	# _update_slot_selected_visual_state is called at the end of _render_current_page


func _render_current_page():
	if not is_instance_valid(inventory_grid_container):
		print_rich("[color=red]InventoryUI: _render_current_page - InventoryGridContainer is null or invalid![/color]")
		return
	if all_inventory_slots.is_empty():
		print_rich("[color=yellow]InventoryUI: _render_current_page - all_inventory_slots is empty.[/color]")
		return

	var start_index = current_page_index * ITEMS_PER_PAGE

	for i in range(all_inventory_slots.size()):
		var slot_button: Button = all_inventory_slots[i]
		if not is_instance_valid(slot_button): continue

		var icon_rect: TextureRect = slot_button.get_node_or_null(ITEM_ICON_NODE_NAME)

		# Disconnect old signals using string names
		var pressed_callable = Callable(self, "_on_inventory_slot_pressed")
		if slot_button.is_connected("pressed", pressed_callable):
			slot_button.disconnect("pressed", pressed_callable)

		var mouse_entered_callable = Callable(self, "_on_slot_mouse_entered")
		if slot_button.is_connected("mouse_entered", mouse_entered_callable):
			slot_button.disconnect("mouse_entered", mouse_entered_callable)

		var mouse_exited_callable = Callable(self, "_on_slot_mouse_exited")
		if slot_button.is_connected("mouse_exited", mouse_exited_callable):
			slot_button.disconnect("mouse_exited", mouse_exited_callable)

		var inventory_item_index = start_index + i
		if inventory_item_index < current_player_inventory_cache.size():
			var item_data: ItemData = current_player_inventory_cache[inventory_item_index]

			if not is_instance_valid(item_data):
				print_rich("[color=red]InventoryUI: _render_current_page - ItemData at inventory index %s is invalid![/color]" % inventory_item_index)
				slot_button.disabled = true
				slot_button.set_meta("item_data", null)
				if icon_rect: icon_rect.texture = null; icon_rect.visible = false
				var equipped_label: Label = slot_button.get_node_or_null(EQUIPPED_INDICATOR_NODE_NAME)
				if equipped_label: equipped_label.visible = false
				slot_button.text = "ERR"
				continue

			slot_button.disabled = false
			slot_button.set_meta("item_data", item_data)

			if icon_rect:
				icon_rect.texture = item_data.icon
				icon_rect.visible = (item_data.icon != null)

				if icon_rect.visible:
					slot_button.text = "" # Clear button text if icon is visible
				else:
					slot_button.text = item_data.display_name.substr(0, 3) if item_data.display_name else "???"
			else:
				print_rich("[color=yellow]InventoryUI: _render_current_page - ItemIcon TextureRect missing in slot %s.[/color]" % i)
				slot_button.text = item_data.display_name.substr(0,3) if item_data.display_name else "???"

			slot_button.pressed.connect(_on_inventory_slot_pressed.bind(item_data))
			slot_button.mouse_entered.connect(_on_slot_mouse_entered.bind(item_data, slot_button))
			slot_button.mouse_exited.connect(_on_slot_mouse_exited)
		else:
			# This slot is empty for the current page
			slot_button.disabled = true
			slot_button.set_meta("item_data", null)
			if icon_rect:
				icon_rect.texture = null
				icon_rect.visible = false
			var equipped_label: Label = slot_button.get_node_or_null(EQUIPPED_INDICATOR_NODE_NAME)
			if equipped_label: equipped_label.visible = false # Hide for empty slots
			slot_button.text = "-" # Placeholder for empty slot

	# After rendering all slots, update visual state for selected item (modulation and "Selected" label)
	if GameManager:
		_update_slot_selected_visual_state(GameManager.current_selected_item_data)
	else:
		_update_slot_selected_visual_state(null) # Ensure no selection if GM missing


func _on_inventory_slot_pressed(item_data_pressed: ItemData):
	SoundManager.play_sfx("ui_click", 1.5)
	if GameManager and item_data_pressed: # Ensure item_data_pressed is not null
		GameManager.select_inventory_item(item_data_pressed)
	elif GameManager and not item_data_pressed: # If somehow an empty slot button was pressed (should be disabled)
		GameManager.select_inventory_item(null) # Explicitly deselect


func _on_slot_mouse_entered(item_data_hovered: ItemData, _slot_button_node: Button):
	if item_name_hover_label and item_data_hovered:
		item_name_hover_label.text = item_data_hovered.display_name
		item_name_hover_label.visible = true


func _on_slot_mouse_exited():
	if item_name_hover_label:
		item_name_hover_label.visible = false


func _on_game_manager_selected_item_changed(selected_item_data: ItemData):
	# This function is called when GameManager's selected_inventory_item_changed signal is emitted.
	# It's responsible for updating the visual state of all slots.
	_update_slot_selected_visual_state(selected_item_data)

	# Also, if no item is selected, ensure the general item hover label is hidden.
	if item_name_hover_label and selected_item_data == null :
		item_name_hover_label.visible = false


func _on_interaction_complete():
	# When an interaction cycle completes, the item is usually deselected from "hand".
	# GameManager's selected_inventory_item_changed signal will be emitted (with null),
	# so _update_slot_selected_visual_state will handle hiding the "Selected" label.
	# We might still want to hide the general item hover label if it was somehow stuck.
	if item_name_hover_label:
		item_name_hover_label.visible = false


func _update_slot_selected_visual_state(selected_item_data: ItemData):
	# This function updates both the button modulation (highlight) AND the "Selected" label visibility.
	for slot_button in all_inventory_slots:
		if not is_instance_valid(slot_button): continue

		var slot_item_data = slot_button.get_meta("item_data", null)
		var equipped_indicator: Label = slot_button.get_node_or_null(EQUIPPED_INDICATOR_NODE_NAME)

		var is_this_slot_selected = false
		if slot_item_data and selected_item_data: # Both must be valid
			if slot_item_data.item_id == selected_item_data.item_id:
				is_this_slot_selected = true

		# Update modulation (highlight)
		if is_this_slot_selected:
			slot_button.modulate = Color(0.7, 0.7, 1.0, 1.0) # Highlight color
		else:
			slot_button.modulate = Color(1.0, 1.0, 1.0, 1.0) # Default color

		# Update "Selected" indicator visibility
		if equipped_indicator:
			equipped_indicator.visible = is_this_slot_selected
		elif slot_item_data and not equipped_indicator: # Log if label is missing but there's an item in slot
			print_rich("[color=orange]InventoryUI: '%s' label missing in slot for item '%s'[/color]" % [EQUIPPED_INDICATOR_NODE_NAME, slot_item_data.display_name])


# --- Pagination Logic ---
func _on_up_button_pressed():
	SoundManager.play_sfx("ui_click", 1.5)
	if current_page_index > 0:
		current_page_index -= 1
		_render_current_page()
		_update_pagination_buttons_state()

func _on_down_button_pressed():
	SoundManager.play_sfx("ui_click", 1.5)
	if current_page_index < total_pages - 1:
		current_page_index += 1
		_render_current_page()
		_update_pagination_buttons_state()

func _update_pagination_buttons_state():
	if up_button: up_button.disabled = (current_page_index == 0)
	if down_button: down_button.disabled = (current_page_index >= total_pages - 1)
</file>

<file path="InventoryUI.tscn">
[gd_scene load_steps=4 format=3 uid="uid://cud6uaak7lo18"]

[ext_resource type="Script" uid="uid://bqkeu73kdy6ue" path="res://InventoryUI.gd" id="1_dsn3v"]
[ext_resource type="Theme" uid="uid://bbh4rjwcxnama" path="res://Themes/verb_and_inventory_theme.tres" id="2_xlonu"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_xlonu"]
bg_color = Color(0.792157, 0.870588, 0.952941, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.627451, 0.827451, 0.988235, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[node name="InventoryUI_CanvasLayer" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_dsn3v")

[node name="InventoryGridPanel" type="Panel" parent="."]
anchors_preset = -1
anchor_left = 0.504
anchor_top = 0.805
anchor_right = 0.788
anchor_bottom = 0.991
offset_left = 0.320007
offset_top = -0.400024
offset_right = 0.039917
offset_bottom = -4.28003
grow_horizontal = 2
grow_vertical = 2
scale = Vector2(1, 1.02276)
size_flags_horizontal = 3
size_flags_vertical = 3
theme = ExtResource("2_xlonu")

[node name="InventoryGridContainer" type="GridContainer" parent="InventoryGridPanel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.037
anchor_top = 0.069
anchor_right = 0.806
anchor_bottom = 0.933
theme = ExtResource("2_xlonu")
columns = 3

[node name="Panel" type="Panel" parent="InventoryGridPanel"]
layout_mode = 1
anchors_preset = -1
anchor_top = -0.203
anchor_right = 0.294
offset_left = 2.0
offset_top = -0.00899887
offset_right = -0.229965

[node name="InventoryLabel" type="Label" parent="InventoryGridPanel/Panel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.127
anchor_top = 0.169
anchor_right = 0.848
anchor_bottom = 0.794
offset_left = -0.066
offset_top = -0.00334787
offset_right = 0.0159912
offset_bottom = -0.0033493
theme = ExtResource("2_xlonu")
text = "INVENTORY"

[node name="UpButton" type="Button" parent="InventoryGridPanel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.863
anchor_top = 0.108
anchor_right = 0.962
anchor_bottom = 0.321
offset_left = 0.0949707
offset_right = 0.0949707
theme = ExtResource("2_xlonu")
text = "UP"

[node name="DownButton" type="Button" parent="InventoryGridPanel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.857
anchor_top = 0.615
anchor_right = 0.956
anchor_bottom = 0.828
offset_bottom = -0.0720367
theme = ExtResource("2_xlonu")
text = "DOWN"

[node name="ExamineItemLabel" type="Label" parent="."]
offset_right = 40.0
offset_bottom = 23.0
theme = ExtResource("2_xlonu")

[node name="ItemNameHoverLabel" type="Label" parent="."]
offset_right = 87.0
offset_bottom = 23.0
theme = ExtResource("2_xlonu")
theme_override_styles/normal = SubResource("StyleBoxFlat_xlonu")
text = "Item Name"
</file>

<file path="Main.gd">
# Main.gd (script attached to your 'Main' root node)
extends Control

# --- Level-Specific Event Resources ---
@export var aida_dialogue_resource: DialogueResource
@export var aida_explanation_data: ExplanationData

# --- UPDATED: Sergei References (Instead of McBucket) ---
# The new conversation scene for Sergei (e.g., Test_Conversation.tscn)
@export var sergei_after_drug_overlay_scene: PackedScene 
# The InteractionArea node attached to Sergei
@export var sergei_interactable: Interactable 

# --- Node References ---
@onready var level_state_manager: LevelStateManager = $LevelStateManager


func _ready():
	# We must wait for one frame. This is a crucial step.
	await get_tree().process_frame

	# --- 1. Hide UI Button on Start ---
	if is_instance_valid(GameManager.insurance_form_button_ui):
		GameManager.insurance_form_button_ui.hide()
	else:
		print_rich("[color=orange]Main.gd: Could not hide insurance button on start, GameManager reference is invalid.[/color]")

	# --- 2. Setup Global Signals ---
	if GameManager:
		# Connect to signal so we know when Aida finishes talking
		GameManager.character_conversation_ended.connect(_on_character_conversation_ended)
		
		# Register this level's state manager
		if is_instance_valid(level_state_manager):
			GameManager.register_level_state_manager(level_state_manager)
		else:
			print_rich("[color=red]%s: LevelStateManager node not found...[/color]" % name)
	else:
		print_rich("[color=red]%s: GameManager not found.[/color]" % name)

	# --- 3. Setup Logic for Level Flags (Sergei Reacting to Drugs) ---
	if is_instance_valid(level_state_manager):
		# A. Connect to the flag change signal (Real-time updates)
		if not level_state_manager.level_flag_changed.is_connected(_on_level_flag_changed):
			level_state_manager.level_flag_changed.connect(_on_level_flag_changed)

		# B. Check current state immediately (For Save/Load or Restart)
		# If McBucket is already asleep, switch Sergei's dialogue immediately.
		if level_state_manager.get_level_flag("mcbucket_zanopram_used"):
			_update_sergei_overlay()


func _exit_tree():
	if GameManager and is_instance_valid(level_state_manager):
		if GameManager.current_level_state_manager == level_state_manager:
			GameManager.register_level_state_manager(null)
			print_rich("[color=yellow]%s: Unregistered its LevelStateManager.[/color]" % name)


# --- SIGNAL HANDLERS ---

func _on_character_conversation_ended(resource: DialogueResource):
	if resource == aida_dialogue_resource:
		var just_spoke_to_aida = level_state_manager.get_level_flag("has_spoken_to_aida")
		var explanation_shown = level_state_manager.get_level_flag("aida_explanation_shown")

		if just_spoke_to_aida and not explanation_shown:
			level_state_manager.set_level_flag("aida_explanation_shown", true)
			level_state_manager.set_level_flag("insurance_button_unlocked", true)
			GameManager.start_explanation(aida_explanation_data, self)


func _on_level_flag_changed(flag_name: String, new_value: bool):
	# Listen specifically for the drug flag
	if flag_name == "mcbucket_zanopram_used" and new_value == true:
		print("Main.gd: McBucket drugged. Updating Sergei's dialogue.")
		_update_sergei_overlay()


# --- HELPER FUNCTIONS ---

func _update_sergei_overlay():
	# Check if we have the reference to Sergei and the new Scene
	if is_instance_valid(sergei_interactable) and sergei_after_drug_overlay_scene:
		# Overwrite Sergei's overlay scene with the new one
		sergei_interactable.character_conversation_overlay_scene = sergei_after_drug_overlay_scene
		print("Main.gd: Sergei's overlay successfully swapped.")
	else:
		print_rich("[color=red]Main.gd Error: Cannot swap Sergei's overlay. Check Inspector assignments.[/color]")
</file>

<file path="player.gd">
extends CharacterBody2D

const SPEED = 700.0
const GRAVITY = 800.0 # Make sure this matches your project settings if you use built-in gravity
const WALK_TO_THRESHOLD_X = 5.0 # How close on X axis to stop
const INTERACTION_OFFSET_X = 30.0 # Horizontal offset from the interactable's actual WalkToPoint.x

@onready var sprite_2d: Sprite2D = $Sprite # Ensure this node path is correct
@onready var animation_player: AnimationPlayer = $AnimationPlayer # Ensure this node path is correct

var current_animation_state = "idle"

var _is_walking_to_target: bool = false
var _actual_walk_destination: Vector2      # The final calculated X,Y point the player moves to
var _start_walk_position_x: float = 0.0    # ADDED: To prevent overshooting
var _interactable_after_walk: Interactable = null
var _verb_for_interaction: String = ""
var _item_for_interaction: ItemData = null # MODIFIED: Store ItemData, initialize to null

var _can_move: bool = true

func _ready():
	# Ensure nodes are valid
	if not sprite_2d: print_rich("[color=red]Player: Sprite2D node not found![/color]")
	if not animation_player: print_rich("[color=red]Player: AnimationPlayer node not found![/color]")
	play_animation("idle")

func _physics_process(delta: float):
	if not _can_move:
		if is_instance_valid(animation_player): # Check if node is still valid
			set_animation_state("idle") # Keep playing idle animation
		velocity.x = 0 # Stop horizontal movement
		# Apply gravity if not on floor
		if not is_on_floor():
			velocity.y += GRAVITY * delta
		else:
			velocity.y = 0 # Or a small downward force if needed for slopes
		move_and_slide()
		return

	if _is_walking_to_target:
		var direction_to_destination = global_position.direction_to(_actual_walk_destination)
		var x_distance_to_destination = abs(global_position.x - _actual_walk_destination.x)

		# --- This is the corrected arrival logic to prevent overshooting ---
		var direction_from_start = sign(_actual_walk_destination.x - _start_walk_position_x)
		var direction_from_current = sign(_actual_walk_destination.x - global_position.x)

		# The walk continues IF we are still approaching the target from the original direction.
		var has_not_reached_target = (direction_from_start == direction_from_current)

		if has_not_reached_target and x_distance_to_destination > WALK_TO_THRESHOLD_X:
			velocity.x = direction_to_destination.x * SPEED
			if not is_on_floor():
				velocity.y += GRAVITY * delta
			else: # On floor, gentle Y velocity adjustment
				velocity.y = move_toward(velocity.y, 0, GRAVITY * delta * 0.1)

			if is_instance_valid(sprite_2d): sprite_2d.flip_h = (velocity.x < 0)
			set_animation_state("walk")
		# --- END OF MODIFICATION ---
		else: # Reached destination
			velocity = Vector2.ZERO # Stop all movement
			_is_walking_to_target = false
			set_animation_state("idle")

			# --- THIS IS THE NEW, CRITICAL LINE ---
			# Tell the GameManager that ANY walk command is now finished, unlocking mouse input.
			if GameManager and GameManager.has_method("player_has_finished_walk_command"):
				GameManager.player_has_finished_walk_command()
			# -------------------------------------

			if is_instance_valid(_interactable_after_walk):
				face_target(_interactable_after_walk.global_position) # Face the interactable

				var interactable_ref = _interactable_after_walk
				var verb_ref = _verb_for_interaction
				var item_ref = _item_for_interaction

				# Clear player's state for this interaction
				_interactable_after_walk = null
				_verb_for_interaction = ""
				_item_for_interaction = null

				# Tell GameManager the player has arrived to trigger the interaction
				if GameManager and GameManager.has_method("player_reached_interaction_target"):
					GameManager.player_reached_interaction_target(interactable_ref, verb_ref, item_ref)
				else:
					print_rich("[color=red]Player: GameManager or player_reached_interaction_target method not found![/color]")
			else:
				print_rich("[color=yellow]Player: Reached walk target point.[/color]")
		move_and_slide()
		return

	# --- No keyboard input, just apply physics when idle ---
	if not is_on_floor():
		velocity.y += GRAVITY * delta
	else: # On floor
		velocity.y = move_toward(velocity.y, 0, GRAVITY * delta * 0.1) # Gentle Y damping

	# Apply friction to stop sliding
	velocity.x = move_toward(velocity.x, 0, SPEED * 0.5)
	if abs(velocity.x) < 1.0 : velocity.x = 0

	# Only set idle animation if we're not already trying to walk somewhere
	if not _is_walking_to_target:
		set_animation_state("idle")

	move_and_slide()


## Called by GameManager to walk to a generic point in the world.
func walk_to_point(destination_pos: Vector2):
	if not _can_move:
		print("Player: Cannot walk_to_point, _can_move is false.")
		return

	# Clear any pending interaction, as this is just a move command.
	_interactable_after_walk = null
	_verb_for_interaction = ""
	_item_for_interaction = null

	_actual_walk_destination.x = destination_pos.x
	_actual_walk_destination.y = global_position.y

	_start_walk_position_x = global_position.x
	_is_walking_to_target = true

	print("Player: Walking to point: %s" % str(_actual_walk_destination))


## Called by GameManager to initiate walking to an interactable
func walk_to_and_interact(interactable_walk_to_point_pos: Vector2, interactable_node: Interactable, verb_id: String, item_data: ItemData):
	if not _can_move:
		print("Player: Cannot walk_to_and_interact, _can_move is false.")
		return

	_interactable_after_walk = interactable_node
	_verb_for_interaction = verb_id
	_item_for_interaction = item_data

	var target_x = interactable_walk_to_point_pos.x
	var target_y = global_position.y

	if global_position.x < target_x: # Player is to the left of the interactable's core X
		_actual_walk_destination.x = target_x - INTERACTION_OFFSET_X
	else: # Player is to the right
		_actual_walk_destination.x = target_x + INTERACTION_OFFSET_X

	_actual_walk_destination.y = target_y

	_start_walk_position_x = global_position.x
	_is_walking_to_target = true

	var item_name_for_log = "None"
	if _item_for_interaction: item_name_for_log = _item_for_interaction.display_name

	print("Player: Original WalkToPoint: %s. Calculated Destination: %s for verb '%s' on '%s' with item '%s'" % [
		str(interactable_walk_to_point_pos),
		str(_actual_walk_destination),
		verb_id,
		interactable_node.object_display_name,
		item_name_for_log
	])

func set_can_move(value: bool):
	_can_move = value
	if not _can_move:
		_is_walking_to_target = false # Cancel any auto-walk
		velocity.x = 0 # Stop horizontal movement immediately
		if not is_on_floor():
			pass
		else:
			velocity.y = 0
		set_animation_state("idle") # Ensure idle animation when movement disabled

func face_target(target_global_position: Vector2):
	if not _can_move and not _is_walking_to_target:
		pass

	if not is_instance_valid(sprite_2d): return

	if target_global_position.x > global_position.x + 1.0: # Add a small threshold
		sprite_2d.flip_h = false # Face right
	elif target_global_position.x < global_position.x - 1.0: # Add a small threshold
		sprite_2d.flip_h = true  # Face left

# --- Animation Helper Functions ---
func set_animation_state(new_state: String):
	if not is_instance_valid(animation_player): return

	if current_animation_state == new_state:
		if not animation_player.is_playing() and animation_player.has_animation(new_state):
			animation_player.play(new_state)
		return

	current_animation_state = new_state
	play_animation(new_state)

func play_animation(anim_name: String):
	if not is_instance_valid(animation_player): return

	if animation_player.has_animation(anim_name):
		animation_player.play(anim_name)
	else:
		print_rich("[color=red]Player: '%s' animation not found in AnimationPlayer.[/color]" % anim_name)
</file>

<file path="player.tscn">
[gd_scene load_steps=41 format=3 uid="uid://ba2cgdy2q1csl"]

[ext_resource type="Script" uid="uid://j0sis8eh01lr" path="res://player.gd" id="1_6ubl7"]
[ext_resource type="Texture2D" uid="uid://djey74n526wpc" path="res://protag_idle/protag_idle_0000.png" id="2_5tmop"]
[ext_resource type="Texture2D" uid="uid://c26bu3dueovgt" path="res://Animations/Protag/Idle/Protag_idle_0002.png" id="3_hl5qd"]
[ext_resource type="Texture2D" uid="uid://drt7l36extpvg" path="res://Animations/Protag/Idle/Protag_idle_0003.png" id="4_ek41f"]
[ext_resource type="Texture2D" uid="uid://xrseuyyi0amp" path="res://Animations/Protag/Idle/Protag_idle_0004.png" id="5_khis8"]
[ext_resource type="Texture2D" uid="uid://chs76j2xvqldv" path="res://Animations/Protag/Idle/Protag_idle_0005.png" id="6_b88wv"]
[ext_resource type="Texture2D" uid="uid://dffgyxf63knqe" path="res://Animations/Protag/Idle/Protag_idle_0006.png" id="7_pgbbb"]
[ext_resource type="Texture2D" uid="uid://7ypxdwg7uhap" path="res://Animations/Protag/Idle/Protag_idle_0007.png" id="8_331ug"]
[ext_resource type="Texture2D" uid="uid://44aj6f800r4o" path="res://Animations/Protag/Idle/Protag_idle_0008.png" id="9_ny14h"]
[ext_resource type="Texture2D" uid="uid://i6b8kix4af57" path="res://Animations/Protag/Idle/Protag_idle_0009.png" id="10_ibah8"]
[ext_resource type="Texture2D" uid="uid://bkj3tc5fthcxw" path="res://Animations/Protag/Idle/Protag_idle_0010.png" id="11_3iwfv"]
[ext_resource type="Texture2D" uid="uid://deucpmbopbyy" path="res://Animations/Protag/Idle/Protag_idle_0011.png" id="12_qwsg1"]
[ext_resource type="Texture2D" uid="uid://dws78lsoswnxp" path="res://Animations/Protag/Idle/Protag_idle_0012.png" id="13_1xqrm"]
[ext_resource type="Texture2D" uid="uid://b2h111uyk32ml" path="res://Animations/Protag/Idle/Protag_idle_0013.png" id="14_bfour"]
[ext_resource type="Texture2D" uid="uid://ccxt15s1vsmml" path="res://Animations/Protag/Idle/Protag_idle_0014.png" id="15_8gr2b"]
[ext_resource type="Texture2D" uid="uid://daqk2w6ubvq31" path="res://Animations/Protag/Idle/Protag_idle_0015.png" id="16_vl8ci"]
[ext_resource type="Texture2D" uid="uid://cl1vbmleumbrr" path="res://Animations/Protag/Idle/Protag_idle_0016.png" id="17_ieltc"]
[ext_resource type="Texture2D" uid="uid://bp3gndhpklgew" path="res://Animations/Protag/Idle/Protag_idle_0017.png" id="18_fddr8"]
[ext_resource type="Texture2D" uid="uid://31fvgohv52t5" path="res://Animations/Protag/Idle/Protag_idle_0018.png" id="19_oybyf"]
[ext_resource type="Texture2D" uid="uid://c3br31vtwosbg" path="res://Animations/Protag/Idle/Protag_idle_0019.png" id="20_ajfva"]
[ext_resource type="Texture2D" uid="uid://d18dr0k8qjv0v" path="res://Animations/Protag/Idle/Protag_idle_0020.png" id="21_5ef02"]
[ext_resource type="Texture2D" uid="uid://j8hhdymcwb0j" path="res://Animations/Protag/Idle/Protag_idle_0021.png" id="22_pfmca"]
[ext_resource type="Texture2D" uid="uid://bc80si6q76mep" path="res://Animations/Protag/Idle/Protag_idle_0022.png" id="23_76oay"]
[ext_resource type="Texture2D" uid="uid://yg6bahkw2a6q" path="res://Animations/Protag/Idle/Protag_idle_0023.png" id="24_b4uyv"]
[ext_resource type="Texture2D" uid="uid://yom0u2trbd7w" path="res://Animations/Protag/Idle/Protag_idle_0024.png" id="25_tw8ou"]
[ext_resource type="Texture2D" uid="uid://fwd18kxfvygu" path="res://Animations/Protag/Walk/Protag_walk_0001.png" id="26_hiqhm"]
[ext_resource type="Texture2D" uid="uid://dlbvhnocpm1w5" path="res://Animations/Protag/Walk/Protag_walk_0002.png" id="27_tkwlq"]
[ext_resource type="Texture2D" uid="uid://bw8vf0lih4j1m" path="res://Animations/Protag/Walk/Protag_walk_0003.png" id="28_hl5qd"]
[ext_resource type="Texture2D" uid="uid://vaya4osfde02" path="res://Animations/Protag/Walk/Protag_walk_0004.png" id="29_ek41f"]
[ext_resource type="Texture2D" uid="uid://bjy3k78sqxos8" path="res://Animations/Protag/Walk/Protag_walk_0005.png" id="30_khis8"]
[ext_resource type="Texture2D" uid="uid://rqxgg4tmupi7" path="res://Animations/Protag/Walk/Protag_walk_0006.png" id="31_b88wv"]
[ext_resource type="Texture2D" uid="uid://mjbdo0wg3ng8" path="res://Animations/Protag/Walk/Protag_walk_0007.png" id="32_pgbbb"]
[ext_resource type="Texture2D" uid="uid://b8tp1ueq7uncy" path="res://Animations/Protag/Walk/Protag_walk_0008.png" id="33_331ug"]

[sub_resource type="Gradient" id="Gradient_hiqhm"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.6041096)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_hiqhm"]
gradient = SubResource("Gradient_hiqhm")
fill = 1
fill_from = Vector2(0.50427353, 0.5)
fill_to = Vector2(0.008547009, 0.014957265)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_keght"]
size = Vector2(220, 935)

[sub_resource type="Animation" id="Animation_ny14h"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [ExtResource("2_5tmop")]
}

[sub_resource type="Animation" id="Animation_i3pqv"]
resource_name = "idle"
length = 2.0
loop_mode = 1
step = 0.8333
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0.0833, 0.1667, 0.25, 0.3333, 0.4167, 0.5, 0.5833, 0.6666, 0.75, 0.8333, 0.9166, 1, 1.0833, 1.1666, 1.2499, 1.3333, 1.4166, 1.4999, 1.5833, 1.667, 1.75, 1.833, 1.917, 2),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("3_hl5qd"), ExtResource("4_ek41f"), ExtResource("5_khis8"), ExtResource("6_b88wv"), ExtResource("7_pgbbb"), ExtResource("8_331ug"), ExtResource("9_ny14h"), ExtResource("10_ibah8"), ExtResource("11_3iwfv"), ExtResource("12_qwsg1"), ExtResource("13_1xqrm"), ExtResource("14_bfour"), ExtResource("15_8gr2b"), ExtResource("16_vl8ci"), ExtResource("17_ieltc"), ExtResource("18_fddr8"), ExtResource("19_oybyf"), ExtResource("20_ajfva"), ExtResource("21_5ef02"), ExtResource("21_5ef02"), ExtResource("22_pfmca"), ExtResource("23_76oay"), ExtResource("24_b4uyv"), ExtResource("25_tw8ou")]
}

[sub_resource type="Animation" id="Animation_ibah8"]
resource_name = "walk"
length = 0.666
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("Sprite:texture")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.0833, 0.1667, 0.25, 0.3333, 0.4167, 0.5, 0.5833, 0.6666),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1, 1, 1, 1),
"update": 1,
"values": [ExtResource("26_hiqhm"), ExtResource("27_tkwlq"), ExtResource("28_hl5qd"), ExtResource("29_ek41f"), ExtResource("30_khis8"), ExtResource("31_b88wv"), ExtResource("32_pgbbb"), ExtResource("33_331ug"), ExtResource("26_hiqhm")]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_hqtel"]
_data = {
&"RESET": SubResource("Animation_ny14h"),
&"idle": SubResource("Animation_i3pqv"),
&"walk": SubResource("Animation_ibah8")
}

[node name="Player" type="CharacterBody2D" groups=["player"]]
script = ExtResource("1_6ubl7")

[node name="FloorShadow" type="Sprite2D" parent="."]
modulate = Color(0.16546667, 0.126, 0.2, 0.32941177)
position = Vector2(-2.4999847, 525)
scale = Vector2(8.453125, 1.7708337)
texture = SubResource("GradientTexture2D_hiqhm")

[node name="Sprite" type="Sprite2D" parent="."]
position = Vector2(8.19647, -8.59983)
texture = ExtResource("2_5tmop")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-12, 12.5)
shape = SubResource("RectangleShape2D_keght")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_hqtel")
}
autoplay = "idle"
</file>

<file path="SoundManager.gd">
# SoundManager.gd
extends Node

# --- Sound Effect Library ---
var sfx_library: Dictionary = {
	"ui_click": preload("res://ui_click.wav"),
	"notification_ping": preload("res://notification_ping.wav"),
	"dialogue_advance": preload("res://Sfx/Dialog/Dialog_sfx.wav"),
	"swish": preload("res://Sfx/Dialog/swish_effect.wav"),
	
	# --- NEW DOOR SOUNDS ---
	"door_close": preload("res://Sfx/Game World/scifi door close.mp3"),
	"door_open": preload("res://Sfx/Game World/scifi door open.mp3"),
	
	# --- HOSPITAL BATHROOM ---
	"hospital_toilet_flush": preload("res://Sfx/Game World/hospital_toilet_flush.mp3")
}

# --- Music Library & Player ---
const MAIN_THEME = preload("res://Sfx/Music/wii menu.mp3")

# A dedicated, persistent player for background music
# It starts as null. We will create it when it's first needed.
var _music_player: AudioStreamPlayer = null


# --- The NEW, SAFE Initialization Function ---
# This is a private function that ensures the music player exists.
func _initialize_music_player():
	# If the player already exists, do nothing.
	if is_instance_valid(_music_player):
		return

	# If it doesn't exist, create and configure it now.
	print_rich("[color=LawnGreen]SoundManager: Initializing music player for the first time.[/color]")
	_music_player = AudioStreamPlayer.new()
	add_child(_music_player)
	# --- FIX: ALLOW MUSIC TO PLAY WHILE GAME IS PAUSED ---
	_music_player.process_mode = Node.PROCESS_MODE_ALWAYS
	# -----------------------------------------------------

	_music_player.stream = MAIN_THEME

	# Set the loop mode for the WAV file
	var audio_stream_wav = _music_player.stream as AudioStreamWAV
	if audio_stream_wav:
		audio_stream_wav.loop_mode = AudioStreamWAV.LOOP_FORWARD


func play_sfx(sound_name: String, pitch: float = 1.0, volume_db: float = 0.0) -> AudioStreamPlayer:
	if not sfx_library.has(sound_name):
		print_rich("[color=red]SoundManager Error: Tried to play non-existent SFX: '%s'[/color]" % sound_name)
		return null # Return null if failed

	var player = AudioStreamPlayer.new()
	add_child(player)
	player.stream = sfx_library[sound_name]
	player.pitch_scale = pitch
	player.volume_db = volume_db
	player.play()
	
	# We still queue_free automatically, but we also return the reference
	player.finished.connect(player.queue_free)
	
	return player


# --- Public Music Functions (Now with Safety Checks) ---
func play_music():
	# --- ADD THIS GUARD ---
	# Before we do anything, make sure the player is ready.
	_initialize_music_player()
	# --------------------

	# Now it's safe to access the player.
	if not _music_player.playing:
		_music_player.play()

func stop_music():
	# --- ADD THIS GUARD ---
	# We even add the check here, just in case stop_music() is ever called first.
	_initialize_music_player()
	# --------------------

	# Now it's safe to access the player.
	_music_player.stop()
</file>

<file path="VerbUI.tscn">
[gd_scene load_steps=4 format=3 uid="uid://bigouorladqds"]

[ext_resource type="Script" uid="uid://npn3pmma7jfq" path="res://VerbUI.gd" id="1_fpe4u"]
[ext_resource type="Theme" uid="uid://bbh4rjwcxnama" path="res://Themes/verb_and_inventory_theme.tres" id="2_5r43t"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_5r43t"]
bg_color = Color(0.79258, 0.870945, 0.954734, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.627399, 0.826419, 0.989882, 1)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[node name="VerbUI_CanvasLayer" type="CanvasLayer"]
process_mode = 3
script = ExtResource("1_fpe4u")

[node name="ActionBubbleLabel" type="Label" parent="."]
offset_right = 40.0
offset_bottom = 23.0
theme = ExtResource("2_5r43t")
theme_override_styles/normal = SubResource("StyleBoxFlat_5r43t")

[node name="VerbGridPanel" type="Panel" parent="."]
anchors_preset = -1
anchor_left = 0.006
anchor_top = 0.805
anchor_right = 0.5
anchor_bottom = 0.99
grow_vertical = 0
size_flags_horizontal = 3
size_flags_vertical = 3
theme = ExtResource("2_5r43t")

[node name="GridContainer" type="GridContainer" parent="VerbGridPanel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_5r43t")
columns = 3

[node name="Panel" type="Panel" parent="."]
offset_left = 15.0
offset_top = 829.0
offset_right = 173.0
offset_bottom = 869.0
theme = ExtResource("2_5r43t")

[node name="ActionsLabel" type="Label" parent="Panel"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.138
anchor_top = 0.118
anchor_right = 0.854
anchor_bottom = 0.853
offset_left = 9.196
offset_top = 2.27999
offset_right = 9.116
offset_bottom = 2.28999
theme = ExtResource("2_5r43t")
text = "ACTIONS"
</file>

<file path="character_conversation_overlay.gd">
extends CanvasLayer
class_name CharacterConversationOverlay

signal conversation_finished(dialogue_resource: DialogueResource)

# --- EXPORT VARIABLES ---
@export var conversation_dialogue_file: DialogueResource
@export var background_animations: SpriteFrames
@export var initial_animation_name: String = "float_loop"
@export var scene_character_sprite_texture: Texture2D
# Assign your grayscale_material.tres here in Inspector
@export var mental_image_shader: ShaderMaterial
var _background_tween: Tween

# --- NODE REFERENCES ---
@onready var root_container: Control = $RootContainer
@onready var animated_background: TextureRect = $RootContainer/AnimatedBackground
@onready var character_main_sprite: Sprite2D = $RootContainer/CharacterMainSprite
@onready var background_sprite: Sprite2D = $RootContainer/BackgroundSprite
@onready var mental_image_sprite: Sprite2D = $RootContainer/MentalImageSprite

# --- TWEEN VARIABLE (NEW) ---
# We store the tween reference here so we can stop it if a new command comes in.
var _mental_image_tween: Tween


# --- SHAKE VARIABLES ---
var _is_shaking: bool = false
var _shake_timer: float = 0.0
var _shake_strength: float = 10.0
var _shake_rng := RandomNumberGenerator.new()
var _is_persistent_shake: bool = false
var _ignore_next_got_dialogue_signal: bool = false
# --- ANIMATION VARIABLES ---
var _current_anim_name: String = ""
var _current_frame_index: int = 0
var _time_since_last_frame: float = 0.0
var _is_playing: bool = false


func _ready():
	if character_main_sprite:
		if scene_character_sprite_texture:
			character_main_sprite.texture = scene_character_sprite_texture
			character_main_sprite.visible = true
		else:
			character_main_sprite.visible = false
	else:
		print_rich("[color=orange]CharacterConversationOverlay: 'CharacterMainSprite' node not found.[/color]")

	DialogueManager.dialogue_ended.connect(_on_dialogue_ended_from_manager)
	DialogueManager.got_dialogue.connect(_on_got_dialogue)
	_shake_rng.randomize()

	if background_animations:
		play_animation(initial_animation_name)
	else:
		print_rich("[color=red]No 'background_animations' (SpriteFrames) assigned![/color]")

	# Ensure mental image sprite is hidden at start
	mental_image_sprite.visible = false

	if conversation_dialogue_file:
		DialogueManager.show_dialogue_balloon_scene(
			"res://conversationballoon.tscn",
			conversation_dialogue_file,
			"start",
			[self]
		)
	else:
		print_rich("[color=red]No 'conversation_dialogue_file' assigned![/color]")
		conversation_finished.emit(null)
		_cleanup_and_queue_free()

	if background_sprite:
		# Force the background to align to the top-left corner on startup
		background_sprite.centered = false  # Just in case you forgot to uncheck it
		background_sprite.position = Vector2.ZERO
func _process(delta: float):
	# --- Shake Logic ---
	if _is_shaking:
		if not _is_persistent_shake:
			_shake_timer -= delta
			if _shake_timer <= 0:
				_is_shaking = false
				root_container.position = Vector2.ZERO

		if _is_shaking:
			var offset_x = _shake_rng.randf_range(-_shake_strength, _shake_strength)
			var offset_y = _shake_rng.randf_range(-_shake_strength, _shake_strength)
			root_container.position = Vector2(offset_x, offset_y)

	# --- Animation Logic ---
	if not _is_playing or not background_animations:
		return

	var anim_speed = background_animations.get_animation_speed(_current_anim_name)
	if anim_speed == 0: return

	var frame_count = background_animations.get_frame_count(_current_anim_name)
	var does_loop = background_animations.get_animation_loop(_current_anim_name)
	var time_per_frame = 1.0 / anim_speed
	_time_since_last_frame += delta
	if _time_since_last_frame >= time_per_frame:
		_time_since_last_frame -= time_per_frame
		_current_frame_index += 1
		if _current_frame_index >= frame_count:
			if does_loop: _current_frame_index = 0
			else:
				_current_frame_index = frame_count - 1
				_is_playing = false
		update_frame()


# --- MENTAL IMAGE FUNCTIONS (UPDATED FOR GODOT 4) ---
# Added 'start_scale' parameter at the end (defaults to 1.0)
func start_mental_image(texture_path: String, fade_duration: float = 0.5, tint: Color = Color.WHITE, final_opacity: float = 0.6, start_scale: float = 1.0):
	# 1. Setup Grayscale Shader
	if mental_image_shader:
		root_container.material = mental_image_shader
		root_container.material.set_shader_parameter("strength", 0.0)

	# 2. Setup Ghost Sprite
	var new_texture = load(texture_path)
	if new_texture is Texture2D:
		mental_image_sprite.texture = new_texture

		# Reset Visuals
		var start_modulate = tint
		start_modulate.a = 0.0
		mental_image_sprite.modulate = start_modulate

		# Set Initial Scale
		var initial_vec = Vector2(start_scale, start_scale)
		mental_image_sprite.scale = initial_vec
		mental_image_sprite.visible = true

		# 3. Handle Tweening
		if _mental_image_tween:
			_mental_image_tween.kill()

		_mental_image_tween = create_tween().set_parallel(true)

		# A: Fade in Opacity
		_mental_image_tween.tween_property(mental_image_sprite, "modulate:a", final_opacity, fade_duration)\
			.set_trans(Tween.TRANS_QUINT).set_ease(Tween.EASE_OUT)

		# B: Fade in Shader
		if mental_image_shader:
			_mental_image_tween.tween_property(root_container.material, "shader_parameter/strength", 1.0, fade_duration)\
				.set_trans(Tween.TRANS_QUINT).set_ease(Tween.EASE_OUT)

		# C: The "Infinite" Slow Zoom (UPDATED)
		# We add 0.5 to the scale (a huge increase) over 100 seconds (a huge time).
		# This keeps the speed slow and steady, but ensures it doesn't "stop"
		# while the player is reading.
		var zoom_amount = 0.5
		var target_scale_vec = Vector2(start_scale + zoom_amount, start_scale + zoom_amount)

		_mental_image_tween.tween_property(mental_image_sprite, "scale", target_scale_vec, 100.0)\
			.set_trans(Tween.TRANS_LINEAR)

		print_rich("[color=lightblue]Starting mental image (Infinite Zoom).[/color]")
	else:
		print_rich("[color=red]Mental Image Error: Failed to load texture at path: " + texture_path + "[/color]")
func stop_mental_image(fade_duration: float = 0.5):
	# 1. Kill any running fade-ins
	if _mental_image_tween:
		_mental_image_tween.kill()

	# 2. Create fade-out tween
	_mental_image_tween = create_tween().set_parallel(true)

	# A: Fade out the Ghost Sprite
	_mental_image_tween.tween_property(mental_image_sprite, "modulate:a", 0.0, fade_duration)\
		.set_trans(Tween.TRANS_QUINT).set_ease(Tween.EASE_IN)

	# B: Fade out the Grayscale Shader (1.0 back to 0.0)
	if root_container.material:
		_mental_image_tween.tween_property(root_container.material, "shader_parameter/strength", 0.0, fade_duration)\
			.set_trans(Tween.TRANS_QUINT).set_ease(Tween.EASE_IN)

	# 3. Wait for animation to finish
	await _mental_image_tween.finished

	# 4. Cleanup
	mental_image_sprite.visible = false
	root_container.material = null # Remove the shader entirely
	print_rich("[color=lightblue]Mental image fade-out complete.[/color]")

# --- (Existing helper functions below) ---

# --- NEW BACKGROUND ZOOM FUNCTIONS ---

# Call this to start the slow zoom on the background.
# Default: Adds 0.2 to the scale (20% zoom) over 40 seconds.
# This creates a very slow, cinematic "creep" in.
func start_background_zoom(zoom_amount: float = 0.2, duration: float = 40.0):
	if not background_sprite: return

	# 1. Reset scale to 1.0 (Normal) so it starts fresh
	background_sprite.scale = Vector2.ONE

	# 2. Kill any existing background animation
	if _background_tween:
		_background_tween.kill()

	# 3. Create the tween
	_background_tween = create_tween()

	# 4. Calculate target (Current 1.0 + Amount)
	var target_scale = Vector2(1.0 + zoom_amount, 1.0 + zoom_amount)

	# 5. Animate linearly (steady speed)
	_background_tween.tween_property(background_sprite, "scale", target_scale, duration)\
		.set_trans(Tween.TRANS_LINEAR)

	print_rich("[color=lightblue]Started background zoom.[/color]")


# Call this to smoothly return the background to normal size.
func stop_background_zoom(reset_duration: float = 0.5):
	if not background_sprite: return

	if _background_tween:
		_background_tween.kill()

	_background_tween = create_tween()

	# Tween back to Vector2.ONE (1.0, 1.0)
	_background_tween.tween_property(background_sprite, "scale", Vector2.ONE, reset_duration)\
		.set_trans(Tween.TRANS_QUINT).set_ease(Tween.EASE_OUT)

	print_rich("[color=lightblue]Resetting background zoom.[/color]")

func _on_got_dialogue(_line: DialogueLine):
	if _ignore_next_got_dialogue_signal:
		_ignore_next_got_dialogue_signal = false
		return
	if _is_persistent_shake:
		_is_shaking = false
		_is_persistent_shake = false
		root_container.position = Vector2.ZERO

func shake(duration: float = 0.4, strength: float = 10.0):
	_shake_strength = strength
	_is_shaking = true
	if duration < 0:
		_is_persistent_shake = true
		_ignore_next_got_dialogue_signal = true
	else:
		_is_persistent_shake = false
		_ignore_next_got_dialogue_signal = false
		_shake_timer = duration

func play_animation(anim_name: String):
	if not background_animations.has_animation(anim_name):
		return
	_current_anim_name = anim_name
	_current_frame_index = 0
	_time_since_last_frame = 0.0
	_is_playing = true
	update_frame()

func update_frame():
	if animated_background and background_animations.has_animation(_current_anim_name):
		var texture = background_animations.get_frame_texture(_current_anim_name, _current_frame_index)
		animated_background.texture = texture

func change_background_animation(animation_name: String):
	play_animation(animation_name)

# MODIFIED FUNCTION
func change_background_sprite(texture_path: String, effect: String = ""):
	if not background_sprite: return

	# Handle empty path (hide background)
	if texture_path.is_empty():
		background_sprite.visible = false
		return

	var new_texture = load(texture_path)
	if not (new_texture is Texture2D):
		print_rich("[color=red]Error: Could not load texture at: %s[/color]" % texture_path)
		return

	# --- CASE 1: NO EFFECT (Standard Switch) ---
	if effect == "" or effect == "none":
		background_sprite.texture = new_texture
		background_sprite.visible = true
		background_sprite.position = Vector2.ZERO
		return

	# --- CASE 2: DISSOLVE TRANSITION (Cross-fade) ---
	if effect == "dissolve":
		# 1. Create a "Ghost" of the OLD image
		# We put it ON TOP of the main sprite so we can fade it out to reveal the new one.
		var temp_old_sprite = background_sprite.duplicate()
		root_container.add_child(temp_old_sprite)
		root_container.move_child(temp_old_sprite, background_sprite.get_index() + 1)

		# 2. Ensure Ghost has the old texture and properties
		temp_old_sprite.texture = background_sprite.texture
		temp_old_sprite.position = background_sprite.position
		temp_old_sprite.scale = background_sprite.scale

		# 3. Set the MAIN sprite to the NEW image immediately (it's hidden under the ghost)
		background_sprite.texture = new_texture
		background_sprite.visible = true

		# 4. Tween the Ghost's Opacity to 0 (Transparent)
		var fade_duration = 0.5 # Adjust speed here if needed
		var dissolve_tween = create_tween()
		dissolve_tween.tween_property(temp_old_sprite, "modulate:a", 0.0, fade_duration)\
			.set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_IN_OUT)

		# 5. Cleanup the ghost when done
		dissolve_tween.tween_callback(temp_old_sprite.queue_free)
		return

	# --- CASE 3: SLIDE TRANSITIONS (Whip Pan) ---

	# 1. Play Sound
	if SoundManager.has_method("play_sfx"):
		SoundManager.play_sfx("swish", 1.0, -5.0)

	# 2. Create Dummy Sprite for the old image
	var temp_old_sprite = background_sprite.duplicate()
	root_container.add_child(temp_old_sprite)
	root_container.move_child(temp_old_sprite, background_sprite.get_index()) # Put BEHIND/Same layer

	temp_old_sprite.texture = background_sprite.texture
	temp_old_sprite.position = Vector2.ZERO
	temp_old_sprite.scale = background_sprite.scale

	# 3. Setup New Sprite
	background_sprite.texture = new_texture
	background_sprite.visible = true

	# 4. Calculate Positions
	var screen_width = get_viewport().get_visible_rect().size.x
	var duration = 0.35

	var new_sprite_start_pos = Vector2.ZERO
	var old_sprite_end_pos = Vector2.ZERO

	if effect == "slide_left":
		new_sprite_start_pos = Vector2(-screen_width, 0)
		old_sprite_end_pos = Vector2(screen_width, 0)

	elif effect == "slide_right":
		new_sprite_start_pos = Vector2(screen_width, 0)
		old_sprite_end_pos = Vector2(-screen_width, 0)

	# 5. Apply positions
	background_sprite.position = new_sprite_start_pos

	# 6. Animate
	var slide_tween = create_tween().set_parallel(true)

	slide_tween.tween_property(background_sprite, "position", Vector2.ZERO, duration)\
		.set_trans(Tween.TRANS_QUART).set_ease(Tween.EASE_OUT)

	slide_tween.tween_property(temp_old_sprite, "position", old_sprite_end_pos, duration)\
		.set_trans(Tween.TRANS_QUART).set_ease(Tween.EASE_OUT)

	# 7. Cleanup
	slide_tween.chain().tween_callback(temp_old_sprite.queue_free)

func _on_dialogue_ended_from_manager(resource: DialogueResource):
	if resource == conversation_dialogue_file:
		conversation_finished.emit(resource)
		_cleanup_and_queue_free()

func _cleanup_and_queue_free():
	if DialogueManager.is_connected("dialogue_ended", _on_dialogue_ended_from_manager):
		DialogueManager.disconnect("dialogue_ended", _on_dialogue_ended_from_manager)
	if DialogueManager.is_connected("got_dialogue", _on_got_dialogue):
		DialogueManager.disconnect("got_dialogue", _on_got_dialogue)
	queue_free()
# NEW FUNCTION: Play a sequence of images with a dissolve effect
# usage: do play_dissolve_sequence(["res://img1.png", "res://img2.png"], 2.0, 1.0)
func play_dissolve_sequence(image_paths: Array, hold_duration: float = 2.0, fade_duration: float = 1.0):
	if not background_sprite: return

	# Loop through every image path provided in the list
	for i in range(image_paths.size()):
		var texture_path = image_paths[i]
		var new_texture = load(texture_path)

		if not (new_texture is Texture2D):
			print_rich("[color=red]Error loading: %s[/color]" % texture_path)
			continue # Skip this bad image and try the next

		# --- STEP 1: If this is the FIRST image and screen is empty, just show it ---
		if i == 0 and not background_sprite.visible:
			background_sprite.texture = new_texture
			background_sprite.visible = true
			background_sprite.modulate.a = 0.0 # Start invisible

			# Simple fade in for the first image
			var tween = create_tween()
			tween.tween_property(background_sprite, "modulate:a", 1.0, fade_duration)
			await tween.finished

		# --- STEP 2: If we are transitioning from an existing image ---
		else:
			# 1. Create a "Ghost" of the current image
			var temp_old_sprite = background_sprite.duplicate()
			root_container.add_child(temp_old_sprite)
			root_container.move_child(temp_old_sprite, background_sprite.get_index() + 1) # Put ON TOP

			# 2. Setup the "Ghost" properties
			temp_old_sprite.texture = background_sprite.texture
			temp_old_sprite.position = background_sprite.position
			temp_old_sprite.centered = background_sprite.centered
			temp_old_sprite.scale = background_sprite.scale

			# 3. Set the REAL sprite to the NEW image underneath
			background_sprite.texture = new_texture
			background_sprite.visible = true

			# 4. Tween the GHOST to transparent (revealing the new one)
			var tween = create_tween()
			tween.tween_property(temp_old_sprite, "modulate:a", 0.0, fade_duration)\
				.set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_IN_OUT)

			# 5. Wait for fade to finish
			await tween.finished
			temp_old_sprite.queue_free() # Delete the ghost

		# --- STEP 3: Wait for the "Hold" time before showing the next one ---
		# We don't wait after the very last image
		if i < image_paths.size() - 1:
			await get_tree().create_timer(hold_duration).timeout


func _exit_tree():
	_cleanup_and_queue_free()
</file>

<file path="CharacterConversationOverlay.tscn">
[gd_scene load_steps=5 format=3 uid="uid://7s7wp2v87sa4"]

[ext_resource type="Script" uid="uid://cy1g0xpb3u0e2" path="res://character_conversation_overlay.gd" id="1_ubaeu"]
[ext_resource type="Resource" uid="uid://b7jdbk4b0natj" path="res://dialogue/npcs/faye.dialogue" id="2_5qcf0"]
[ext_resource type="SpriteFrames" uid="uid://w63ywvs0833i" path="res://conversation_backgrounds.tres" id="3_4hhp7"]
[ext_resource type="Texture2D" uid="uid://coo5k2phjvc1e" path="res://Protag.png" id="3_wh5aq"]

[node name="CharacterConversationOverlay" type="CanvasLayer"]
process_mode = 3
layer = 2
script = ExtResource("1_ubaeu")
conversation_dialogue_file = ExtResource("2_5qcf0")
background_animations = ExtResource("3_4hhp7")
scene_character_sprite_texture = ExtResource("3_wh5aq")

[node name="RootContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundRect" type="ColorRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MentalImageSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(962, 457)
scale = Vector2(0.308889, 0.308889)

[node name="BackgroundSprite" type="Sprite2D" parent="RootContainer"]
position = Vector2(962, 457)
scale = Vector2(0.308889, 0.308889)

[node name="AnimatedBackground" type="TextureRect" parent="RootContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
expand_mode = 1
stretch_mode = 6
</file>

<file path="LevelStateManager.gd">
# LevelStateManager.gd
extends Node
class_name LevelStateManager

# --- ADD THIS SIGNAL ---
signal level_flag_changed(flag_name: String, new_value: bool)


# --- EXPORTED LEVEL-SPECIFIC FLAGS ---
# Add flags relevant to THIS level here.
# For our test:
@export var rusty_key_picked_up: bool = false
@export var key_used_on_burger: bool = false
@export var zanopram_taken: bool = false
@export var cannathink_taken: bool = false
@export var invigirol_taken: bool = false
@export var has_spoken_to_aida: bool = false
@export var aida_explanation_shown: bool = false
@export var insurance_button_unlocked: bool = false
@export var mcbucket_cannathink_used: bool = false
@export var memory_box_unlocked: bool = false
@export var mcbucket_invigirol_used: bool = false
@export var mcbucket_zanopram_used: bool = false
@export var toilet_clogged:bool = false
@export var aida_in_main_room:bool = true
@export var has_spoken_to_sergey_once: bool =  false
@export var toilet_has_paper: bool = false # Stage 1: Paper dropped
@export var aida_fixing_toilet: bool = false # Acts as a lock preventing re-trigger


# Example of other potential flags for a level:
# @export var generator_online: bool = false
# @export var npc_met_for_quest: bool = false
# @export var secret_door_unlocked: bool = false

func _ready():
	print_rich("[color=LawnGreen]LevelStateManager for '%s' is ready.[/color]" % get_parent().name if get_parent() else "UnnamedLevel")
	# You could print initial flag states here for debugging if needed
	# print_initial_flags()

func print_initial_flags():
	var properties = get_property_list()
	for p in properties:
		if p.usage & PROPERTY_USAGE_STORAGE: # Check if it's a stored property (like exported ones)
			if get(p.name) is bool: # Only care about boolean flags for this example
				print_rich("  [color=gray]Initial Flag '%s': %s[/color]" % [p.name, get(p.name)])


# Generic function to set any exported boolean flag by its string name
func set_level_flag(flag_name: String, value: bool):
	if not has_meta(flag_name) and get(flag_name) == null: # Check if property exists
		# A more robust check might involve iterating get_property_list()
		# to ensure 'flag_name' is a valid exported bool property.
		# For now, we rely on 'get(flag_name)' not being null if it's an exported var.
		var property_exists = false
		for prop_info in get_property_list():
			if prop_info.name == flag_name and prop_info.type == TYPE_BOOL:
				property_exists = true
				break

		if not property_exists:
			print_rich("[color=red]LevelStateManager ('%s'): Attempted to set non-existent or non-boolean exported flag: '%s'[/color]" % [get_parent().name if get_parent() else "", flag_name])
			return

	if get(flag_name) == value:
		# print_rich("[color=gray]LevelStateManager ('%s'): Flag '%s' already set to %s. No change.[/color]" % [get_parent().name if get_parent() else "", flag_name, value])
		return # No change

	set(flag_name, value) # Use set() to modify exported vars by string name
	print_rich("[color=LawnGreen]LevelStateManager ('%s'): Level Flag Set -> %s = %s[/color]" % [get_parent().name if get_parent() else "", flag_name, value])
	level_flag_changed.emit(flag_name, value)

	# You could add logic here to check for level completion or trigger other events
	# based on this flag change. For example:
	# if flag_name == "rusty_key_picked_up" and value == true:
	#     check_if_all_keys_collected()


# Generic function to get any exported boolean flag by its string name
func get_level_flag(flag_name: String) -> bool:
	var property_exists = false
	for prop_info in get_property_list():
		if prop_info.name == flag_name and prop_info.type == TYPE_BOOL:
			property_exists = true
			break

	if not property_exists:
		# print_rich("[color=orange]LevelStateManager ('%s'): Attempted to get non-existent or non-boolean exported flag: '%s'. Returning false.[/color]" % [get_parent().name if get_parent() else "", flag_name])
		return false

	var flag_value = get(flag_name)
	if flag_value is bool:
		return flag_value

	# print_rich("[color=orange]LevelStateManager ('%s'): Flag '%s' is not a boolean. Returning false.[/color]" % [get_parent().name if get_parent() else "", flag_name])
	return false # Should not happen if property_exists check is good
</file>

<file path="UI_cannathink.tscn">
[gd_scene load_steps=15 format=3 uid="uid://b5eqmwcgkinbv"]

[ext_resource type="Texture2D" uid="uid://cwwpjjh8g2oys" path="res://cannathink.png" id="1_mtq27"]
[ext_resource type="BitMap" uid="uid://dlj2f3klm7wtl" path="res://zanopram_map.png" id="2_waoth"]
[ext_resource type="Script" uid="uid://hm12uesh52vl" path="res://ui_interactable.gd" id="3_kfii6"]
[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="4_lndah"]
[ext_resource type="Script" uid="uid://bmq0s1nqhqi4j" path="res://InteractionResponse.gd" id="5_jssx0"]
[ext_resource type="Resource" uid="uid://bivfrghh084ym" path="res://interactions/actions/DefaultExamineResponse.tres" id="6_loee1"]
[ext_resource type="Script" uid="uid://dltqnu07oiff" path="res://action.gd" id="7_ljjww"]
[ext_resource type="Script" uid="uid://bapryqa2s86c5" path="res://interactions/actions/SayLineAction.gd" id="8_1sodi"]
[ext_resource type="Script" uid="uid://nvyqoryt5sbh" path="res://interactions/actions/AddItemAction.gd" id="9_cx2wj"]
[ext_resource type="Script" uid="uid://c5bw6trnybm71" path="res://interactions/actions/DestroyAction.gd" id="10_vbd00"]

[sub_resource type="Resource" id="Resource_ookji"]
script = ExtResource("8_1sodi")
line_to_say = "picekd up cannathink"
metadata/_custom_type_script = "uid://bapryqa2s86c5"

[sub_resource type="Resource" id="Resource_ktyjx"]
script = ExtResource("9_cx2wj")
item_id_to_add = "cannathink"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_a2j4x"]
script = ExtResource("10_vbd00")
message_on_destroy = "cannathink"
metadata/_custom_type_script = "uid://c5bw6trnybm71"

[sub_resource type="Resource" id="Resource_17844"]
script = ExtResource("5_jssx0")
verb_id = "pickup"
required_item_id = ""
required_flag_id = ""
required_flag_value = true
actions_to_perform = Array[ExtResource("7_ljjww")]([SubResource("Resource_ookji"), SubResource("Resource_ktyjx"), SubResource("Resource_a2j4x")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[node name="TextureButton" type="TextureButton"]
texture_normal = ExtResource("1_mtq27")
texture_click_mask = ExtResource("2_waoth")
script = ExtResource("3_kfii6")

[node name="Interactable" type="Area2D" parent="."]
script = ExtResource("4_lndah")
object_display_name = "CannaThink"
object_id = "cannathink"
state_flag_id = "cannathink_taken"
interaction_location = 1
interactions = Array[ExtResource("5_jssx0")]([ExtResource("6_loee1"), SubResource("Resource_17844")])
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="Sprite2D" type="Sprite2D" parent="Interactable"]
</file>

<file path="UI_Invigirol.tscn">
[gd_scene load_steps=15 format=3 uid="uid://bi8u415ulvhb"]

[ext_resource type="Texture2D" uid="uid://bqbbirvssvi8t" path="res://invigirol_sprite.png" id="1_mmg5h"]
[ext_resource type="Script" uid="uid://hm12uesh52vl" path="res://ui_interactable.gd" id="1_t6val"]
[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="2_bbeln"]
[ext_resource type="BitMap" uid="uid://b20nrgyq3yjvp" path="res://invigirol.png" id="2_jwtrt"]
[ext_resource type="Script" uid="uid://bmq0s1nqhqi4j" path="res://InteractionResponse.gd" id="5_ylk1r"]
[ext_resource type="Resource" uid="uid://bivfrghh084ym" path="res://interactions/actions/DefaultExamineResponse.tres" id="6_4ra0u"]
[ext_resource type="Script" uid="uid://dltqnu07oiff" path="res://action.gd" id="7_quqnq"]
[ext_resource type="Script" uid="uid://bapryqa2s86c5" path="res://interactions/actions/SayLineAction.gd" id="8_yystr"]
[ext_resource type="Script" uid="uid://nvyqoryt5sbh" path="res://interactions/actions/AddItemAction.gd" id="9_qx4ii"]
[ext_resource type="Script" uid="uid://c5bw6trnybm71" path="res://interactions/actions/DestroyAction.gd" id="10_xamdo"]

[sub_resource type="Resource" id="Resource_noxll"]
script = ExtResource("8_yystr")
line_to_say = "I have picked up invigirol"
metadata/_custom_type_script = "uid://bapryqa2s86c5"

[sub_resource type="Resource" id="Resource_ykc8w"]
script = ExtResource("9_qx4ii")
item_id_to_add = "invigirol"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_t1m4h"]
script = ExtResource("10_xamdo")
message_on_destroy = "invigirol destroyed"
metadata/_custom_type_script = "uid://c5bw6trnybm71"

[sub_resource type="Resource" id="Resource_hxs5m"]
script = ExtResource("5_ylk1r")
verb_id = "pickup"
required_item_id = ""
required_flag_id = ""
required_flag_value = true
actions_to_perform = Array[ExtResource("7_quqnq")]([SubResource("Resource_noxll"), SubResource("Resource_ykc8w"), SubResource("Resource_t1m4h")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[node name="TextureButton" type="TextureButton"]
texture_normal = ExtResource("1_mmg5h")
texture_click_mask = ExtResource("2_jwtrt")
script = ExtResource("1_t6val")

[node name="Interactable" type="Area2D" parent="."]
script = ExtResource("2_bbeln")
object_display_name = "Invigirol"
object_id = "invigirol"
state_flag_id = "invigirol_taken"
interaction_location = 1
interactions = Array[ExtResource("5_ylk1r")]([ExtResource("6_4ra0u"), SubResource("Resource_hxs5m")])
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="Sprite2D" type="Sprite2D" parent="Interactable"]
</file>

<file path="UI_Zanopram.tscn">
[gd_scene load_steps=13 format=3 uid="uid://b8jbh3bghi1rb"]

[ext_resource type="Script" uid="uid://hm12uesh52vl" path="res://ui_interactable.gd" id="1_82e07"]
[ext_resource type="Texture2D" uid="uid://bjuaurrw0logr" path="res://zanopram.png" id="1_582fx"]
[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="2_5mir5"]
[ext_resource type="BitMap" uid="uid://dlj2f3klm7wtl" path="res://zanopram_map.png" id="2_ftjr1"]
[ext_resource type="Script" uid="uid://bmq0s1nqhqi4j" path="res://InteractionResponse.gd" id="5_vot75"]
[ext_resource type="Resource" uid="uid://bivfrghh084ym" path="res://interactions/actions/DefaultExamineResponse.tres" id="6_7tucb"]
[ext_resource type="Script" uid="uid://dltqnu07oiff" path="res://action.gd" id="7_v03ym"]
[ext_resource type="Script" uid="uid://nvyqoryt5sbh" path="res://interactions/actions/AddItemAction.gd" id="8_sb6td"]
[ext_resource type="Script" uid="uid://c5bw6trnybm71" path="res://interactions/actions/DestroyAction.gd" id="9_kicyk"]

[sub_resource type="Resource" id="Resource_12wmw"]
script = ExtResource("8_sb6td")
item_id_to_add = "zanopram"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_5yl0c"]
script = ExtResource("9_kicyk")
message_on_destroy = ""
metadata/_custom_type_script = "uid://c5bw6trnybm71"

[sub_resource type="Resource" id="Resource_6nd1o"]
script = ExtResource("5_vot75")
verb_id = "pickup"
required_item_id = ""
required_flag_id = ""
required_flag_value = true
actions_to_perform = Array[ExtResource("7_v03ym")]([SubResource("Resource_12wmw"), SubResource("Resource_5yl0c")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[node name="TextureButton" type="TextureButton"]
texture_normal = ExtResource("1_582fx")
texture_click_mask = ExtResource("2_ftjr1")
script = ExtResource("1_82e07")

[node name="Interactable" type="Area2D" parent="."]
script = ExtResource("2_5mir5")
object_display_name = "Zzzanopram"
object_id = "zanopram"
state_flag_id = "zanopram_taken"
interaction_location = 1
interactions = Array[ExtResource("5_vot75")]([ExtResource("6_7tucb"), SubResource("Resource_6nd1o")])
metadata/_custom_type_script = "uid://dwldhrx7leysr"

[node name="Sprite2D" type="Sprite2D" parent="Interactable"]
</file>

<file path="conversationballoon.tscn">
[gd_scene load_steps=6 format=3 uid="uid://dmfq0fjxxjgay"]

[ext_resource type="Script" uid="uid://cynyquih1wama" path="res://conversationballoon.gd" id="1_313u1"]
[ext_resource type="PackedScene" uid="uid://ckvgyvclnwggo" path="res://addons/dialogue_manager/dialogue_label.tscn" id="2_313u1"]
[ext_resource type="FontFile" uid="uid://bd58xbyix7r6p" path="res://Fonts/VarelaRound-Regular.ttf" id="3_313u1"]
[ext_resource type="Script" uid="uid://bb52rsfwhkxbn" path="res://addons/dialogue_manager/dialogue_responses_menu.gd" id="3_ibrr4"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_oijet"]
bg_color = Color(0, 0, 0, 0.745098)

[node name="ExampleBalloon" type="CanvasLayer"]
layer = 100
script = ExtResource("1_313u1")

[node name="Balloon" type="Control" parent="."]
unique_name_in_owner = true
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="Balloon"]
clip_children = 2
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 21.0
offset_top = -183.0
offset_right = -19.0
offset_bottom = -19.0
grow_horizontal = 2
grow_vertical = 0
mouse_filter = 1
theme_override_styles/panel = SubResource("StyleBoxFlat_oijet")

[node name="Dialogue" type="MarginContainer" parent="Balloon/Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 15

[node name="VBoxContainer" type="VBoxContainer" parent="Balloon/Panel/Dialogue"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="CharacterLabel" type="RichTextLabel" parent="Balloon/Panel/Dialogue/VBoxContainer"]
unique_name_in_owner = true
modulate = Color(1, 1, 1, 0.501961)
layout_mode = 2
mouse_filter = 1
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 0.19607843)
theme_override_constants/shadow_outline_size = 1
theme_override_constants/outline_size = 4
theme_override_fonts/normal_font = ExtResource("3_313u1")
theme_override_font_sizes/normal_font_size = 28
theme_override_font_sizes/bold_font_size = 28
theme_override_font_sizes/bold_italics_font_size = 28
theme_override_font_sizes/italics_font_size = 28
theme_override_font_sizes/mono_font_size = 28
bbcode_enabled = true
text = "Character"
fit_content = true
scroll_active = false

[node name="DialogueLabel" parent="Balloon/Panel/Dialogue/VBoxContainer" instance=ExtResource("2_313u1")]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_colors/font_shadow_color = Color(0, 0, 0, 0.19607843)
theme_override_fonts/normal_font = ExtResource("3_313u1")
theme_override_font_sizes/normal_font_size = 28
theme_override_font_sizes/bold_font_size = 28
theme_override_font_sizes/bold_italics_font_size = 28
theme_override_font_sizes/italics_font_size = 28
theme_override_font_sizes/mono_font_size = 28
text = "Dialogue..."
seconds_per_step = 0.018

[node name="Responses" type="MarginContainer" parent="Balloon"]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -866.0
offset_top = -836.0
offset_right = -225.0
offset_bottom = -432.0
grow_horizontal = 2
grow_vertical = 0

[node name="ResponsesMenu" type="VBoxContainer" parent="Balloon/Responses" node_paths=PackedStringArray("response_template")]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 8
theme_override_constants/separation = 2
script = ExtResource("3_ibrr4")
response_template = NodePath("ResponseExample")

[node name="ResponseExample" type="Button" parent="Balloon/Responses/ResponsesMenu"]
layout_mode = 2
theme_override_fonts/font = ExtResource("3_313u1")
theme_override_font_sizes/font_size = 28
text = "Response example"

[connection signal="gui_input" from="Balloon" to="." method="_on_balloon_gui_input"]
[connection signal="response_selected" from="Balloon/Responses/ResponsesMenu" to="." method="_on_responses_menu_response_selected"]
</file>

<file path="GameManager.tscn">
[gd_scene load_steps=16 format=3 uid="uid://xspnhif2n7ak"]

[ext_resource type="Script" uid="uid://cuj755ptbe4e0" path="res://GameManager.gd" id="1_108xg"]
[ext_resource type="Script" uid="uid://cn3ln508qp8dm" path="res://VerbData.gd" id="2_dxunw"]
[ext_resource type="Resource" uid="uid://xp53l3fuethr" path="res://examinables.dialogue" id="2_pdxvr"]
[ext_resource type="Resource" uid="uid://bs01nglwwhavy" path="res://dialogue/talkto.dialogue" id="3_iyray"]
[ext_resource type="Resource" uid="uid://dhmxbhyhr4erb" path="res://examine_verb.tres" id="3_pdxvr"]
[ext_resource type="Resource" uid="uid://bnekusymfhc2d" path="res://talk_to_verb.tres" id="4_iyray"]
[ext_resource type="Resource" uid="uid://k8ha62365syy" path="res://pick_up_verb.tres" id="7_0145d"]
[ext_resource type="Resource" uid="uid://hs2nkbv1s6yx" path="res://use_verb.tres" id="8_0q1rh"]
[ext_resource type="Script" uid="uid://by8o1t3tdwrep" path="res://ItemData.gd" id="8_0145d"]
[ext_resource type="Resource" uid="uid://cywl5aqwmqhx1" path="res://key_rusty_item.tres" id="9_0q1rh"]
[ext_resource type="Resource" uid="uid://dle6p4hlq4yos" path="res://zanopram.tres" id="11_5me18"]
[ext_resource type="Resource" uid="uid://xmq2iq7j8nup" path="res://cannathink.tres" id="12_dm6qn"]
[ext_resource type="Resource" uid="uid://lr7bq8edhdbr" path="res://invigirol.tres" id="13_lhkyk"]
[ext_resource type="Resource" uid="uid://f3at4vpof4bj" path="res://testbox.tres" id="14_lk78y"]
[ext_resource type="Resource" uid="uid://c2o4m1lmeyqpn" path="res://hospital_toilet_paper.tres" id="15_3ky0o"]

[node name="GameManager" type="Node"]
script = ExtResource("1_108xg")
player_examine_lines = ExtResource("2_pdxvr")
player_talk_to_lines = ExtResource("3_iyray")
all_verb_data_resources = Array[ExtResource("2_dxunw")]([ExtResource("3_pdxvr"), ExtResource("4_iyray"), ExtResource("7_0145d"), ExtResource("8_0q1rh")])
all_item_data_resources = Array[ExtResource("8_0145d")]([ExtResource("9_0q1rh"), ExtResource("11_5me18"), ExtResource("12_dm6qn"), ExtResource("13_lhkyk"), ExtResource("14_lk78y"), ExtResource("15_3ky0o")])
</file>

<file path="GameManager.gd">
# GameManager.gd
extends Node

const MAIN_GAME_SCENE_PATH = "res://main.tscn"
const INSURANCE_FORM_SCENE = preload("res://insurance_form.tscn")
const MAIN_MENU_SCENE_PATH = "res://main_menu.tscn"
# --- ADD THIS LINE ---
# Make sure this path is correct for your project structure!
# In Boot.gd - CUT THESE LINES
const INTRO_OVERLAY_SCENE_PATH = "res://CharacterConversationOverlay.tscn"
const INTRO_DIALOGUE_FILE_PATH = "res://dialogue/npcs/faye.dialogue"
const INTRO_BACKGROUND_ANIMATIONS_PATH = "res://conversation_backgrounds.tres"
const INTRO_INITIAL_ANIMATION_NAME = "float_loop"

var _insurance_form_instance: CanvasLayer = null # To keep track of the form
# --- Signals ---
signal verb_changed(new_verb_id: String)
signal sentence_line_updated(text: String)
signal interaction_complete # For VerbUI to reset its state
signal available_verbs_changed(available_verb_data_array: Array[VerbData])
signal item_picked_up(item_name: String)
signal notification_requested(message: String)

# character conversation ended signal
signal character_conversation_ended(dialogue_resource: DialogueResource)

# Inventory Signals
signal inventory_updated(inventory_items: Array[ItemData])
signal selected_inventory_item_changed(selected_item_data: ItemData) # "In Hand" / "Selected"

# --- High-Level Game State Management ---
# 1. Define the game states using an enum for clarity and safety.
# In GameManager.gd
# In GameManager.gd
enum GameState {
	BOOTING,
	LOGO_SPLASH,
	MAIN_MENU,
	INTRO_CONVERSATION,
	IN_GAME_PLAY,
	PAUSED,
	EXPLANATION,
	CUTSCENE # <--- Add this line
}



# --- Interaction Context Management ---
# This enum tracks what the player is currently focused on.
enum InteractionState {
	WORLD,
	CONVERSATION,
	ZOOM_VIEW
}
var current_interaction_state: InteractionState = InteractionState.WORLD

# These references are crucial. We need to tell the GameManager where the UI nodes are.
# IMPORTANT: Verify these paths match the node structure in your main game scene!
# These references are crucial. We link them in the Inspector.
var verb_ui: CanvasLayer = null
var inventory_ui: CanvasLayer = null
var insurance_form_button_ui: CanvasLayer = null
var explanation_layer: CanvasLayer = null
var transition_layer: CanvasLayer = null


# --- END of Interaction Context Management ---
# 2. Create a variable to hold the current state.
var current_game_state: GameState = GameState.BOOTING

# 3. Reference to your main game scene instance.
#    The Boot.gd script will set this reference for us later.
var main_game_scene_instance: Node = null
var main_menu_scene_instance: CanvasLayer = null
# --- END of High-Level Game State Management ---
var input_blocker_layer: CanvasLayer = null
# --- State Variables ---
var current_verb_id: String = ""
var current_selected_item_data: ItemData = null # "In Hand" / "Selected" item
var hovered_interactable: Interactable = null
var player_node: CharacterBody2D

var _is_player_walking: bool = false
var _current_character_conversation_overlay_instance: CharacterConversationOverlay = null
var _signals_connected_to_interactable: Interactable = null # Tracks interactable for signal cleanup

var current_level_state_manager: LevelStateManager = null # For current level's state



# --- Verb Management ---
@export var player_examine_lines: DialogueResource
@export var player_talk_to_lines: DialogueResource
@export var all_verb_data_resources: Array[VerbData] = []
var unlocked_verb_ids: Array[String] = []
var active_scene_verb_ids: Array[String] = []

# --- Inventory Management ---
@export var all_item_data_resources: Array[ItemData] = []
var player_inventory: Array[ItemData] = []
var _item_data_map: Dictionary = {} # item_id -> ItemData




# --- Game Flags (Global) ---
var game_flags: Dictionary = {} # For flags that persist across levels

# --- Verb ID Constants ---

const IMPLICIT_USE_ITEM_VERB_ID: String = "use_item" # BACK TO "use_item"
const USE_ON_TARGET_VERB_ID: String = "use_on_target" # BACK TO "use_on_target"
# --- NEW CONSTANT ---
const WALK_TO_VERB_ID: String = "walk_to"


# In GameManager.gd

# In GameManager.gd

func _ready():
	print_rich("[color=cyan]GM: GameManager is Ready! Starting initialization...[/color]")

	if DialogueManager:
		DialogueManager.dialogue_started.connect(_on_dialogue_started)
		print_rich("[color=green]GM: Connected to DialogueManager.dialogue_started.[/color]")
	else:
		print_rich("[color=red]GM: DialogueManager (Autoload) not found. Dialogue events won't control player movement.[/color]")

	# Initialize Verbs
	print_rich("[color=aqua]GM: Initializing verbs...[/color]")
	for verb_data_res in all_verb_data_resources:
		if verb_data_res and verb_data_res.unlocked_by_default and not verb_data_res.verb_id in unlocked_verb_ids:
			unlocked_verb_ids.append(verb_data_res.verb_id)
			print_rich("  [color=gray]GM: Unlocked default verb: %s[/color]" % verb_data_res.verb_id)
	active_scene_verb_ids = unlocked_verb_ids.duplicate()
	_emit_available_verbs_changed_update()
	print_rich("[color=green]GM: Verbs initialized. %s default verbs unlocked.[/color]" % unlocked_verb_ids.size())

	# Initialize Item Data Map
	print_rich("[color=aqua]GM: Initializing item data map...[/color]")
	if all_item_data_resources.is_empty():
		print_rich("[color=yellow]GM: 'all_item_data_resources' array is empty. No items loaded from Inspector.[/color]")
	else:
		print_rich("[color=gray]GM: Found %s item resources in 'all_item_data_resources'.[/color]" % all_item_data_resources.size())

	for item_data_res in all_item_data_resources:
		if item_data_res and item_data_res.item_id != "":
			if not _item_data_map.has(item_data_res.item_id):
				_item_data_map[item_data_res.item_id] = item_data_res
				print_rich("  [color=gray]GM: Mapped item: ID='%s', Name='%s'[/color]" % [item_data_res.item_id, item_data_res.display_name])
			else:
				print_rich("[color=red]GM: Duplicate item_id found in all_item_data_resources: '%s'. Overwriting in map is problematic.[/color]" % item_data_res.item_id)
		elif item_data_res and item_data_res.item_id == "":
			print_rich("[color=orange]GM: ItemData resource '%s' found with EMPTY item_id. It cannot be used by ID.[/color]" % item_data_res.resource_path if item_data_res else "UNKNOWN")
		elif not item_data_res:
			print_rich("[color=yellow]GM: Found a null entry in 'all_item_data_resources'. Please check Inspector.[/color]")

	print_rich("[color=green]GM: Item data map initialized. %s items mapped.[/color]" % _item_data_map.size())
	print_rich("[color=cyan]GM: GameManager initialization complete.[/color]")

	# --- DIRECT SCENE RUN CHECK ---
	if current_game_state == GameState.BOOTING:
		var potential_player = get_tree().get_first_node_in_group("player")

		if is_instance_valid(potential_player):
			print_rich("[color=purple]GM: Direct scene run detected (player found on boot).[/color]")
			print_rich("[color=purple]GM: Manually setting state to IN_GAME_PLAY and assigning nodes.[/color]")

			# 1. Manually assign the player node
			player_node = potential_player

			# 2. Assign the main scene instance (assuming player is a child of the main scene)
			main_game_scene_instance = player_node.get_owner()
			if not is_instance_valid(main_game_scene_instance):
				# Fallback if owner is not set correctly
				main_game_scene_instance = get_tree().get_root().get_child(-1)

			# Find and assign the UI nodes now that the main scene is confirmed to exist.
			_find_and_assign_ui_nodes()

			print_rich("[color=green]GM: Found player: %s[/color]" % player_node.name)
			print_rich("[color=green]GM: Assigned main scene: %s[/color]" % main_game_scene_instance.name)

			# 3. Manually set the state.
			current_game_state = GameState.IN_GAME_PLAY

			# 4. Ensure the player can move
			if player_node.has_method("set_can_move"):
				player_node.set_can_move(true)

			# --- THIS IS THE FIX ---
			# We wait one frame to ensure the Scene Tree and AudioServer are fully stable
			# before trying to create and play the audio player.
			await get_tree().process_frame
			print_rich("[color=purple]GM: Starting music now...[/color]")
			SoundManager.play_music()

		else:
			# This Else block is new - it warns you if the Player Group is missing
			print_rich("[color=red]GM: Direct run detected, BUT no node in group 'player' was found.[/color]")
			print_rich("[color=red]GM: Music did not start because the initialization block was skipped.[/color]")
			print_rich("[color=red]GM: Please select your Player node -> Node Tab -> Groups -> Add 'player'.[/color]")
func _unhandled_input(event: InputEvent):
	# The initial check for _is_player_walking has been removed.

	if not (event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed()):
		return

	if current_game_state != GameState.IN_GAME_PLAY or current_interaction_state != InteractionState.WORLD:
		return

	if current_verb_id != "" or current_selected_item_data != null or hovered_interactable != null:
		return

	if is_instance_valid(player_node) and player_node.has_method("walk_to_point"):
		# Set the lock flag to true before telling the player to walk.
		# This is still important so that hover events are blocked correctly.
		_is_player_walking = true
		player_node.walk_to_point(player_node.get_global_mouse_position())


# Replace the entire existing function with this one.
# In GameManager.gd
# Replace the entire existing function with this one.
func change_game_state(new_state: GameState):
	if new_state == current_game_state:
		return

	# Wait for the end of the current frame so UI interactions clear
	await get_tree().process_frame

	# =========================================================
	# 1. LEAVING THE OLD STATE (Cleanup)
	# =========================================================
	match current_game_state:
		GameState.MAIN_MENU:
			if is_instance_valid(main_menu_scene_instance):
				print_rich("[color=yellow]GM: Cleaning up Main Menu scene.[/color]")
				main_menu_scene_instance.queue_free()
				main_menu_scene_instance = null
				
		GameState.IN_GAME_PLAY:
			# When LEAVING the game (e.g. to Menu), stop music.
			# If going to CUTSCENE, we usually want music to keep playing.
			if new_state != GameState.CUTSCENE:
				SoundManager.stop_music()

	print_rich("[color=yellow]GameManager: Changing state from %s to %s[/color]" % [GameState.keys()[current_game_state], GameState.keys()[new_state]])
	current_game_state = new_state

	# =========================================================
	# 2. ENTERING THE NEW STATE (Setup)
	# =========================================================
	match current_game_state:
		GameState.MAIN_MENU:
			if is_instance_valid(main_menu_scene_instance):
				return

			var menu_packed_scene = load(MAIN_MENU_SCENE_PATH)
			if not menu_packed_scene:
				print_rich("[color=red]GameManager Error: Failed to load Main Menu Scene.[/color]")
				return

			main_menu_scene_instance = menu_packed_scene.instantiate()
			main_menu_scene_instance.new_game_requested.connect(_on_main_menu_new_game_requested)
			main_menu_scene_instance.quit_game_requested.connect(_on_main_menu_quit_requested)

			get_tree().root.add_child(main_menu_scene_instance)
			print_rich("[color=green]GM: Main Menu scene loaded and initialized.[/color]")

		GameState.EXPLANATION:
			pass

		GameState.INTRO_CONVERSATION:
			_start_intro_conversation()

		GameState.IN_GAME_PLAY:
			# --- A. LOADING PHASE ---
			# Only load the scene if it doesn't exist (e.g. fresh boot)
			if not is_instance_valid(main_game_scene_instance):
				var main_packed_scene = load(MAIN_GAME_SCENE_PATH)
				if not main_packed_scene:
					print_rich("[color=red]GameManager Error: Failed to load Main Game Scene.[/color]")
					return

				main_game_scene_instance = main_packed_scene.instantiate()
				get_tree().root.add_child(main_game_scene_instance)
				_find_and_assign_ui_nodes()
				
				# Play music if we just loaded the game
				SoundManager.play_music() 

			# --- B. RESTORATION PHASE (Run this EVERY time we enter IN_GAME_PLAY) ---
			
			# 1. Ensure UI nodes are found (in case of re-linking)
			if not is_instance_valid(verb_ui): _find_and_assign_ui_nodes()

			# 2. Find Player if missing
			if not is_instance_valid(player_node):
				player_node = get_tree().get_first_node_in_group("player")

			# 3. Restore Main UI Visibility
			if is_instance_valid(verb_ui): verb_ui.visible = true
			if is_instance_valid(inventory_ui): inventory_ui.visible = true
			
			# 4. Restore Insurance Button (Logic Check)
			if is_instance_valid(insurance_form_button_ui):
				var should_be_visible = get_current_level_flag("insurance_button_unlocked")
				insurance_form_button_ui.visible = should_be_visible

			# 5. Unblock Input (Remove the gray blocker)
			if is_instance_valid(input_blocker_layer):
				input_blocker_layer.visible = false

			# 6. Unlock Player Movement
			if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
				player_node.set_can_move(true)
				
			print_rich("[color=green]GM: IN_GAME_PLAY state active. UI restored, Player unlocked.[/color]")

		GameState.PAUSED:
			pass

		GameState.BOOTING:
			pass
			
		GameState.CUTSCENE:
			# 1. Hide the UI
			if is_instance_valid(verb_ui): verb_ui.visible = false
			if is_instance_valid(inventory_ui): inventory_ui.visible = false
			if is_instance_valid(insurance_form_button_ui): insurance_form_button_ui.visible = false
			
			# 2. Block Input (Clicking on things in the world)
			if is_instance_valid(input_blocker_layer):
				input_blocker_layer.visible = true
				
			# 3. Stop the Player from moving
			if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
				player_node.set_can_move(false)
				
			print_rich("[color=Plum]GM: Entered CUTSCENE state. UI hidden, Input blocked.[/color]")
func select_verb(verb_id_to_select: String):
	var previously_selected_verb_id = current_verb_id
	var new_verb_id = ""

	if current_verb_id == verb_id_to_select:
		new_verb_id = ""
	else:
		var is_selectable = false
		for verb_data in get_currently_displayable_verbs():
			if verb_data.verb_id == verb_id_to_select:
				is_selectable = true; break
		if verb_id_to_select == "" or is_selectable:
			new_verb_id = verb_id_to_select
		else:
			print_rich("[color=orange]GM: Attempted to select unavailable verb: %s[/color]" % verb_id_to_select)
			new_verb_id = previously_selected_verb_id

	if current_verb_id != new_verb_id:
		current_verb_id = new_verb_id
		verb_changed.emit(current_verb_id)

		if current_verb_id != "" and current_verb_id != USE_ON_TARGET_VERB_ID and current_selected_item_data != null:
			print_rich("[color=lightblue]GM: Verb '%s' selected, previously 'in-hand' item '%s' deselected.[/color]" % [current_verb_id, current_selected_item_data.display_name])
			current_selected_item_data = null
			selected_inventory_item_changed.emit(null)
		elif current_verb_id == USE_ON_TARGET_VERB_ID and current_selected_item_data != null:
			print_rich("[color=lightblue]GM: Verb '%s' selected, keeping 'in-hand' item: '%s'[/color]" % [current_verb_id, current_selected_item_data.display_name])
		elif current_verb_id == "" and previously_selected_verb_id == USE_ON_TARGET_VERB_ID and current_selected_item_data != null:
			print_rich("[color=lightblue]GM: Verb '%s' deselected, also deselecting 'in-hand' item '%s'[/color]" % [previously_selected_verb_id, current_selected_item_data.display_name])
			current_selected_item_data = null
			selected_inventory_item_changed.emit(null)

	update_sentence_line_ui()
	print_rich("[color=cyan]GM STATE: Verb='%s', Item='%s'[/color]" % [current_verb_id if current_verb_id else "None", current_selected_item_data.display_name if current_selected_item_data else "None"])

func select_inventory_item(item_data_to_select: ItemData):
	var previous_verb_id_was_use_on_target = (current_verb_id == USE_ON_TARGET_VERB_ID)

	if not item_data_to_select:
		if current_selected_item_data != null:
			var deselected_item_name = current_selected_item_data.display_name
			current_selected_item_data = null
			selected_inventory_item_changed.emit(null)
			print_rich("[color=lightblue]GM: Deselected 'in-hand' item: '%s' (by selecting null)[/color]" % deselected_item_name)
		update_sentence_line_ui()
		print_rich("[color=cyan]GM STATE: Verb='%s', Item='%s'[/color]" % [current_verb_id if current_verb_id else "None", current_selected_item_data.display_name if current_selected_item_data else "None"])
		return

	if current_selected_item_data == item_data_to_select:
		var deselected_item_name = current_selected_item_data.display_name
		current_selected_item_data = null
		selected_inventory_item_changed.emit(null)
		print_rich("[color=lightblue]GM: Deselected 'in-hand' item by re-clicking: '%s'.[/color]" % deselected_item_name)
	else:
		current_selected_item_data = item_data_to_select
		selected_inventory_item_changed.emit(current_selected_item_data)
		print_rich("[color=lightblue]GM: Selected new 'in-hand' item: '%s' (ID: %s)[/color]" % [current_selected_item_data.display_name, current_selected_item_data.item_id])

		if current_verb_id != "" and not previous_verb_id_was_use_on_target:
			print_rich("[color=lightblue]GM: 'In-hand' item selected, previous verb '%s' deselected.[/color]" % current_verb_id)
			current_verb_id = ""
			verb_changed.emit("")
		elif previous_verb_id_was_use_on_target:
			print_rich("[color=lightblue]GM: 'In-hand' item selected, 'Use With' verb ('%s') remains active.[/color]" % USE_ON_TARGET_VERB_ID)

	update_sentence_line_ui()
	print_rich("[color=cyan]GM STATE: Verb='%s', Item='%s'[/color]" % [current_verb_id if current_verb_id else "None", current_selected_item_data.display_name if current_selected_item_data else "None"])


# --- UI and Interaction Flow ---
func set_hovered_object(interactable: Interactable):
	# Update the internal data immediately. 
	# This ensures the game knows exactly what is under the mouse, even while the camera is moving.
	hovered_interactable = interactable
	
	# Only update the visual UI text if the player isn't currently locked in a walk animation.
	if not _is_player_walking:
		update_sentence_line_ui()

func clear_hovered_object():
	# Clear the internal data immediately.
	hovered_interactable = null
	
	# Only update the visual UI text if the player isn't currently locked in a walk animation.
	if not _is_player_walking:
		update_sentence_line_ui()

func update_sentence_line_ui():
	var line_text = ""
	var verb_data_for_use_on_target = get_verb_data_by_id(USE_ON_TARGET_VERB_ID) # Get VerbData for display text

	if current_verb_id == USE_ON_TARGET_VERB_ID:
		# --- Handling for "Use Item With Target" verb ---
		var use_verb_display_text = USE_ON_TARGET_VERB_ID # Fallback
		if verb_data_for_use_on_target:
			use_verb_display_text = verb_data_for_use_on_target.display_text

		var source_item_name = "None Selected"
		if current_selected_item_data:
			source_item_name = current_selected_item_data.display_name

		line_text = "%s: %s" % [use_verb_display_text, source_item_name] # e.g., "Use With: Rusty Key" or "Use With: None Selected"

		if hovered_interactable:
			line_text += " ON " + hovered_interactable.object_display_name # e.g., " ON Burger"
		else:
			line_text += " ON..." # Waiting for target

	elif current_selected_item_data:
		# --- Handling for when an item is selected ("in hand") but NO verb is active (implicit use) ---
		# This is the "Item Name with Target Name" mode.
		line_text = current_selected_item_data.display_name
		if hovered_interactable:
			line_text += " with " + hovered_interactable.object_display_name # e.g., "Rusty Key with Door"
		# else: just the item name, like "Rusty Key" (player is holding it)

	elif current_verb_id != "":
		# --- Handling for other active verbs (Examine, Talk To, Pickup, etc.) ---
		var verb_data = get_verb_data_by_id(current_verb_id)
		var display_verb_text = current_verb_id # Fallback
		if verb_data:
			display_verb_text = verb_data.display_text

		line_text = display_verb_text
		if hovered_interactable:
			line_text += ": " + hovered_interactable.object_display_name # e.g., "Examine: Door"
		else:
			# For verbs that don't strictly require a target (like a generic "Look Around" verb)
			# or when waiting for a target for verbs that do.
			if verb_data and not verb_data.requires_target_object:
				pass # Just the verb display text is enough
			else:
				line_text += ":" # Add colon if no target, like "Examine:"

	# --- MODIFIED BLOCK ---
	# This now checks the object's location before creating the "Walk to" text.
	elif hovered_interactable and hovered_interactable.interaction_location == Interactable.InteractionLocation.WORLD:
		line_text = "Walk to: " + hovered_interactable.object_display_name

	# If line_text is still empty, it means no verb or item is selected, and nothing is hovered.
	# The UI should handle an empty string appropriately (e.g., hide the sentence line label).
	sentence_line_updated.emit(line_text)


func process_interaction_click(interactable_node: Interactable):
	# The initial check for _is_player_walking has been removed.

	if not is_instance_valid(interactable_node):
		print_rich("[color=red]GM: process_interaction_click with null or invalid interactable.[/color]")
		return

	print_rich("[color=aqua]GM: process_interaction_click on '%s'. Current Verb: '%s', Current Item: '%s'[/color]" % [
		interactable_node.object_display_name,
		current_verb_id if current_verb_id else "None",
		current_selected_item_data.display_name if current_selected_item_data else "None"
	])

	if current_verb_id == USE_ON_TARGET_VERB_ID:
		# --- Handling for explicit "Use Item With Target" verb ---
		if current_selected_item_data != null:
			# Both "Use With" verb and a source item are selected. Proceed.
			print_rich("[color=green]GM: Processing 'Use With': Item '%s' ON Target '%s'[/color]" % [current_selected_item_data.display_name, interactable_node.object_display_name])
			_initiate_interaction_flow(interactable_node, USE_ON_TARGET_VERB_ID, current_selected_item_data)
		else:
			# "Use With" verb is active, but no source item selected. Inform player.
			print_rich("[color=orange]GM: Cannot 'Use With' on '%s'. No source item selected from inventory.[/color]" % interactable_node.object_display_name)
			return

	elif current_selected_item_data != null: # No specific verb, but an item is "in hand" (implicit use)
		print_rich("[color=green]GM: Processing implicit item use: Item '%s' with Target '%s'[/color]" % [current_selected_item_data.display_name, interactable_node.object_display_name])
		_initiate_interaction_flow(interactable_node, IMPLICIT_USE_ITEM_VERB_ID, current_selected_item_data)

	elif current_verb_id != "": # A verb (other than "Use With") is selected, no item "in hand"
		print_rich("[color=green]GM: Processing verb: '%s' on Target '%s'[/color]" % [current_verb_id, interactable_node.object_display_name])
		_initiate_interaction_flow(interactable_node, current_verb_id, null)

	else: # No verb and no item selected.
		# The default "Walk to" action should ONLY apply to objects in the main world.
		if interactable_node.interaction_location == Interactable.InteractionLocation.WORLD:
			print_rich("[color=green]GM: Processing default 'Walk to' on Target '%s'[/color]" % interactable_node.object_display_name)
			_initiate_interaction_flow(interactable_node, WALK_TO_VERB_ID, null)
		else:
			# For UI objects, do nothing if no verb/item is selected. This is the desired behavior.
			print_rich("[color=yellow]GM: No verb/item selected for interaction with UI object '%s'. Ignoring click.[/color]" % interactable_node.object_display_name)
			return


func _initiate_interaction_flow(interactable_node: Interactable, verb_to_use_id: String, item_data_to_use: ItemData):
	if not is_instance_valid(interactable_node):
		print_rich("[color=red]GM: _initiate_interaction_flow called with invalid interactable_node.[/color]")
		_complete_interaction_cycle(); return

	# --- NEW LINE ADDED HERE ---
	# Tell the object (Aida) that an interaction is coming so she can stop walking immediately
	if interactable_node.has_method("notify_interaction_pending"):
		interactable_node.notify_interaction_pending()
	# ---------------------------

	var walk_needed = true

	if interactable_node.interaction_location == Interactable.InteractionLocation.UI_OVERLAY:
		walk_needed = false
	else:
		if interactable_node.has_method("does_verb_require_walk"):
			walk_needed = interactable_node.does_verb_require_walk(verb_to_use_id, item_data_to_use)
		else:
			print_rich("[color=yellow]GM: Interactable '%s' no 'does_verb_require_walk'. Assuming walk needed.[/color]" % interactable_node.name)
			walk_needed = true

	var item_name_for_log = "None"
	if item_data_to_use: item_name_for_log = item_data_to_use.display_name
	print_rich("[color=aqua]GM: Initiating flow: Verb '%s' on '%s' with item '%s'. Requires walk: %s[/color]" % [verb_to_use_id, interactable_node.object_display_name, item_name_for_log, str(walk_needed)])

	if walk_needed:
		# --- THIS IS THE FIX ---
		# Set the lock flag to true before telling the player to walk.
		_is_player_walking = true
		if not is_instance_valid(player_node):
			print_rich("[color=red]GM: Player node not set or invalid. Interacting immediately (if possible).[/color]")
			_perform_actual_interaction(interactable_node, verb_to_use_id, item_data_to_use)
			return
		if player_node.has_method("walk_to_and_interact"):
			var walk_target_pos = interactable_node.get_walk_to_position()
			player_node.walk_to_and_interact(walk_target_pos, interactable_node, verb_to_use_id, item_data_to_use)
		else:
			print_rich("[color=orange]GM: Player '%s' no 'walk_to_and_interact'. Interacting immediately.[/color]" % player_node.name)
			_perform_actual_interaction(interactable_node, verb_to_use_id, item_data_to_use)
	else:
		if is_instance_valid(player_node) and player_node.has_method("face_target"):
			if interactable_node.interaction_location == Interactable.InteractionLocation.WORLD:
				player_node.face_target(interactable_node.global_position)
		_perform_actual_interaction(interactable_node, verb_to_use_id, item_data_to_use)

# --- ADD THIS ENTIRE NEW FUNCTION ---
# The player will call this function to "unlock" input once they have stopped moving.
func player_has_finished_walk_command():
	_is_player_walking = false


func player_reached_interaction_target(interactable_node: Interactable, verb_to_use_id: String, item_data_to_use: ItemData):
	print_rich("[color=aqua]GM: Player has reached target '%s'. Performing interaction.[/color]" % interactable_node.object_display_name if is_instance_valid(interactable_node) else "[color=red]INVALID TARGET[/color]")
	if not is_instance_valid(interactable_node):
		print_rich("[color=red]GM: Player reached target, but interactable is no longer valid. Aborting interaction.[/color]")
		_complete_interaction_cycle(); return
	_perform_actual_interaction(interactable_node, verb_to_use_id, item_data_to_use)

func _perform_actual_interaction(interactable_node: Interactable, verb_to_use_id: String, item_in_hand_data: ItemData = null):
	if not is_instance_valid(interactable_node):
		print_rich("[color=red]GM: _perform_actual_interaction called with invalid interactable_node.[/color]")
		_complete_interaction_cycle(); return

	var item_name_for_log = "None"
	var item_id_for_interaction = ""
	if item_in_hand_data:
		item_name_for_log = item_in_hand_data.display_name
		item_id_for_interaction = item_in_hand_data.item_id

	print_rich("[color=aqua]GM: Performing actual interaction: Verb '%s' on '%s' with 'in-hand' item: '%s' (ID: '%s')[/color]" % [verb_to_use_id, interactable_node.object_display_name, item_name_for_log, item_id_for_interaction])

	_disconnect_interactable_request_signals()

	_signals_connected_to_interactable = interactable_node
	print_rich("[color=gray]GM: Connecting signals to Interactable: %s for non-dialogue interaction.[/color]" % interactable_node.name)

	if not interactable_node.display_dialogue.is_connected(_on_interactable_display_dialogue_console):
		interactable_node.display_dialogue.connect(_on_interactable_display_dialogue_console)
	if not interactable_node.interaction_processed.is_connected(_on_interactable_action_finished):
		interactable_node.interaction_processed.connect(_on_interactable_action_finished)
	if interactable_node.has_signal("request_remove_item_from_inventory") and not interactable_node.request_remove_item_from_inventory.is_connected(remove_item_from_inventory):
		interactable_node.request_remove_item_from_inventory.connect(remove_item_from_inventory)
	if interactable_node.has_signal("request_add_item_to_inventory") and not interactable_node.request_add_item_to_inventory.is_connected(add_item_to_inventory):
		interactable_node.request_add_item_to_inventory.connect(add_item_to_inventory)
	if interactable_node.has_signal("request_set_game_flag") and not interactable_node.request_set_game_flag.is_connected(set_game_flag):
		interactable_node.request_set_game_flag.connect(set_game_flag)
	if interactable_node.has_signal("request_set_level_flag") and not interactable_node.request_set_level_flag.is_connected(set_current_level_flag):
		print_rich("[color=darkcyan]GM: Connecting Interactable's request_set_level_flag to GM.set_current_level_flag[/color]")
		interactable_node.request_set_level_flag.connect(set_current_level_flag)

	interactable_node.attempt_interaction(verb_to_use_id, item_id_for_interaction)

# --- DialogueManager Signal Handlers (Global) ---
func _on_dialogue_started(_resource: Resource):
	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		player_node.set_can_move(false)

	# --- ADD THIS BLOCK ---
	# Hide the main UI whenever any dialogue line appears.
	# This handles both in-world dialogue and character conversations.
	if is_instance_valid(verb_ui):
		verb_ui.visible = false
	if is_instance_valid(inventory_ui):
		inventory_ui.visible = false


func _on_dialogue_ended_for_object_dialogue(_resource: Resource):
	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		player_node.set_can_move(true)

	# --- THIS IS THE FIX ---
	# Restore the main UI as long as we are NOT in a full-screen conversation.
	# This now correctly handles both the WORLD and the ZOOM_VIEW states.
	if current_interaction_state != InteractionState.CONVERSATION:
		if is_instance_valid(verb_ui):
			verb_ui.visible = true
		if is_instance_valid(inventory_ui):
			inventory_ui.visible = true

	_complete_interaction_cycle()

# Replace the entire existing function with this one.
func _on_character_conversation_finished(resource: DialogueResource):
	# First, perform all the necessary cleanup and state changes.
	exit_to_world_state()

	if _current_character_conversation_overlay_instance:
		_current_character_conversation_overlay_instance.queue_free()
		_current_character_conversation_overlay_instance = null

	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		player_node.set_can_move(true)

	_complete_interaction_cycle()

	# Now, simply announce that a conversation ended, and pass along which one.
	# The Main scene will be listening for this.
	character_conversation_ended.emit(resource)


# --- Interactable Signal Handlers ---
func _on_interactable_display_dialogue_console(text: String):
	print_rich("[color=yellow]GM (via Interactable Console): %s[/color]" % text)

func _on_interactable_action_finished():
	print_rich("[color=aqua]GM: Interactable action finished. Completing interaction cycle.[/color]")
	_complete_interaction_cycle()

func _disconnect_interactable_request_signals():
	if is_instance_valid(_signals_connected_to_interactable):
		var node_to_disconnect_from = _signals_connected_to_interactable
		print_rich("[color=gray]GM: Disconnecting signals from Interactable: %s[/color]" % node_to_disconnect_from.name)

		if node_to_disconnect_from.display_dialogue.is_connected(_on_interactable_display_dialogue_console):
			node_to_disconnect_from.display_dialogue.disconnect(_on_interactable_display_dialogue_console)
		if node_to_disconnect_from.interaction_processed.is_connected(_on_interactable_action_finished):
			node_to_disconnect_from.interaction_processed.disconnect(_on_interactable_action_finished)
		if node_to_disconnect_from.has_signal("request_remove_item_from_inventory") and \
		   node_to_disconnect_from.request_remove_item_from_inventory.is_connected(remove_item_from_inventory):
			node_to_disconnect_from.request_remove_item_from_inventory.disconnect(remove_item_from_inventory)
		if node_to_disconnect_from.has_signal("request_add_item_to_inventory") and \
		   node_to_disconnect_from.request_add_item_to_inventory.is_connected(add_item_to_inventory):
			node_to_disconnect_from.request_add_item_to_inventory.disconnect(add_item_to_inventory)
		if node_to_disconnect_from.has_signal("request_set_game_flag") and \
		   node_to_disconnect_from.request_set_game_flag.is_connected(set_game_flag):
			node_to_disconnect_from.request_set_game_flag.disconnect(set_game_flag)
		if node_to_disconnect_from.has_signal("request_set_level_flag") and \
		   node_to_disconnect_from.request_set_level_flag.is_connected(set_current_level_flag):
			print_rich("[color=gray]GM: Disconnecting Interactable's request_set_level_flag from GM.set_current_level_flag[/color]")
			node_to_disconnect_from.request_set_level_flag.disconnect(set_current_level_flag)
	else:
		if _signals_connected_to_interactable != null:
			print_rich("[color=yellow]GM: Tried to disconnect signals, but _signals_connected_to_interactable was invalid.[/color]")

	_signals_connected_to_interactable = null

func _complete_interaction_cycle():
	print_rich("[color=cyan]GM: Interaction cycle fully complete. Resetting state.[/color]")
	_disconnect_interactable_request_signals()
	interaction_complete.emit()

	current_verb_id = ""
	if current_selected_item_data:
		current_selected_item_data = null
		selected_inventory_item_changed.emit(null)

	# --- FIX START: Restore Player Control and UI ---
	# Since we removed the unfreeze logic from the individual Dialogue actions,
	# we must ensure the player is un-frozen here, at the absolute end of the chain.
	
	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		# Only unfreeze if we are in the normal gameplay state (not a full cutscene/zoom)
		if current_interaction_state == InteractionState.WORLD:
			player_node.set_can_move(true)

	# Restore UI visibility (Verbs and Inventory)
	if current_interaction_state != InteractionState.CONVERSATION:
		if is_instance_valid(verb_ui):
			verb_ui.visible = true
		if is_instance_valid(inventory_ui):
			inventory_ui.visible = true
	# --- FIX END ---

	update_sentence_line_ui()


# --- LevelStateManager Registration & Flag Handling ---
func register_level_state_manager(lsm: LevelStateManager):
	current_level_state_manager = lsm
	if is_instance_valid(lsm):
		print_rich("[color=LawnGreen]GM: Registered LevelStateManager: %s (from scene: %s)[/color]" % [lsm.name, lsm.get_parent().name if lsm.get_parent() else "N/A"])
		if lsm.has_method("print_initial_flags"):
			lsm.print_initial_flags()
	else:
		if lsm == null:
			print_rich("[color=yellow]GM: LevelStateManager unregistered (set to null).[/color]")
		else:
			print_rich("[color=orange]GM: Attempted to register invalid LevelStateManager instance.[/color]")

func set_current_level_flag(flag_name: String, value: bool):
	if is_instance_valid(current_level_state_manager):
		print_rich("[color=darkcyan]GM: Routing to LevelStateManager to set flag: %s = %s[/color]" % [flag_name, value])
		current_level_state_manager.set_level_flag(flag_name, value)
	else:
		print_rich("[color=orange]GM: No current LevelStateManager to set level flag '%s'. This might be an error if a level flag was intended.[/color]" % flag_name)

func get_current_level_flag(flag_name: String) -> bool:
	if is_instance_valid(current_level_state_manager):
		return current_level_state_manager.get_level_flag(flag_name)
	return false


# --- Verb Data and Availability ---
# In GameManager.gd

func get_verb_data_by_id(verb_id_to_find: String) -> VerbData:
	var id_for_lookup = verb_id_to_find

	# --- NEW LOGIC: DATA MAPPING ---
	# If the game's internal logic asks for an implicit or target-based "use" verb,
	# we remap it to the single, public "use" verb ID. This ensures that all "use"
	# actions correctly find the data stored in "use_verb.tres".
	if verb_id_to_find == IMPLICIT_USE_ITEM_VERB_ID or verb_id_to_find == USE_ON_TARGET_VERB_ID:
		id_for_lookup = "use"

	# The rest of the function remains the same. It now searches for "use".
	for verb_data_res in all_verb_data_resources:
		if verb_data_res and verb_data_res.verb_id == id_for_lookup:
			return verb_data_res

	# If nothing is found, return null as before.
	return null

func get_currently_displayable_verbs() -> Array[VerbData]:
	var displayable_verbs: Array[VerbData] = []
	for verb_data_res in all_verb_data_resources:
		if verb_data_res and verb_data_res.verb_id in unlocked_verb_ids:
			if active_scene_verb_ids.is_empty() or verb_data_res.verb_id in active_scene_verb_ids:
				displayable_verbs.append(verb_data_res)
	return displayable_verbs

func _emit_available_verbs_changed_update():
	available_verbs_changed.emit(get_currently_displayable_verbs())

func set_active_scene_verbs(verb_ids_for_scene: Array[String]):
	active_scene_verb_ids = verb_ids_for_scene.duplicate()
	_emit_available_verbs_changed_update()
	if current_verb_id != "" and not is_verb_id_currently_active(current_verb_id):
		select_verb("")

func unlock_verb(verb_id_to_unlock: String):
	var verb_data = get_verb_data_by_id(verb_id_to_unlock)
	if verb_data and not verb_id_to_unlock in unlocked_verb_ids:
		unlocked_verb_ids.append(verb_id_to_unlock)
		_emit_available_verbs_changed_update()
		print_rich("[color=green]GM: Unlocked verb: %s[/color]" % verb_id_to_unlock)
	elif not verb_data: print_rich("[color=red]GM: Tried to unlock non-existent verb: '%s'[/color]" % verb_id_to_unlock)
	elif verb_id_to_unlock in unlocked_verb_ids: print_rich("[color=yellow]GM: Verb '%s' already unlocked.[/color]" % verb_id_to_unlock)

func lock_verb(verb_id_to_lock: String):
	if verb_id_to_lock in unlocked_verb_ids:
		unlocked_verb_ids.erase(verb_id_to_lock)
		_emit_available_verbs_changed_update()
		print_rich("[color=yellow]GM: Locked verb: %s[/color]" % verb_id_to_lock)
		if current_verb_id == verb_id_to_lock:
			select_verb("")
	else: print_rich("[color=orange]GM: Tried to lock verb '%s' that was not unlocked or doesn't exist.[/color]" % verb_id_to_lock)

func is_verb_id_currently_active(verb_id_to_check: String) -> bool:
	if not verb_id_to_check in unlocked_verb_ids: return false
	if active_scene_verb_ids.is_empty(): return true
	return active_scene_verb_ids.has(verb_id_to_check)


# --- Inventory Management Functions ---
func add_item_to_inventory(item_id_to_add: String):
	print_rich("[color=aqua]GM: Attempting add_item_to_inventory for ID: '%s'[/color]" % item_id_to_add)
	var item_data = get_item_data_by_id(item_id_to_add)
	if not item_data:
		print_rich("[color=red]GM: add_item_to_inventory - FAILED. ItemData for id '%s' is null after lookup.[/color]" % item_id_to_add)
		return

	if not item_data.is_stackable and has_item(item_id_to_add):
		print_rich("[color=yellow]GM: Item '%s' (Name: %s, non-stackable) already in inventory. Not adding duplicate.[/color]" % [item_id_to_add, item_data.display_name])
		return

	player_inventory.append(item_data)
	inventory_updated.emit(player_inventory.duplicate())
	print_rich("[color=green]GM: Successfully added item '%s' (Name: %s) to inventory. Player now has %s items.[/color]" % [item_id_to_add, item_data.display_name, player_inventory.size()])
	show_notification("Picked up: " + item_data.display_name)

func remove_item_from_inventory(item_id_to_remove: String):
	print_rich("[color=aqua]GM: Attempting remove_item_from_inventory for ID: '%s'[/color]" % item_id_to_remove)
	var item_data_ref = get_item_data_by_id(item_id_to_remove)
	if not item_data_ref:
		print_rich("[color=red]GM: remove_item_from_inventory - FAILED. ItemData for id '%s' not found in master list.[/color]" % item_id_to_remove)
		return

	var item_found_and_removed = false
	for i in range(player_inventory.size() - 1, -1, -1):
		var item_data_in_inv: ItemData = player_inventory[i]
		if item_data_in_inv.item_id == item_id_to_remove:
			player_inventory.remove_at(i)
			item_found_and_removed = true
			print_rich("[color=green]GM: Removed item '%s' (Name: %s) from inventory.[/color]" % [item_id_to_remove, item_data_in_inv.display_name])

			if current_selected_item_data and current_selected_item_data.item_id == item_id_to_remove:
				current_selected_item_data = null
				selected_inventory_item_changed.emit(null)

			inventory_updated.emit(player_inventory.duplicate())
			if not item_data_ref.is_stackable: break

	if not item_found_and_removed:
		print_rich("[color=yellow]GM: Tried to remove item_id '%s' (Name: %s), but it was not found in player's inventory.[/color]" % [item_id_to_remove, item_data_ref.display_name])

func has_item(item_id_to_check: String) -> bool:
	for item_data_in_inv in player_inventory:
		if item_data_in_inv.item_id == item_id_to_check:
			return true
	return false

func get_item_data_by_id(item_id_to_find: String) -> ItemData:
	if _item_data_map.has(item_id_to_find):
		return _item_data_map[item_id_to_find]

	print_rich("[color=orange]GM: get_item_data_by_id - ItemData for id '%s' NOT FOUND in _item_data_map.[/color]" % item_id_to_find)
	print_rich("  [color=gray]GM: Current _item_data_map keys: %s[/color]" % str(_item_data_map.keys()))
	print_rich("  [color=gray]GM: Make sure '%s' is the exact item_id in your .tres file AND that .tres file is in 'all_item_data_resources' in GameManager Inspector.[/color]" % item_id_to_find)
	return null

func get_player_inventory() -> Array[ItemData]:
	return player_inventory.duplicate()


# --- Game Flag Management (Global) ---
func set_game_flag(flag_name: String, value: bool):
	if game_flags.get(flag_name, !value) == value:
		return
	game_flags[flag_name] = value
	print_rich("[color=green]GM: GLOBAL Flag set: '%s' = %s[/color]" % [flag_name, str(value)])

func get_game_flag(flag_name: String) -> bool:
	return game_flags.get(flag_name, false)

# ADD THESE THREE NEW FUNCTIONS

func enter_conversation_state():
	if current_interaction_state == InteractionState.CONVERSATION: return
	print_rich("[color=Plum]GM: Entering CONVERSATION state.[/color]")
	current_interaction_state = InteractionState.CONVERSATION

	# --- DEBUGGING STEP ---
	# Let's see if the GameManager can actually see your button node.
	print("Attempting to hide button UI. Node is: ", insurance_form_button_ui)
	# --- END DEBUGGING STEP ---

	# Show the blocker on layer 1 to stop clicks to the world (layer 0)
	if is_instance_valid(input_blocker_layer):
		input_blocker_layer.visible = true

	# Hide the game UI
	if is_instance_valid(verb_ui): verb_ui.visible = false
	if is_instance_valid(inventory_ui): inventory_ui.visible = false
	if is_instance_valid(insurance_form_button_ui): insurance_form_button_ui.visible = false

func enter_zoom_view_state():
	if current_interaction_state == InteractionState.ZOOM_VIEW: return
	print_rich("[color=Plum]GM: Entering ZOOM_VIEW state.[/color]")
	current_interaction_state = InteractionState.ZOOM_VIEW

	# ... (existing code for input blocker and UI layers) ...
	if is_instance_valid(input_blocker_layer):
		input_blocker_layer.visible = true
	if is_instance_valid(verb_ui):
		verb_ui.layer = 3
		verb_ui.visible = true
	if is_instance_valid(inventory_ui):
		inventory_ui.layer = 3
		inventory_ui.visible = true

	# --- THIS IS STILL IMPORTANT ---
	# Explicitly disabling player movement prevents weird input bugs on un-pause.
	if is_instance_valid(player_node):
		player_node.set_can_move(false)
	# -----------------------------

	# --- PAUSE THE ENTIRE GAME ---
	# This stops _process and _physics_process for all nodes unless their
	# process_mode is set to "Always".
	get_tree().paused = true
	# -----------------------------

func exit_to_world_state():
	print_rich("[color=Plum]GM: Exiting overlay, returning to WORLD state.[/color]")
	current_interaction_state = InteractionState.WORLD

	if is_instance_valid(input_blocker_layer):
		input_blocker_layer.visible = false
	if is_instance_valid(verb_ui):
		verb_ui.layer = 1
		verb_ui.visible = true
	if is_instance_valid(inventory_ui):
		inventory_ui.layer = 1
		inventory_ui.visible = true

	# --- THIS IS THE FIX (APPLIED HERE AS WELL) ---
	# Check the flag here too, so the button reappears after future conversations.
	if is_instance_valid(insurance_form_button_ui):
		var should_be_visible = get_current_level_flag("insurance_button_unlocked")
		insurance_form_button_ui.visible = should_be_visible
	# --- END OF FIX ---

	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		player_node.set_can_move(true)

	get_tree().paused = false


# In GameManager.gd
# Replace your entire _find_and_assign_ui_nodes function with this one.

# In GameManager.gd
# Replace the entire function.

func _find_and_assign_ui_nodes():
	# Check if we even have a main scene to search in.
	if not is_instance_valid(main_game_scene_instance):
		print_rich("[color=red]GM: Cannot find UI nodes because main_game_scene_instance is not valid.[/color]")
		return

	# Tell Godot to look INSIDE the main scene for these nodes using their Unique Scene Names.
	verb_ui = main_game_scene_instance.get_node_or_null("%VerbUI_CanvasLayer")
	inventory_ui = main_game_scene_instance.get_node_or_null("%InventoryUI_CanvasLayer")
	insurance_form_button_ui = main_game_scene_instance.get_node_or_null("%InsuranceFormButtonUI")
	input_blocker_layer = main_game_scene_instance.get_node_or_null("%InputBlockerLayer")
	explanation_layer = main_game_scene_instance.get_node_or_null("%ExplanationLayer")

	# --- Verification Logging ---
	if is_instance_valid(verb_ui):
		print_rich("[color=green]GM: Successfully found and assigned VerbUI.[/color]")
	else:
		print_rich("[color=red]GM: FAILED to find VerbUI.[/color]")

	if is_instance_valid(inventory_ui):
		print_rich("[color=green]GM: Successfully found and assigned InventoryUI.[/color]")
	else:
		print_rich("[color=red]GM: FAILED to find InventoryUI.[/color]")

	if is_instance_valid(insurance_form_button_ui):
		print_rich("[color=green]GM: Successfully found and assigned InsuranceFormButtonUI.[/color]")
		# --- THIS IS THE CORRECTED LINE ---
		# We now connect to the 'form_button_pressed' signal that your script emits.
		if not insurance_form_button_ui.form_button_pressed.is_connected(_on_insurance_form_button_pressed):
			insurance_form_button_ui.form_button_pressed.connect(_on_insurance_form_button_pressed)
	else:
		print_rich("[color=red]GM: FAILED to find InsuranceFormButtonUI.[/color]")

	if is_instance_valid(input_blocker_layer):
		print_rich("[color=green]GM: Successfully found and assigned InputBlockerLayer.[/color]")
	else:
		print_rich("[color=red]GM: FAILED to find InputBlockerLayer.[/color]")

	if is_instance_valid(explanation_layer):
		print_rich("[color=green]GM: Successfully found and assigned ExplanationLayer.[/color]")
		if not explanation_layer.explanation_finished.is_connected(exit_explanation_state):
			explanation_layer.explanation_finished.connect(exit_explanation_state)
	else:
		print_rich("[color=red]GM: FAILED to find ExplanationLayer.[/color]")
	transition_layer = main_game_scene_instance.get_node_or_null("%TransitionLayer")
	if is_instance_valid(transition_layer):
		print_rich("[color=green]GM: Found TransitionLayer.[/color]")
	else:
		print_rich("[color=red]GM: FAILED to find TransitionLayer.[/color]")
		
func _on_form_field_submitted(field_id: String, value):
	# Log the incoming data for debugging.
	print_rich("[color=Cyan]GM: Received submission for field '%s' with value: %s[/color]" % [field_id, value])

	# Use a 'match' statement to cleanly handle each field's data.
	match field_id:
		"first_name":
			# --- YOUR GAME LOGIC FOR THE NAME GOES HERE ---
			if value.to_lower() == "jane": # Example correct answer
				print_rich("[color=Green]GM Feedback: That name sounds familiar.[/color]")
				# TODO: Play a 'correct' sound, set a flag, etc.
				# set_game_flag("first_name_correct", true)
			else:
				print_rich("[color=Orange]GM Feedback: That name doesn't seem right...[/color]")
				# TODO: Play an 'incorrect' sound.

		"date_of_birth":
			# --- YOUR GAME LOGIC FOR THE DATE OF BIRTH GOES HERE ---
			if value == "12/05/2003": # Example correct answer
				print_rich("[color=Green]GM Feedback: The date has a certain significance.[/color]")
				# TODO: Play a 'correct' sound, set a flag, etc.
				# set_game_flag("dob_correct", true)
			else:
				print_rich("[color=Orange]GM Feedback: That date means nothing to me.[/color]")
				# TODO: Play an 'incorrect' sound.
# This function is called ONLY when the "Close Form" button is pressed.
func _on_insurance_form_closed():
	print_rich("[color=Yellow]GM: Insurance form was closed by the player.[/color]")

	# Clean up our reference to the form instance. This is important.
	_insurance_form_instance = null

	# Return control to the player and un-pause the game.
	exit_to_world_state()


# Add these new functions to the end of GameManager.gd
# In GameManager.gd
# Replace the entire existing function with this one.

func start_explanation(data: ExplanationData, root_node_to_search: Node):
	if current_game_state == GameState.EXPLANATION or not is_instance_valid(explanation_layer):
		return

	change_game_state(GameState.EXPLANATION)

	# --- THIS IS THE NEW, SMARTER HIDING LOGIC ---
	var nodes_to_keep_visible = []

	# --- THIS IS THE FIX ---
	# A Resource doesn't have a ".has()" method. The correct way to check for a property
	# is using the 'in' keyword.
	if "exceptions_to_hide" in data:
	# --- END OF FIX ---
		for node_path in data.exceptions_to_hide:
			var node = root_node_to_search.get_node_or_null(node_path)
			if is_instance_valid(node):
				nodes_to_keep_visible.append(node)

	if is_instance_valid(verb_ui) and not verb_ui in nodes_to_keep_visible:
		verb_ui.hide()

	if is_instance_valid(inventory_ui) and not inventory_ui in nodes_to_keep_visible:
		inventory_ui.hide()

	if is_instance_valid(insurance_form_button_ui):
		if insurance_form_button_ui in nodes_to_keep_visible:
			insurance_form_button_ui.show()
		else:
			insurance_form_button_ui.hide()
	# --- END OF NEW LOGIC ---

	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		player_node.set_can_move(false)

	get_tree().paused = true
	explanation_layer.show_explanation(data, root_node_to_search)

func exit_explanation_state():
	if current_game_state != GameState.EXPLANATION:
		return

	print_rich("[color=Plum]GM: Exiting EXPLANATION, returning to IN_GAME_PLAY state.[/color]")

	get_tree().paused = false

	# Show the main game UI
	if is_instance_valid(verb_ui): verb_ui.visible = true
	if is_instance_valid(inventory_ui): inventory_ui.visible = true

	# --- THIS IS THE FIX ---
	# Instead of just showing the button, check if it has been unlocked.
	if is_instance_valid(insurance_form_button_ui):
		var should_be_visible = get_current_level_flag("insurance_button_unlocked")
		insurance_form_button_ui.visible = should_be_visible
	# --- END OF FIX ---

	if is_instance_valid(player_node) and player_node.has_method("set_can_move"):
		player_node.set_can_move(true)

	change_game_state(GameState.IN_GAME_PLAY)

# In GameManager.gd
# Add these three missing functions to the end of the script.

# This function runs when the main UI button (on the game screen) is pressed.
func _on_insurance_form_button_pressed():
	# If a form is already open, do nothing. Prevents opening multiple forms.
	if is_instance_valid(_insurance_form_instance):
		return

	print_rich("[color=LawnGreen]GM: Opening insurance form...[/color]")

	# Create a new instance of our form scene.
	_insurance_form_instance = INSURANCE_FORM_SCENE.instantiate()

	# --- CONNECT TO THE NEW SIGNALS ---
	# Connect to the signal that's emitted when ANY "OK" button is pressed.
	_insurance_form_instance.field_submitted.connect(_on_form_field_submitted)
	# Connect to the signal that's emitted ONLY when the "Close Form" button is pressed.
	_insurance_form_instance.form_closed.connect(_on_insurance_form_closed)
	# ----------------------------------

	# Add the form to the main scene tree so it becomes visible.
	get_tree().root.add_child(_insurance_form_instance)

	# The form's own script hides it by default, so we show it now.
	_insurance_form_instance.show()

	# Pause the game world and disable player movement.
	enter_zoom_view_state()

# This function receives data from ANY "OK" button on the form.
func show_notification(message: String):
	notification_requested.emit(message)


func _on_main_menu_new_game_requested():
	print_rich("[color=LawnGreen]GM: 'New Game' requested. Starting intro sequence...[/color]")
	# We simply change the state. The change_game_state function will handle
	# cleaning up the menu and starting the next part of the game.
	change_game_state(GameState.INTRO_CONVERSATION)


func _on_main_menu_quit_requested():
	print_rich("[color=LawnGreen]GM: 'Quit Game' requested. Closing application.[/color]")
	get_tree().quit()


func _start_intro_conversation():
	print_rich("[color=yellow]GM: Starting intro sequence...[/color]")

	var intro_overlay_packed_scene = load(INTRO_OVERLAY_SCENE_PATH)
	if not intro_overlay_packed_scene:
		print_rich("[color=red]GM Error: Failed to load Intro Overlay Scene at path: %s[/color]" % INTRO_OVERLAY_SCENE_PATH)
		return

	var intro_overlay = intro_overlay_packed_scene.instantiate()

	# Configure its exported variables from code.
	intro_overlay.conversation_dialogue_file = load(INTRO_DIALOGUE_FILE_PATH)
	intro_overlay.background_animations = load(INTRO_BACKGROUND_ANIMATIONS_PATH)
	intro_overlay.initial_animation_name = INTRO_INITIAL_ANIMATION_NAME

	# Connect to its 'conversation_finished' signal.
	intro_overlay.conversation_finished.connect(_on_intro_conversation_finished, CONNECT_ONE_SHOT)

	# Add it to the scene tree so it becomes visible and starts running.
	get_tree().root.add_child(intro_overlay)


func _on_intro_conversation_finished(_dialogue_resource):
	print_rich("[color=yellow]GM: Intro conversation finished. Transitioning to main game...[/color]")
	# The intro is over, so we tell the GameManager to load the main game world.
	change_game_state(GameState.IN_GAME_PLAY)
</file>

<file path="interactable.gd">
extends Area2D
class_name Interactable

signal display_dialogue(text: String)
signal self_destruct_requested
signal interaction_processed

# Global/GameManager state requests
signal request_remove_item_from_inventory(item_id_to_remove: String)
signal request_add_item_to_inventory(item_id_to_add: String)
signal request_set_game_flag(flag_name: String, value: bool)
signal request_set_level_flag(flag_name: String, value: bool)
signal interaction_pending # Fired when the player clicks, but is still walking over

enum ObjectCategory { OBJECT, CHARACTER }
# --- NEW ENUM TO DEFINE WHERE THE INTERACTABLE EXISTS ---
enum InteractionLocation { WORLD, UI_OVERLAY }


@export var object_display_name: String = "Object"
@export var object_id: String = ""
@export var state_flag_id: String = ""
@export var category: ObjectCategory = ObjectCategory.OBJECT
# --- NEW EXPORT VARIABLE FOR THE LOCATION CONTEXT ---
@export var interaction_location: InteractionLocation = InteractionLocation.WORLD


# --- THE NEW SYSTEM IS NOW THE ONLY SYSTEM ---
@export var interactions: Array[InteractionResponse] = [preload("res://interactions/actions/DefaultExamineResponse.tres")]

@onready var object_sprite: Sprite2D = get_parent().get_node_or_null("ObjectSprite")
@onready var walk_to_point: Marker2D = $WalkToPoint if has_node("WalkToPoint") else null
var _is_mouse_over: bool = false

@export var character_conversation_overlay_scene: PackedScene
@export var object_zoom_overlay_scene: PackedScene


func _ready():
	if not state_flag_id.is_empty():
		if GameManager.get_current_level_flag(state_flag_id):
			get_parent().queue_free()
			return

	if object_id == "":
		object_id = name + "_" + str(get_instance_id())
		print_rich("[color=yellow]Interactable: '%s' no object_id. Auto-gen: %s[/color]" % [name, object_id])
	if category == ObjectCategory.CHARACTER and character_conversation_overlay_scene == null:
		print_rich("[color=orange]Interactable '%s' (ID: %s): Category CHARACTER but no 'character_conversation_overlay_scene'![/color]" % [object_display_name, object_id])
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	input_event.connect(_on_input_event)
	self_destruct_requested.connect(queue_free)

func _on_mouse_entered():
	_is_mouse_over = true
	if GameManager: GameManager.set_hovered_object(self)
	if object_sprite and object_sprite.material is ShaderMaterial and object_sprite.material.get_shader_parameter("enable_outline")!=null:
		object_sprite.material.set_shader_parameter("enable_outline", true)

func _on_mouse_exited():
	_is_mouse_over = false
	if GameManager: GameManager.clear_hovered_object()
	if object_sprite and object_sprite.material is ShaderMaterial and object_sprite.material.get_shader_parameter("enable_outline")!=null:
		object_sprite.material.set_shader_parameter("enable_outline", false)

func _on_input_event(_v: Viewport, event: InputEvent, _sidx: int):
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed():
		if GameManager: GameManager.process_interaction_click(self)

# --- FULLY REFACTORED CORE LOGIC ---
func attempt_interaction(verb_id: String, item_id_used_with: String = ""):
	# --- FIX: NORMALIZE "USE" VERBS ---
	# If GameManager sends "use_item" (because you have an item selected),
	# we treat it as "use" so you can simply type "use" in the Inspector.
	var effective_verb_id = verb_id
	if verb_id == "use_item" or verb_id == "use_on_target":
		effective_verb_id = "use"
	# ----------------------------------

	print_rich("[color=Orchid]--- Interactable '%s': attempt_interaction --- Verb: '%s' (Effective: '%s'), ItemID: '%s'[/color]" % [object_display_name, verb_id, effective_verb_id, item_id_used_with])

	# Check for a matching interaction in our resource array.
	for response in interactions:
		if not response or response.verb_id.is_empty():
			continue

		# 1. CHECK AGAINST EFFECTIVE VERB ID
		var verb_matches: bool = (response.verb_id == effective_verb_id)
		
		# 2. CHECK ITEM ID
		var item_matches: bool = (response.required_item_id == item_id_used_with)

		# 3. CHECK FLAG CONDITIONS
		var flag_matches: bool = true 
		if not response.required_flag_id.is_empty():
			# This checks the LevelStateManager via GameManager to see if the flag matches your Inspector setting
			if GameManager:
				flag_matches = (GameManager.get_current_level_flag(response.required_flag_id) == response.required_flag_value)
			else:
				flag_matches = false # Safety check

		# IF ALL CONDITIONS MET:
		if verb_matches and item_matches and flag_matches:
			print_rich("[color=LimeGreen]Found matching InteractionResponse for Verb '%s' and Item '%s' with Flag Condition Met.[/color]" % [effective_verb_id, item_id_used_with])

			# Execute the actions in order
			for action in response.actions_to_perform:
				if action:
					# Await the action execution. 
					# This handles the timing for Dialogue (Wait for close) and Sounds (Wait for finish).
					await action.execute(self)

			# Signal to GameManager that the entire sequence is done.
			# This triggers the "Unfreeze Player" and "Restore UI" logic in GameManager.
			interaction_processed.emit()
			return

	# --- FALLBACK LOGIC (If no match found above) ---
	
	if GameManager:
		# Use the original verb_id for fallback lookup (or effective, depending on your fallback setup)
		var verb_data = GameManager.get_verb_data_by_id(verb_id) 
		if is_instance_valid(verb_data) and is_instance_valid(verb_data.fallback_dialogue_file):
			print_rich("[color=Goldenrod]No match found. Calling FallbackManager.[/color]")
			if FallbackManager:
				FallbackManager.trigger_fallback(verb_data, self.object_id, item_id_used_with)
			return

	# Final safety net if no fallback is configured
	print_rich("[color=Red]No interaction response and no fallback file found for verb '%s'.[/color]" % verb_id)
	display_dialogue.emit("I can't seem to do that.")
	interaction_processed.emit()

func get_walk_to_position() -> Vector2:
	if walk_to_point: return walk_to_point.global_position
	return get_parent().global_position

# --- CORRECTED VERSION OF THIS FUNCTION ---
# This function provides simple, reliable logic for walking.
func does_verb_require_walk(verb_id_to_check: String, item_data_used: ItemData = null) -> bool:
	# 1. "Walk to" always requires walking.
	if verb_id_to_check == "walk_to":
		return true

	# 2. Determine the Item ID we are checking against
	var item_id_checking = ""
	if item_data_used:
		item_id_checking = item_data_used.item_id

	# 3. Search through the interactions array to find the SPECIFIC response that will trigger.
	# We use the exact same matching logic as attempt_interaction() to find the right one.
	for response in interactions:
		if not response: continue

		# Check basic matches
		var verb_matches: bool = (response.verb_id == verb_id_to_check)
		var item_matches: bool = (response.required_item_id == item_id_checking)

		# Check flag matches (Logic matching attempt_interaction)
		var flag_matches: bool = true
		if not response.required_flag_id.is_empty():
			# If a flag ID is specified, we must check it.
			flag_matches = (GameManager.get_current_level_flag(response.required_flag_id) == response.required_flag_value)

		# If we found the valid interaction response that is going to fire:
		if verb_matches and item_matches and flag_matches:
			# Return the custom setting from the Inspector
			return response.requires_walk

	# 4. Fallback defaults if no specific interaction was found in the list.
	# If the specific interaction isn't defined, we fall back to generic rules.
	
	if verb_id_to_check == "examine":
		return false
		
	if verb_id_to_check == "talk_to" and category == ObjectCategory.CHARACTER:
		return true

	# Default safety net: If we don't know what to do, walk to it.
	return true


func notify_interaction_pending():
	interaction_pending.emit()
</file>

<file path="main.tscn">
[gd_scene load_steps=144 format=3 uid="uid://cqtgjhr5nepn1"]

[ext_resource type="PackedScene" uid="uid://bigouorladqds" path="res://VerbUI.tscn" id="1_1bvp3"]
[ext_resource type="Script" uid="uid://suh4s1w73ooy" path="res://Main.gd" id="1_efxa6"]
[ext_resource type="PackedScene" uid="uid://ba2cgdy2q1csl" path="res://player.tscn" id="1_pgf6g"]
[ext_resource type="Resource" uid="uid://ccyinn2ynsx1p" path="res://AIda.dialogue" id="2_0cbny"]
[ext_resource type="PackedScene" uid="uid://d3c3oshbfjh6w" path="res://static_wall_background.tscn" id="2_dg77c"]
[ext_resource type="Script" uid="uid://dljo5cmv24o5h" path="res://camera_2d.gd" id="2_h2yge"]
[ext_resource type="PackedScene" uid="uid://cud6uaak7lo18" path="res://InventoryUI.tscn" id="2_kek77"]
[ext_resource type="PackedScene" uid="uid://c3shvlwnp4663" path="res://interactable.tscn" id="2_lquwl"]
[ext_resource type="Texture2D" uid="uid://smwtb1ho1c5j" path="res://png-clipart-hamburger-cheeseburger-fast-food-pixel-art-burger-king-food-cheese.png" id="3_7mycd"]
[ext_resource type="Resource" uid="uid://d3deg4gqysr72" path="res://ExplanationData.tres" id="3_hrvbo"]
[ext_resource type="PackedScene" uid="uid://dojqgskjk44nk" path="res://Test_Conversation.tscn" id="4_ntx8l"]
[ext_resource type="PackedScene" uid="uid://mbqo64idf1si" path="res://static_wall_background_ventless.tscn" id="4_rm4vd"]
[ext_resource type="PackedScene" uid="uid://btku3hrvme7k6" path="res://static_bathroom_background.tscn" id="5_f6a44"]
[ext_resource type="PackedScene" uid="uid://cj8nc55uc3in" path="res://Interactables/Game World/Hospital Bathroom/hospital_bathroom_toilet_paper.tscn" id="6_e71vb"]
[ext_resource type="PackedScene" uid="uid://dq1e26q2d8nix" path="res://Interactables/Game World/Hospital Bathroom/hospital_toilet.tscn" id="6_uypp3"]
[ext_resource type="Texture2D" uid="uid://bl6sy4jw0eepu" path="res://Sprites/Hospital Bathroom/hospital_bathroom_commode.PNG" id="7_6iyjs"]
[ext_resource type="Texture2D" uid="uid://dj4qqp4dhq5l4" path="res://faye.png" id="7_272bh"]
[ext_resource type="Resource" uid="uid://bivfrghh084ym" path="res://interactions/actions/DefaultExamineResponse.tres" id="7_jq2sk"]
[ext_resource type="PackedScene" uid="uid://dwqwwrmp7uisr" path="res://Interactables/Game World/Hospital Bathroom/hospital_bathroom_toilet_flush.tscn" id="7_rnkwl"]
[ext_resource type="PackedScene" uid="uid://oy53tf8tvxe5" path="res://aida.tscn" id="8_vivmo"]
[ext_resource type="Script" uid="uid://bapryqa2s86c5" path="res://interactions/actions/SayLineAction.gd" id="9_4k2k6"]
[ext_resource type="Texture2D" uid="uid://bcxknipqlnnip" path="res://Sprites/Hospital Bathroom/hospital_bathroom_sink.png" id="9_4w656"]
[ext_resource type="Script" uid="uid://nvyqoryt5sbh" path="res://interactions/actions/AddItemAction.gd" id="10_0rl1p"]
[ext_resource type="Script" uid="uid://bs05cyo72v37l" path="res://LevelStateManager.gd" id="10_4c57u"]
[ext_resource type="PackedScene" uid="uid://frycmvsnkt3j" path="res://Sergei.tscn" id="10_getpj"]
[ext_resource type="Resource" uid="uid://buvvctce1wr7t" path="res://use_item_accompanying_dialogue.dialogue" id="10_vke2r"]
[ext_resource type="Script" uid="uid://c5bw6trnybm71" path="res://interactions/actions/DestroyAction.gd" id="11_ok6jj"]
[ext_resource type="PackedScene" uid="uid://dq4pkbax7ni44" path="res://mcbucket_med_dispenser.tscn" id="12_a6jrf"]
[ext_resource type="PackedScene" uid="uid://c8w3xusvs4d7d" path="res://mcbucket.tscn" id="13_0odxb"]
[ext_resource type="PackedScene" uid="uid://bjnf6egwtuqv5" path="res://MedCabinetzoomin.tscn" id="14_cegan"]
[ext_resource type="Script" uid="uid://bfn877nkjq8gv" path="res://interactions/actions/PlaySoundAction.gd" id="14_ruth0"]
[ext_resource type="PackedScene" uid="uid://3rnka5lbsieb" path="res://tubelight.tscn" id="14_w48qg"]
[ext_resource type="Resource" uid="uid://dlyoiu6syhnqe" path="res://unusables.dialogue" id="15_uit24"]
[ext_resource type="Script" uid="uid://dwldhrx7leysr" path="res://interactable.gd" id="16_2cqfq"]
[ext_resource type="PackedScene" uid="uid://bkjbta25aa1fj" path="res://Interactables/Game World/Hospital Bathroom/hospital_bathroom_mirror.tscn" id="16_blkrb"]
[ext_resource type="PackedScene" uid="uid://c4v86fmondjfo" path="res://AidaDialogue.tscn" id="16_come4"]
[ext_resource type="PackedScene" uid="uid://crcjecrrvndr2" path="res://Interactables/Game World/Hospital Room/medicine_cabinet.tscn" id="17_074og"]
[ext_resource type="PackedScene" uid="uid://b7dat8bd2cm67" path="res://have_more_logo.tscn" id="18_d13ii"]
[ext_resource type="Script" uid="uid://7xsscyp60ilq" path="res://interactions/actions/CallMethodAction.gd" id="19_4k2k6"]
[ext_resource type="Script" uid="uid://b4i2dd2kqpmun" path="res://interactions/actions/RemoveItemAction.gd" id="20_0rl1p"]
[ext_resource type="PackedScene" uid="uid://c2mnsensqkur6" path="res://Sergei_Conversation.tscn" id="20_h8e4i"]
[ext_resource type="Script" uid="uid://h83nrnu1277x" path="res://interactions/actions/StartConversationAction.gd" id="22_b1qrp"]
[ext_resource type="PackedScene" uid="uid://ckc058if0px63" path="res://mcbucket_default_conversation.tscn" id="22_facbu"]
[ext_resource type="PackedScene" uid="uid://bpk8g8k1r5vb6" path="res://test_box.tscn" id="23_0odxb"]
[ext_resource type="Script" uid="uid://dosqfqbexlf5k" path="res://interactions/actions/OpenZoomViewAction.gd" id="24_ok6jj"]
[ext_resource type="Script" uid="uid://bmq0s1nqhqi4j" path="res://InteractionResponse.gd" id="24_qsp4k"]
[ext_resource type="Script" uid="uid://dltqnu07oiff" path="res://action.gd" id="25_kq58d"]
[ext_resource type="Script" uid="uid://8n5g87ifbnd5" path="res://interactions/actions/SetLevelFlagAction.gd" id="27_0n3wm"]
[ext_resource type="PackedScene" uid="uid://dg2mtprp1wybv" path="res://sergei_med_dispenser.tscn" id="27_a6jrf"]
[ext_resource type="PackedScene" uid="uid://ctrgw5138xyjg" path="res://hospital_bathroom_door.tscn" id="30_pjyto"]
[ext_resource type="Script" uid="uid://bjrpwaag6vx20" path="res://interactions/actions/TriggerCutsceneAction.gd" id="32_ntx8l"]
[ext_resource type="PackedScene" uid="uid://cymg2dkrvsnfy" path="res://explanation_layer.tscn" id="38_d2t1y"]
[ext_resource type="PackedScene" uid="uid://cxo2auakscy0h" path="res://hospital_door.tscn" id="40_h8e4i"]
[ext_resource type="PackedScene" uid="uid://cn3wt8p41equ0" path="res://insurance_form_button_ui.tscn" id="41_4lmeg"]
[ext_resource type="PackedScene" uid="uid://dk7b3f3vitmx1" path="res://TransitionLayer.tscn" id="41_hrvbo"]
[ext_resource type="Script" uid="uid://dm3vji871klli" path="res://interactions/actions/TeleportAction.gd" id="44_0cbny"]
[ext_resource type="PackedScene" uid="uid://cpvtyvf4t8pht" path="res://memory_box.tscn" id="44_gngh3"]
[ext_resource type="Resource" uid="uid://bom2aj2a6w76n" path="res://generic_lines.dialogue" id="45_qnost"]
[ext_resource type="Script" uid="uid://bvfc7q2g4fum1" path="res://interactions/actions/OpenMemoryBoxAction.gd" id="45_wnkbs"]
[ext_resource type="Script" uid="uid://8c6cnm8lo25p" path="res://interactions/actions/ShowCustomDialogueAction.gd" id="46_wnkbs"]
[ext_resource type="Texture2D" uid="uid://dxrfme6ebfa8c" path="res://hospital bed.png" id="47_wnkbs"]
[ext_resource type="PackedScene" uid="uid://b8abif6uqojn4" path="res://tv.tscn" id="48_f6a44"]
[ext_resource type="PackedScene" uid="uid://b7ruec2vo6haw" path="res://Non Interactables/hospital_bathroom_sink.tscn" id="53_abqjc"]
[ext_resource type="Script" uid="uid://c2cuhw0y84tao" path="res://Cutscenes/ToiletClogCutscene.gd" id="63_sm6fg"]
[ext_resource type="Resource" uid="uid://dmkt054qdywph" path="res://test.dialogue" id="64_b17eg"]

[sub_resource type="Resource" id="Resource_4obbf"]
script = ExtResource("10_0rl1p")
item_id_to_add = "hospital_toilet_paper"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_f1p13"]
script = ExtResource("24_qsp4k")
verb_id = "use"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_4obbf")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_birbe"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("10_vke2r")
dialogue_checkpoint = "hospital_toilet_already_broken"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_1yv1y"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_id = "toilet_clogged"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_birbe")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_5yh34"]
script = ExtResource("14_ruth0")
sound_name = "hospital_toilet_flush"
metadata/_custom_type_script = "uid://bfn877nkjq8gv"

[sub_resource type="Resource" id="Resource_pjuso"]
script = ExtResource("19_4k2k6")
target_node_path = NodePath("../HospitalToilet")
method_name = "change_state"
arguments = [2]
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_jbvwl"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("10_vke2r")
dialogue_checkpoint = "toilet_flushed_stuck"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_sn1fb"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_id = "toilet_has_paper"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_5yh34"), SubResource("Resource_pjuso"), SubResource("Resource_jbvwl"), null])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_yjja3"]
script = ExtResource("14_ruth0")
sound_name = "hospital_toilet_flush"
metadata/_custom_type_script = "uid://bfn877nkjq8gv"

[sub_resource type="Resource" id="Resource_yvsr8"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "toilet_flush_weak"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_vieuh"]
script = ExtResource("24_qsp4k")
verb_id = "use"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_yjja3"), SubResource("Resource_yvsr8")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_ppx11"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("15_uit24")
dialogue_checkpoint = "hospital_toilet_already_dropped"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_ovcoh"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "hospital_toilet_paper"
required_flag_id = "toilet_has_paper"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_ppx11")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_23xmf"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("15_uit24")
dialogue_checkpoint = "hospital_toilet_already_clogged"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_swlj1"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "hospital_toilet_paper"
required_flag_id = "toilet_clogged"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_23xmf")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_yysqy"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("10_vke2r")
dialogue_checkpoint = "toilet_clog_success"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_n5t1e"]
script = ExtResource("20_0rl1p")
item_id_to_remove = "hospital_toilet_paper"
metadata/_custom_type_script = "uid://b4i2dd2kqpmun"

[sub_resource type="Resource" id="Resource_h6isl"]
script = ExtResource("19_4k2k6")
target_node_path = NodePath("..")
method_name = "change_state"
arguments = [1]
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_53bls"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "hospital_toilet_paper"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_yysqy"), SubResource("Resource_n5t1e"), SubResource("Resource_h6isl")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_lwnsi"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("15_uit24")
dialogue_checkpoint = "hospital_toilet_regular_use"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_41lik"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_value = false
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_lwnsi")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Gradient" id="Gradient_rnkwl"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.6041096)
colors = PackedColorArray(0.33333334, 0.13333334, 0.2, 1, 0.33, 0.132, 0.19800003, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_abqjc"]
gradient = SubResource("Gradient_rnkwl")
fill = 1
fill_from = Vector2(0.50427353, 0.5)
fill_to = Vector2(0.008547009, 0.014957265)

[sub_resource type="Resource" id="Resource_facbu"]
script = ExtResource("9_4k2k6")
line_to_say = "picked up the rusty key"
metadata/_custom_type_script = "uid://bapryqa2s86c5"

[sub_resource type="Resource" id="Resource_b1qrp"]
script = ExtResource("10_0rl1p")
item_id_to_add = "key_rusty"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_come4"]
script = ExtResource("11_ok6jj")
metadata/_custom_type_script = "uid://c5bw6trnybm71"

[sub_resource type="Resource" id="Resource_h8e4i"]
script = ExtResource("24_qsp4k")
verb_id = "pickup"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_facbu"), SubResource("Resource_b1qrp"), SubResource("Resource_come4")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="RectangleShape2D" id="RectangleShape2D_pjluw"]
size = Vector2(9583, 90.4065)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_0cbny"]
size = Vector2(2181, 76)

[sub_resource type="Resource" id="Resource_l0gw7"]
script = ExtResource("44_0cbny")
target_marker_name = "ClinicSpawnPoint1"
metadata/_custom_type_script = "uid://dm3vji871klli"

[sub_resource type="Resource" id="Resource_wat4s"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_id = "aida_fixing_toilet"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_l0gw7")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_k1udn"]
script = ExtResource("32_ntx8l")
cutscene_node_name = "ToiletClogCutscene"
metadata/_custom_type_script = "uid://bjrpwaag6vx20"

[sub_resource type="Resource" id="Resource_dij0e"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_id = "toilet_clogged"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_l0gw7"), SubResource("Resource_k1udn")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_inymm"]
script = ExtResource("24_qsp4k")
verb_id = "use"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_l0gw7")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_qnost"]
script = ExtResource("22_b1qrp")
metadata/_custom_type_script = "uid://h83nrnu1277x"

[sub_resource type="Resource" id="Resource_wnkbs"]
script = ExtResource("24_qsp4k")
verb_id = "talk_to"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_qnost")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_htxhm"]
script = ExtResource("24_qsp4k")
verb_id = "examine"
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_f6a44"]
script = ExtResource("22_b1qrp")
metadata/_custom_type_script = "uid://h83nrnu1277x"

[sub_resource type="Resource" id="Resource_0cbny"]
script = ExtResource("24_qsp4k")
verb_id = "talk_to"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_f6a44")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_4lmeg"]
script = ExtResource("20_0rl1p")
item_id_to_remove = "cannathink"
metadata/_custom_type_script = "uid://b4i2dd2kqpmun"

[sub_resource type="Resource" id="Resource_ntx8l"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "mcbucket_med_given_after_zanopram"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_1vm84"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "cannathink"
required_flag_id = "mcbucket_zanopram_used"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_4lmeg"), SubResource("Resource_ntx8l")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_rqtf5"]
script = ExtResource("20_0rl1p")
item_id_to_remove = "invigirol"
metadata/_custom_type_script = "uid://b4i2dd2kqpmun"

[sub_resource type="Resource" id="Resource_kkkcx"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "mcbucket_med_given_after_zanopram"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_5dllo"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "invigirol"
required_flag_id = "mcbucket_zanopram_used"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_rqtf5"), SubResource("Resource_kkkcx")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_0dhbp"]
script = ExtResource("20_0rl1p")
item_id_to_remove = "zanopram"
metadata/_custom_type_script = "uid://b4i2dd2kqpmun"

[sub_resource type="Resource" id="Resource_34ol3"]
script = ExtResource("19_4k2k6")
target_node_path = NodePath("../McBucket_Path/McBucket")
method_name = "change_state"
arguments = [3]
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_jx0wj"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "zanopram"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_0dhbp"), SubResource("Resource_34ol3")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_uatky"]
script = ExtResource("19_4k2k6")
target_node_path = NodePath("../McBucket_Path/McBucket")
method_name = "change_state"
arguments = [1]
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_ok6jj"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "cannathink"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_4lmeg"), SubResource("Resource_uatky")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_cyx1q"]
script = ExtResource("19_4k2k6")
target_node_path = NodePath("../McBucket_Path/McBucket")
method_name = "change_state"
arguments = [2]
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_wu3dr"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_item_id = "invigirol"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_rqtf5"), SubResource("Resource_cyx1q")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_gx4rg"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "mcbucket_sleeping_talk_to_response"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_0n3wm"]
script = ExtResource("24_qsp4k")
verb_id = "talk_to"
required_flag_id = "mcbucket_zanopram_used"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_gx4rg")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_6iyjs"]
script = ExtResource("27_0n3wm")
flag_name = "mcbucket_cannathink_used"
metadata/_custom_type_script = "uid://8n5g87ifbnd5"

[sub_resource type="Resource" id="Resource_4w656"]
script = ExtResource("19_4k2k6")
target_node_path = NodePath("..")
method_name = "on_player_used_cannathink"
metadata/_custom_type_script = "uid://7xsscyp60ilq"

[sub_resource type="Resource" id="Resource_e71vb"]
script = ExtResource("20_0rl1p")
item_id_to_remove = "cannathink"
metadata/_custom_type_script = "uid://b4i2dd2kqpmun"

[sub_resource type="Resource" id="Resource_abqjc"]
script = ExtResource("24_qsp4k")
verb_id = "use_item"
required_item_id = "cannathink"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_6iyjs"), SubResource("Resource_4w656"), SubResource("Resource_e71vb")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_c2n8d"]
script = ExtResource("22_b1qrp")
metadata/_custom_type_script = "uid://h83nrnu1277x"

[sub_resource type="Resource" id="Resource_wy5fy"]
script = ExtResource("24_qsp4k")
verb_id = "talk_to"
required_flag_value = false
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_c2n8d")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_kq58d"]
script = ExtResource("24_qsp4k")
verb_id = "examine"
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_jcxqu"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "medicine_cabinet_interrupt"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_0arob"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_id = "aida_in_main_room"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_jcxqu")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_0cp0l"]
script = ExtResource("24_ok6jj")
metadata/_custom_type_script = "uid://dosqfqbexlf5k"

[sub_resource type="Resource" id="Resource_d2t1y"]
script = ExtResource("24_qsp4k")
verb_id = "use"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_0cp0l")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_4k2k6"]
script = ExtResource("24_qsp4k")
verb_id = "examine"
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_hrvbo"]
script = ExtResource("10_0rl1p")
item_id_to_add = "testbox"
metadata/_custom_type_script = "uid://nvyqoryt5sbh"

[sub_resource type="Resource" id="Resource_blkrb"]
script = ExtResource("11_ok6jj")
metadata/_custom_type_script = "uid://c5bw6trnybm71"

[sub_resource type="Resource" id="Resource_uypp3"]
script = ExtResource("24_qsp4k")
verb_id = "pickup"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_hrvbo"), SubResource("Resource_blkrb")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_phcyf"]
script = ExtResource("44_0cbny")
target_marker_name = "BathroomSpawnPoint"
metadata/_custom_type_script = "uid://dm3vji871klli"

[sub_resource type="Resource" id="Resource_rnkwl"]
script = ExtResource("24_qsp4k")
verb_id = "use"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_phcyf")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_vke2r"]
script = ExtResource("45_wnkbs")
metadata/_custom_type_script = "uid://bvfc7q2g4fum1"

[sub_resource type="Resource" id="Resource_b17eg"]
script = ExtResource("24_qsp4k")
verb_id = "use"
required_flag_id = "memory_box_unlocked"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_vke2r")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_uit24"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "memory_box_unlocked"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_rm4vd"]
script = ExtResource("27_0n3wm")
flag_name = "memory_box_unlocked"
metadata/_custom_type_script = "uid://8n5g87ifbnd5"

[sub_resource type="Resource" id="Resource_ruth0"]
script = ExtResource("24_qsp4k")
verb_id = "use_item"
required_item_id = "key_rusty"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_uit24"), SubResource("Resource_rm4vd")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[sub_resource type="Resource" id="Resource_pjyto"]
script = ExtResource("46_wnkbs")
dialogue_resource = ExtResource("45_qnost")
dialogue_checkpoint = "memory_box_locked"
metadata/_custom_type_script = "uid://8c6cnm8lo25p"

[sub_resource type="Resource" id="Resource_sm6fg"]
script = ExtResource("24_qsp4k")
verb_id = "use"
actions_to_perform = Array[ExtResource("25_kq58d")]([SubResource("Resource_pjyto")])
metadata/_custom_type_script = "uid://bmq0s1nqhqi4j"

[node name="Main" type="Control" node_paths=PackedStringArray("sergei_interactable")]
layout_mode = 3
anchors_preset = 0
offset_left = -5752.0
offset_top = -597.0
offset_right = -5752.0
offset_bottom = -597.0
mouse_filter = 2
script = ExtResource("1_efxa6")
aida_dialogue_resource = ExtResource("2_0cbny")
aida_explanation_data = ExtResource("3_hrvbo")
sergei_after_drug_overlay_scene = ExtResource("4_ntx8l")
sergei_interactable = NodePath("Sergei_Path/Sergei/InteractionArea")

[node name="BackgroundContainer" type="Node2D" parent="."]
z_index = -30

[node name="ColorRect" type="ColorRect" parent="BackgroundContainer"]
z_index = -21
offset_left = -5533.0
offset_top = -2549.0
offset_right = 31492.172
offset_bottom = 6669.0
mouse_filter = 2
color = Color(0, 0, 0, 1)
metadata/_edit_use_anchors_ = true

[node name="WallContainer" type="Node2D" parent="."]
z_index = -11
position = Vector2(-817, -540.07)
scale = Vector2(0.5, 0.5)

[node name="StaticWallBackground6" parent="WallContainer" instance=ExtResource("4_rm4vd")]
position = Vector2(-160, 2)

[node name="StaticWallBackground2" parent="WallContainer" instance=ExtResource("2_dg77c")]
position = Vector2(3680, 2)

[node name="StaticWallBackground3" parent="WallContainer" instance=ExtResource("2_dg77c")]
position = Vector2(7520, 0)

[node name="StaticWallBackground4" parent="WallContainer" instance=ExtResource("2_dg77c")]
position = Vector2(11360, 0)

[node name="StaticWallBackground5" parent="WallContainer" instance=ExtResource("2_dg77c")]
z_index = 1
position = Vector2(15194, 0)

[node name="BathroomContainer" type="Node2D" parent="."]
unique_name_in_owner = true
z_index = -5
position = Vector2(-817, 1500)
scale = Vector2(0.5, 0.5)

[node name="StaticWallBackground" parent="BathroomContainer" instance=ExtResource("5_f6a44")]

[node name="HospitalBathroomToiletPaper" parent="." instance=ExtResource("6_e71vb")]
position = Vector2(462, 2066)
scale = Vector2(0.5, 0.5)
object_display_name = "Toilet Paper Dispenser"
object_id = "toilet_paper_dispenser"
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_f1p13")])

[node name="HospitalBathroomToiletPaper2" parent="." instance=ExtResource("7_rnkwl")]
position = Vector2(643, 1931)
scale = Vector2(0.4, 0.4)
object_display_name = "Toilet Flush"
object_id = "toilet_flush"
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_1yv1y"), SubResource("Resource_sn1fb"), SubResource("Resource_vieuh")])

[node name="HospitalToilet" parent="." instance=ExtResource("6_uypp3")]
position = Vector2(641, 2120)
scale = Vector2(0.6, 0.6)

[node name="InteractionArea" parent="HospitalToilet" index="2"]
object_display_name = "Toilet"
object_id = "hospital_toilet"
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_ovcoh"), SubResource("Resource_swlj1"), SubResource("Resource_53bls"), SubResource("Resource_41lik")])

[node name="WallShadow" type="Sprite2D" parent="HospitalToilet"]
modulate = Color(0.33, 0.132, 0.19800003, 0.11764706)
z_index = -1
texture = ExtResource("7_6iyjs")
offset = Vector2(7, 6)

[node name="ToiletFloorShadow" type="Sprite2D" parent="HospitalToilet"]
position = Vector2(-3.3333335, 198.33333)
scale = Vector2(5.885404, 1.7708337)
texture = SubResource("GradientTexture2D_abqjc")

[node name="HospitalBathroomSink" parent="." instance=ExtResource("53_abqjc")]
position = Vector2(-497, 2038)
scale = Vector2(0.5, 0.5)

[node name="Wallshadow" type="Sprite2D" parent="HospitalBathroomSink"]
modulate = Color(0.33, 0.132, 0.19800003, 0.22352941)
z_index = -1
texture = ExtResource("9_4w656")
offset = Vector2(7, 6)

[node name="SinkFloorShadow" type="Sprite2D" parent="HospitalBathroomSink"]
position = Vector2(4.9997253, 416)
scale = Vector2(12.0937605, 2.1250005)
texture = SubResource("GradientTexture2D_abqjc")

[node name="Burger" parent="." instance=ExtResource("2_lquwl")]
visible = false
position = Vector2(-699, 755)
object_display_name = "Burger"
object_id = "burger"

[node name="ObjectSprite" parent="Burger" index="0"]
scale = Vector2(0.0377778, 0.0377778)
texture = ExtResource("3_7mycd")

[node name="Rusty Key" parent="." instance=ExtResource("2_lquwl")]
visible = false
z_index = 1805
position = Vector2(-339, 28)
scale = Vector2(4.125, 4.125)
object_display_name = "Rusty Key"
object_id = "key_rusty_world"
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_h8e4i")])

[node name="ObjectSprite" parent="Rusty Key" index="0"]
scale = Vector2(0.0377778, 0.0377778)
texture = ExtResource("3_7mycd")

[node name="CollisionShape2D" parent="Rusty Key" index="1"]
z_index = 15

[node name="Floor" type="StaticBody2D" parent="."]
position = Vector2(220, -515)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Floor"]
position = Vector2(3609.5, 834)
shape = SubResource("RectangleShape2D_pjluw")
debug_color = Color(0.581501, 0.477937, 0.264005, 0.419608)

[node name="StaticBody2D" type="StaticBody2D" parent="."]
position = Vector2(0, 2338)

[node name="CollisionShape2D" type="CollisionShape2D" parent="StaticBody2D"]
position = Vector2(53.5, 12)
shape = SubResource("RectangleShape2D_0cbny")

[node name="faye" parent="." instance=ExtResource("2_lquwl")]
visible = false
position = Vector2(921, -355)
scale = Vector2(6.595, 6.595)
object_display_name = "Faye"
object_id = "faye"
category = 1

[node name="ObjectSprite" parent="faye" index="0"]
scale = Vector2(0.0377778, 0.0377778)
texture = ExtResource("7_272bh")

[node name="WalkToPoint" parent="faye" index="2"]
position = Vector2(-1, 11)

[node name="HospitalBathroomMirror" parent="." instance=ExtResource("16_blkrb")]
position = Vector2(-495, 1879)
scale = Vector2(0.5, 0.5)
object_display_name = "Bathroom Mirror"
object_id = "bathroom_mirror"

[node name="Left wall" type="StaticBody2D" parent="."]
position = Vector2(-974, 49)
scale = Vector2(0.0427764, 8.83949)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Left wall"]
position = Vector2(-2641.6563, -21.1551)
shape = SubResource("RectangleShape2D_pjluw")
debug_color = Color(0.581501, 0.477937, 0.264005, 0.419608)

[node name="Bathroom Left wall" type="StaticBody2D" parent="."]
unique_name_in_owner = true
position = Vector2(-860, 2104)
scale = Vector2(0.0427764, 8.83949)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Bathroom Left wall"]
position = Vector2(-2641.6563, -22.06013)
shape = SubResource("RectangleShape2D_pjluw")
debug_color = Color(0.581501, 0.477937, 0.264005, 0.419608)

[node name="Right Wall" type="StaticBody2D" parent="."]
position = Vector2(8989, 61)
scale = Vector2(0.0427764, 8.83949)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Right Wall"]
position = Vector2(-4114.42, -21.1551)
shape = SubResource("RectangleShape2D_pjluw")
debug_color = Color(0.581501, 0.477937, 0.264005, 0.419608)

[node name="ExitDoor2" parent="." instance=ExtResource("30_pjyto")]
position = Vector2(143, 1948)
scale = Vector2(0.43, 0.43)
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_wat4s"), SubResource("Resource_dij0e"), SubResource("Resource_inymm")])

[node name="Bathroom Right Wall" type="StaticBody2D" parent="."]
unique_name_in_owner = true
position = Vector2(1422, 2110)
scale = Vector2(0.0427764, 8.83949)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Bathroom Right Wall"]
position = Vector2(-3857.2656, -22.85203)
shape = SubResource("RectangleShape2D_pjluw")
debug_color = Color(0.581501, 0.477937, 0.264005, 0.419608)

[node name="Aida_Path" type="Node2D" parent="."]
position = Vector2(-25, 54)
scale = Vector2(0.5, 0.5)

[node name="AIda" parent="Aida_Path" instance=ExtResource("8_vivmo")]
position = Vector2(9658, -52)
scale = Vector2(0.98, 0.98)

[node name="MovementController" parent="Aida_Path/AIda" index="2"]
movement_speed = 250.0
wait_duration = 15.0
waypoints = Array[NodePath]([NodePath("../../Waypoint1"), NodePath("../../Waypoint2")])

[node name="InteractionArea" parent="Aida_Path/AIda" index="3"]
script = ExtResource("16_2cqfq")
object_display_name = "AIda"
object_id = "AIda"
category = 1
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_wnkbs")])
character_conversation_overlay_scene = ExtResource("16_come4")

[node name="Waypoint1" type="Marker2D" parent="Aida_Path"]
position = Vector2(10646, -32)

[node name="Waypoint2" type="Marker2D" parent="Aida_Path"]
position = Vector2(5456, -32)

[node name="Sergei_Path" type="Node2D" parent="."]
z_index = 1
position = Vector2(-3413, 201)

[node name="Sergei" parent="Sergei_Path" instance=ExtResource("10_getpj")]
position = Vector2(11404, 86)

[node name="InteractionArea" parent="Sergei_Path/Sergei" index="2"]
script = ExtResource("16_2cqfq")
object_display_name = "Sergei"
object_id = "sergei"
category = 1
interactions = Array[ExtResource("24_qsp4k")]([SubResource("Resource_htxhm"), SubResource("Resource_0cbny")])
character_conversation_overlay_scene = ExtResource("20_h8e4i")

[node name="InteractionClickShape" parent="Sergei_Path/Sergei/InteractionArea" index="0"]
position = Vector2(159, -196)

[node name="Sprite2D" parent="Sergei_Path/Sergei" index="3"]
position = Vector2(-27.99999, -172)

[node name="MedicineCabinet2" parent="." instance=ExtResource("12_a6jrf")]
position = Vector2(890, 3)
scale = Vector2(0.735, 0.735)
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_1vm84"), SubResource("Resource_5dllo"), SubResource("Resource_jx0wj"), SubResource("Resource_ok6jj"), SubResource("Resource_wu3dr")])

[node name="McBucket_Path" type="Node2D" parent="."]
position = Vector2(770, 91)
scale = Vector2(0.6, 0.6)

[node name="McBucket" parent="McBucket_Path" instance=ExtResource("13_0odxb")]

[node name="InteractionArea" parent="McBucket_Path/McBucket" index="2"]
script = ExtResource("16_2cqfq")
object_display_name = "mcbucket"
object_id = "mcbucket"
category = 1
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_0n3wm"), SubResource("Resource_abqjc"), SubResource("Resource_wy5fy")])
character_conversation_overlay_scene = ExtResource("22_facbu")

[node name="Sprite2D" parent="McBucket_Path/McBucket" index="3"]
z_index = 1

[node name="MedicineCabinet" parent="." instance=ExtResource("17_074og")]
z_index = -1
position = Vector2(2605.0002, -114.99999)
scale = Vector2(0.45, 0.45)
interactions = Array[ExtResource("24_qsp4k")]([SubResource("Resource_kq58d"), SubResource("Resource_0arob"), SubResource("Resource_d2t1y")])
object_zoom_overlay_scene = ExtResource("14_cegan")

[node name="Player" parent="." instance=ExtResource("1_pgf6g")]
position = Vector2(3950, 90)
scale = Vector2(0.5, 0.5)

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(4394, 0)
process_callback = 0
limit_left = -100000
limit_top = -100000
limit_right = 100000
limit_bottom = 100000
limit_smoothed = true
position_smoothing_enabled = true
script = ExtResource("2_h2yge")
target_path = NodePath("../Player")

[node name="HaveMoreLogo" parent="." instance=ExtResource("18_d13ii")]
visible = false
position = Vector2(2535, -329)
scale = Vector2(0.16, 0.16)

[node name="LevelStateManager" type="Node" parent="."]
script = ExtResource("10_4c57u")

[node name="Tubelight" parent="." instance=ExtResource("14_w48qg")]
position = Vector2(-416, -549)
scale = Vector2(0.76, 0.76)

[node name="VerbUI_CanvasLayer" parent="." instance=ExtResource("1_1bvp3")]
unique_name_in_owner = true
layer = 2

[node name="InventoryUI_CanvasLayer" parent="." instance=ExtResource("2_kek77")]
unique_name_in_owner = true
layer = 2

[node name="ExplanationLayer" parent="." instance=ExtResource("38_d2t1y")]
unique_name_in_owner = true

[node name="TransitionLayer" parent="." instance=ExtResource("41_hrvbo")]
unique_name_in_owner = true

[node name="TestBox" parent="." instance=ExtResource("23_0odxb")]
visible = false
position = Vector2(-507, 18)
object_display_name = "testbox"
object_id = "testbox"
interactions = Array[ExtResource("24_qsp4k")]([SubResource("Resource_4k2k6"), SubResource("Resource_uypp3")])

[node name="SergeiMedicineDispenser" parent="." instance=ExtResource("27_a6jrf")]
z_index = -1
position = Vector2(7870, -32)
scale = Vector2(0.735, 0.735)

[node name="ExitDoor" parent="." instance=ExtResource("40_h8e4i")]
z_index = -1
position = Vector2(40, -91)
scale = Vector2(0.43, 0.43)
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_rnkwl")])

[node name="InsuranceFormButtonUI" parent="." instance=ExtResource("41_4lmeg")]
unique_name_in_owner = true

[node name="NotificationContainer" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -144.0
offset_top = 72.0
offset_right = -104.0
offset_bottom = 112.0
grow_horizontal = 0

[node name="MemoryBox" parent="." instance=ExtResource("44_gngh3")]
z_index = -10
position = Vector2(5643, 6.0000005)
scale = Vector2(0.8, 0.8)
object_display_name = "Memory Box"
object_id = "MemoryBox"
interactions = Array[ExtResource("24_qsp4k")]([ExtResource("7_jq2sk"), SubResource("Resource_b17eg"), SubResource("Resource_ruth0"), SubResource("Resource_sm6fg")])

[node name="television_screen" parent="." instance=ExtResource("48_f6a44")]
z_index = -1
position = Vector2(1551, -207)
scale = Vector2(0.8, 0.8)

[node name="HospitalBed" type="Sprite2D" parent="."]
position = Vector2(3832, 181)
scale = Vector2(0.8, 0.8)
texture = ExtResource("47_wnkbs")

[node name="BathroomSpawnPoint" type="Marker2D" parent="."]
position = Vector2(132, 2092)

[node name="ClinicSpawnPoint1" type="Marker2D" parent="."]
position = Vector2(40, -17)

[node name="Cutscenes" type="Node" parent="."]

[node name="ToiletClogCutscene" type="Node" parent="Cutscenes" node_paths=PackedStringArray("aida_npc", "player", "toilet_interactable", "main_room_door_pos", "player_spawn_pos", "bathroom_entry_pos", "toilet_fix_pos", "main_room_return_pos")]
script = ExtResource("63_sm6fg")
aida_npc = NodePath("../../Aida_Path/AIda")
player = NodePath("../../Player")
toilet_interactable = NodePath("../../HospitalToilet/InteractionArea")
main_room_door_pos = NodePath("../../AidaDoorWaitPos")
player_spawn_pos = NodePath("../../ClinicSpawnPoint1")
bathroom_entry_pos = NodePath("../../BathroomSpawnPoint")
toilet_fix_pos = NodePath("../../HospitalToilet/WalkToPoint")
main_room_return_pos = NodePath("../../ClinicSpawnPoint1")
aida_scold_dialogue = ExtResource("64_b17eg")
scold_dialogue_start_id = "test"
fix_duration = 15.0

[node name="AidaDoorWaitPos" type="Marker2D" parent="."]
position = Vector2(279, 0)

[editable path="HospitalToilet"]
[editable path="HospitalBathroomSink"]
[editable path="Burger"]
[editable path="Rusty Key"]
[editable path="faye"]
[editable path="Aida_Path/AIda"]
[editable path="Sergei_Path/Sergei"]
[editable path="McBucket_Path/McBucket"]
[editable path="InventoryUI_CanvasLayer"]
[editable path="InsuranceFormButtonUI"]
</file>

</files>
